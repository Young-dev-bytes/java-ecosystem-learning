{"version":3,"file":"extension.js","mappings":"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","sources":["webpack://debug-auto-launch/external commonjs \"vscode\"","webpack://debug-auto-launch/external node-commonjs \"fs\"","webpack://debug-auto-launch/external node-commonjs \"net\"","webpack://debug-auto-launch/external node-commonjs \"path\"","webpack://debug-auto-launch/webpack/bootstrap","webpack://debug-auto-launch/./src/extension.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"fs\");","module.exports = require(\"net\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { promises as fs } from 'fs';\nimport { createServer, Server } from 'net';\nimport { dirname } from 'path';\nimport * as vscode from 'vscode';\n\nconst enum State {\n\tDisabled = 'disabled',\n\tOnlyWithFlag = 'onlyWithFlag',\n\tSmart = 'smart',\n\tAlways = 'always',\n}\nconst TEXT_STATUSBAR_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Auto Attach: Disabled'),\n\t[State.Always]: vscode.l10n.t('Auto Attach: Always'),\n\t[State.Smart]: vscode.l10n.t('Auto Attach: Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Auto Attach: With Flag'),\n};\n\nconst TEXT_STATE_LABEL = {\n\t[State.Disabled]: vscode.l10n.t('Disabled'),\n\t[State.Always]: vscode.l10n.t('Always'),\n\t[State.Smart]: vscode.l10n.t('Smart'),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only With Flag'),\n};\nconst TEXT_STATE_DESCRIPTION = {\n\t[State.Disabled]: vscode.l10n.t('Auto attach is disabled and not shown in status bar'),\n\t[State.Always]: vscode.l10n.t('Auto attach to every Node.js process launched in the terminal'),\n\t[State.Smart]: vscode.l10n.t(\"Auto attach when running scripts that aren't in a node_modules folder\"),\n\t[State.OnlyWithFlag]: vscode.l10n.t('Only auto attach when the `--inspect` flag is given')\n};\nconst TEXT_TOGGLE_WORKSPACE = vscode.l10n.t('Toggle auto attach in this workspace');\nconst TEXT_TOGGLE_GLOBAL = vscode.l10n.t('Toggle auto attach on this machine');\nconst TEXT_TEMP_DISABLE = vscode.l10n.t('Temporarily disable auto attach in this session');\nconst TEXT_TEMP_ENABLE = vscode.l10n.t('Re-enable auto attach');\nconst TEXT_TEMP_DISABLE_LABEL = vscode.l10n.t('Auto Attach: Disabled');\n\nconst TOGGLE_COMMAND = 'extension.node-debug.toggleAutoAttach';\nconst STORAGE_IPC = 'jsDebugIpcState';\n\nconst SETTING_SECTION = 'debug.javascript';\nconst SETTING_STATE = 'autoAttachFilter';\n\n/**\n * settings that, when changed, should cause us to refresh the state vars\n */\nconst SETTINGS_CAUSE_REFRESH = new Set(\n\t['autoAttachSmartPattern', SETTING_STATE].map(s => `${SETTING_SECTION}.${s}`),\n);\n\n\nlet currentState: Promise<{ context: vscode.ExtensionContext; state: State | null }>;\nlet statusItem: vscode.StatusBarItem | undefined; // and there is no status bar item\nlet server: Promise<Server | undefined> | undefined; // auto attach server\nlet isTemporarilyDisabled = false; // whether the auto attach server is disabled temporarily, reset whenever the state changes\n\nexport function activate(context: vscode.ExtensionContext): void {\n\tcurrentState = Promise.resolve({ context, state: null });\n\n\tcontext.subscriptions.push(\n\t\tvscode.commands.registerCommand(TOGGLE_COMMAND, toggleAutoAttachSetting.bind(null, context)),\n\t);\n\n\tcontext.subscriptions.push(\n\t\tvscode.workspace.onDidChangeConfiguration(e => {\n\t\t\t// Whenever a setting is changed, disable auto attach, and re-enable\n\t\t\t// it (if necessary) to refresh variables.\n\t\t\tif (\n\t\t\t\te.affectsConfiguration(`${SETTING_SECTION}.${SETTING_STATE}`) ||\n\t\t\t\t[...SETTINGS_CAUSE_REFRESH].some(setting => e.affectsConfiguration(setting))\n\t\t\t) {\n\t\t\t\trefreshAutoAttachVars();\n\t\t\t}\n\t\t}),\n\t);\n\n\tupdateAutoAttach(readCurrentState());\n}\n\nexport async function deactivate(): Promise<void> {\n\tawait destroyAttachServer();\n}\n\nfunction refreshAutoAttachVars() {\n\tupdateAutoAttach(State.Disabled);\n\tupdateAutoAttach(readCurrentState());\n}\n\nfunction getDefaultScope(info: ReturnType<vscode.WorkspaceConfiguration['inspect']>) {\n\tif (!info) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t} else if (info.workspaceFolderValue) {\n\t\treturn vscode.ConfigurationTarget.WorkspaceFolder;\n\t} else if (info.workspaceValue) {\n\t\treturn vscode.ConfigurationTarget.Workspace;\n\t} else if (info.globalValue) {\n\t\treturn vscode.ConfigurationTarget.Global;\n\t}\n\n\treturn vscode.ConfigurationTarget.Global;\n}\n\ntype PickResult = { state: State } | { setTempDisabled: boolean } | { scope: vscode.ConfigurationTarget } | undefined;\ntype PickItem = vscode.QuickPickItem & ({ state: State } | { setTempDisabled: boolean });\n\nasync function toggleAutoAttachSetting(context: vscode.ExtensionContext, scope?: vscode.ConfigurationTarget): Promise<void> {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tscope = scope || getDefaultScope(section.inspect(SETTING_STATE));\n\n\tconst isGlobalScope = scope === vscode.ConfigurationTarget.Global;\n\tconst quickPick = vscode.window.createQuickPick<PickItem>();\n\tconst current = readCurrentState();\n\n\tconst items: PickItem[] = [State.Always, State.Smart, State.OnlyWithFlag, State.Disabled].map(state => ({\n\t\tstate,\n\t\tlabel: TEXT_STATE_LABEL[state],\n\t\tdescription: TEXT_STATE_DESCRIPTION[state],\n\t\talwaysShow: true,\n\t}));\n\n\tif (current !== State.Disabled) {\n\t\titems.unshift({\n\t\t\tsetTempDisabled: !isTemporarilyDisabled,\n\t\t\tlabel: isTemporarilyDisabled ? TEXT_TEMP_ENABLE : TEXT_TEMP_DISABLE,\n\t\t\talwaysShow: true,\n\t\t});\n\t}\n\n\tquickPick.items = items;\n\tquickPick.activeItems = isTemporarilyDisabled\n\t\t? [items[0]]\n\t\t: quickPick.items.filter(i => 'state' in i && i.state === current);\n\tquickPick.title = isGlobalScope ? TEXT_TOGGLE_GLOBAL : TEXT_TOGGLE_WORKSPACE;\n\tquickPick.buttons = [\n\t\t{\n\t\t\ticonPath: new vscode.ThemeIcon(isGlobalScope ? 'folder' : 'globe'),\n\t\t\ttooltip: isGlobalScope ? TEXT_TOGGLE_WORKSPACE : TEXT_TOGGLE_GLOBAL,\n\t\t},\n\t];\n\n\tquickPick.show();\n\n\tlet result = await new Promise<PickResult>(resolve => {\n\t\tquickPick.onDidAccept(() => resolve(quickPick.selectedItems[0]));\n\t\tquickPick.onDidHide(() => resolve(undefined));\n\t\tquickPick.onDidTriggerButton(() => {\n\t\t\tresolve({\n\t\t\t\tscope: isGlobalScope\n\t\t\t\t\t? vscode.ConfigurationTarget.Workspace\n\t\t\t\t\t: vscode.ConfigurationTarget.Global,\n\t\t\t});\n\t\t});\n\t});\n\n\tquickPick.dispose();\n\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tif ('scope' in result) {\n\t\treturn await toggleAutoAttachSetting(context, result.scope);\n\t}\n\n\tif ('state' in result) {\n\t\tif (result.state !== current) {\n\t\t\tsection.update(SETTING_STATE, result.state, scope);\n\t\t} else if (isTemporarilyDisabled) {\n\t\t\tresult = { setTempDisabled: false };\n\t\t}\n\t}\n\n\tif ('setTempDisabled' in result) {\n\t\tupdateStatusBar(context, current, true);\n\t\tisTemporarilyDisabled = result.setTempDisabled;\n\t\tif (result.setTempDisabled) {\n\t\t\tawait destroyAttachServer();\n\t\t} else {\n\t\t\tawait createAttachServer(context); // unsets temp disabled var internally\n\t\t}\n\t\tupdateStatusBar(context, current, false);\n\t}\n}\n\nfunction readCurrentState(): State {\n\tconst section = vscode.workspace.getConfiguration(SETTING_SECTION);\n\treturn section.get<State>(SETTING_STATE) ?? State.Disabled;\n}\n\nasync function clearJsDebugAttachState(context: vscode.ExtensionContext) {\n\tif (server || await context.workspaceState.get(STORAGE_IPC)) {\n\t\tawait context.workspaceState.update(STORAGE_IPC, undefined);\n\t\tawait vscode.commands.executeCommand('extension.js-debug.clearAutoAttachVariables');\n\t\tawait destroyAttachServer();\n\t}\n}\n\n/**\n * Turns auto attach on, and returns the server auto attach is listening on\n * if it's successful.\n */\nasync function createAttachServer(context: vscode.ExtensionContext) {\n\tconst ipcAddress = await getIpcAddress(context);\n\tif (!ipcAddress) {\n\t\treturn undefined;\n\t}\n\n\tserver = createServerInner(ipcAddress).catch(async err => {\n\t\tconsole.error('[debug-auto-launch] Error creating auto attach server: ', err);\n\n\t\tif (process.platform !== 'win32') {\n\t\t\t// On macOS, and perhaps some Linux distros, the temporary directory can\n\t\t\t// sometimes change. If it looks like that's the cause of a listener\n\t\t\t// error, automatically refresh the auto attach vars.\n\t\t\ttry {\n\t\t\t\tawait fs.access(dirname(ipcAddress));\n\t\t\t} catch {\n\t\t\t\tconsole.error('[debug-auto-launch] Refreshing variables from error');\n\t\t\t\trefreshAutoAttachVars();\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t});\n\n\treturn await server;\n}\n\nconst createServerInner = async (ipcAddress: string) => {\n\ttry {\n\t\treturn await createServerInstance(ipcAddress);\n\t} catch (e) {\n\t\t// On unix/linux, the file can 'leak' if the process exits unexpectedly.\n\t\t// If we see this, try to delete the file and then listen again.\n\t\tawait fs.unlink(ipcAddress).catch(() => undefined);\n\t\treturn await createServerInstance(ipcAddress);\n\t}\n};\n\nconst createServerInstance = (ipcAddress: string) =>\n\tnew Promise<Server>((resolve, reject) => {\n\t\tconst s = createServer(socket => {\n\t\t\tconst data: Buffer[] = [];\n\t\t\tsocket.on('data', async chunk => {\n\t\t\t\tif (chunk[chunk.length - 1] !== 0) {\n\t\t\t\t\t// terminated with NUL byte\n\t\t\t\t\tdata.push(chunk);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tdata.push(chunk.slice(0, -1));\n\n\t\t\t\ttry {\n\t\t\t\t\tawait vscode.commands.executeCommand(\n\t\t\t\t\t\t'extension.js-debug.autoAttachToProcess',\n\t\t\t\t\t\tJSON.parse(Buffer.concat(data).toString()),\n\t\t\t\t\t);\n\t\t\t\t\tsocket.write(Buffer.from([0]));\n\t\t\t\t} catch (err) {\n\t\t\t\t\tsocket.write(Buffer.from([1]));\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t});\n\t\t})\n\t\t\t.on('error', reject)\n\t\t\t.listen(ipcAddress, () => resolve(s));\n\t});\n\n/**\n * Destroys the auto-attach server, if it's running.\n */\nasync function destroyAttachServer() {\n\tconst instance = await server;\n\tif (instance) {\n\t\tawait new Promise(r => instance.close(r));\n\t}\n}\n\ninterface CachedIpcState {\n\tipcAddress: string;\n\tjsDebugPath: string;\n\tsettingsValue: string;\n}\n\n/**\n * Map of logic that happens when auto attach states are entered and exited.\n * All state transitions are queued and run in order; promises are awaited.\n */\nconst transitions: { [S in State]: (context: vscode.ExtensionContext) => Promise<void> } = {\n\tasync [State.Disabled](context) {\n\t\tawait clearJsDebugAttachState(context);\n\t},\n\n\tasync [State.OnlyWithFlag](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Smart](context) {\n\t\tawait createAttachServer(context);\n\t},\n\n\tasync [State.Always](context) {\n\t\tawait createAttachServer(context);\n\t},\n};\n\n/**\n * Ensures the status bar text reflects the current state.\n */\nfunction updateStatusBar(context: vscode.ExtensionContext, state: State, busy = false) {\n\tif (state === State.Disabled && !busy) {\n\t\tstatusItem?.hide();\n\t\treturn;\n\t}\n\n\tif (!statusItem) {\n\t\tstatusItem = vscode.window.createStatusBarItem('status.debug.autoAttach', vscode.StatusBarAlignment.Left);\n\t\tstatusItem.name = vscode.l10n.t(\"Debug Auto Attach\");\n\t\tstatusItem.command = TOGGLE_COMMAND;\n\t\tstatusItem.tooltip = vscode.l10n.t(\"Automatically attach to node.js processes in debug mode\");\n\t\tcontext.subscriptions.push(statusItem);\n\t}\n\n\tlet text = busy ? '$(loading) ' : '';\n\ttext += isTemporarilyDisabled ? TEXT_TEMP_DISABLE_LABEL : TEXT_STATUSBAR_LABEL[state];\n\tstatusItem.text = text;\n\tstatusItem.show();\n}\n\n/**\n * Updates the auto attach feature based on the user or workspace setting\n */\nfunction updateAutoAttach(newState: State) {\n\tcurrentState = currentState.then(async ({ context, state: oldState }) => {\n\t\tif (newState === oldState) {\n\t\t\treturn { context, state: oldState };\n\t\t}\n\n\t\tif (oldState !== null) {\n\t\t\tupdateStatusBar(context, oldState, true);\n\t\t}\n\n\t\tawait transitions[newState](context);\n\t\tisTemporarilyDisabled = false;\n\t\tupdateStatusBar(context, newState, false);\n\t\treturn { context, state: newState };\n\t});\n}\n\n/**\n * Gets the IPC address for the server to listen on for js-debug sessions. This\n * is cached such that we can reuse the address of previous activations.\n */\nasync function getIpcAddress(context: vscode.ExtensionContext) {\n\t// Iff the `cachedData` is present, the js-debug registered environment\n\t// variables for this workspace--cachedData is set after successfully\n\t// invoking the attachment command.\n\tconst cachedIpc = context.workspaceState.get<CachedIpcState>(STORAGE_IPC);\n\n\t// We invalidate the IPC data if the js-debug path changes, since that\n\t// indicates the extension was updated or reinstalled and the\n\t// environment variables will have been lost.\n\t// todo: make a way in the API to read environment data directly without activating js-debug?\n\tconst jsDebugPath =\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug-nightly')?.extensionPath ||\n\t\tvscode.extensions.getExtension('ms-vscode.js-debug')?.extensionPath;\n\n\tconst settingsValue = getJsDebugSettingKey();\n\tif (cachedIpc?.jsDebugPath === jsDebugPath && cachedIpc?.settingsValue === settingsValue) {\n\t\treturn cachedIpc.ipcAddress;\n\t}\n\n\tconst result = await vscode.commands.executeCommand<{ ipcAddress: string }>(\n\t\t'extension.js-debug.setAutoAttachVariables',\n\t\tcachedIpc?.ipcAddress,\n\t);\n\tif (!result) {\n\t\treturn;\n\t}\n\n\tconst ipcAddress = result.ipcAddress;\n\tawait context.workspaceState.update(STORAGE_IPC, {\n\t\tipcAddress,\n\t\tjsDebugPath,\n\t\tsettingsValue,\n\t} as CachedIpcState);\n\n\treturn ipcAddress;\n}\n\nfunction getJsDebugSettingKey() {\n\tconst o: { [key: string]: unknown } = {};\n\tconst config = vscode.workspace.getConfiguration(SETTING_SECTION);\n\tfor (const setting of SETTINGS_CAUSE_REFRESH) {\n\t\to[setting] = config.get(setting);\n\t}\n\n\treturn JSON.stringify(o);\n}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","context","currentState","Promise","resolve","state","subscriptions","push","vscode","commands","registerCommand","TOGGLE_COMMAND","toggleAutoAttachSetting","bind","workspace","onDidChangeConfiguration","e","affectsConfiguration","SETTING_SECTION","SETTING_STATE","SETTINGS_CAUSE_REFRESH","some","setting","refreshAutoAttachVars","updateAutoAttach","readCurrentState","async","destroyAttachServer","TEXT_STATUSBAR_LABEL","l10n","t","TEXT_STATE_LABEL","TEXT_STATE_DESCRIPTION","TEXT_TOGGLE_WORKSPACE","TEXT_TOGGLE_GLOBAL","TEXT_TEMP_DISABLE","TEXT_TEMP_ENABLE","TEXT_TEMP_DISABLE_LABEL","STORAGE_IPC","Set","map","s","statusItem","server","isTemporarilyDisabled","scope","section","getConfiguration","info","isGlobalScope","inspect","workspaceFolderValue","ConfigurationTarget","WorkspaceFolder","workspaceValue","Workspace","globalValue","Global","quickPick","window","createQuickPick","current","items","label","description","alwaysShow","unshift","setTempDisabled","activeItems","filter","i","title","buttons","iconPath","ThemeIcon","tooltip","show","result","onDidAccept","selectedItems","onDidHide","onDidTriggerButton","dispose","update","updateStatusBar","createAttachServer","get","ipcAddress","cachedIpc","workspaceState","jsDebugPath","extensions","getExtension","extensionPath","settingsValue","o","config","JSON","stringify","getJsDebugSettingKey","executeCommand","getIpcAddress","createServerInner","catch","err","console","error","process","platform","access","dirname","createServerInstance","unlink","reject","createServer","socket","data","on","chunk","length","slice","parse","Buffer","concat","toString","write","from","listen","instance","r","close","transitions","clearJsDebugAttachState","busy","hide","createStatusBarItem","StatusBarAlignment","Left","name","command","text","newState","then","oldState"],"sourceRoot":""}