<p>As I'm always committed to bringing you the most relevant and real-life examples, in the previous lecture we touched upon a few other very important topics beyond Multithreading like color spaces, bit-shifting and binary algebra. Since these topics are very frequently used in the industry (as well as in job interviews), this guide will provide a more in-detail explanation of those parts of the Image Processing Example.</p><h4><strong>Pixels and Color Space Background</strong></h4><p>In digital imaging, a <strong>Pixel </strong>represents the smallest element of a picture displayed on the screen.</p><p>An image is nothing more than a 2-dimensional collection of Pixels.</p><p>The color of a pixel can be encoded in different ways.</p><p>A few frequently used groups of pixel color encoding are:</p><ul><li><p><a href="https://en.wikipedia.org/wiki/YUV" rel="noopener noreferrer" target="_blank">Y'UV</a> - <strong>Luma</strong> (brightness), and 2 <strong>chroma</strong> (color) components </p></li><li><p><a href="https://en.wikipedia.org/wiki/RGB_color_model" rel="noopener noreferrer" target="_blank">RGB</a> - <strong>Red, Green, Blue</strong></p></li><li><p><a href="https://en.wikipedia.org/wiki/HSL_and_HSV" rel="noopener noreferrer" target="_blank">HSL and HSV</a> - <strong>Hue, Saturation, Lightness/Brightness</strong></p></li><li><p><a href="https://www.colourphil.co.uk/xyz_colour_space.shtml" rel="noopener noreferrer" target="_blank">CIE XYZ</a>&nbsp; - Device independent <strong>Red</strong>, <strong>Green</strong> and <strong>Blue</strong></p></li></ul><h4><strong>ARGB Memory Representation</strong></h4><p>The format used in our Image Processing example is a version of the RGB family called ARGB, where A stands for alpha (transparency)</p><p>The representation of this color in memory is as follows:</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-03_22-28-43-915490ddeaac0c502fe7366f804a839f.png"></figure><p>As we can see, each component is represented by 1 byte (8 bits) so the value of each component is in the range of 0 (0x in hexadecimal) and 255 (0xFF in hexadecimal)</p><p>Since we have 4 bytes, we can store the entire color of a pixel in a variable of type <code>int</code>.</p><h4><strong>Component Extraction Code Explanation</strong></h4><p>In the Image Processing example we have the following methods that extract individual components of a pixel:</p><pre class="prettyprint linenums">public static int getRed(int rgb) {
    return (rgb &amp; 0x00FF0000) &gt;&gt; 16;
}

public static int getGreen(int rgb) {
    return (rgb &amp; 0x0000FF00) &gt;&gt; 8;
}

public static int getBlue(int rgb) {
    return rgb &amp; 0x000000FF;
}</pre><p>Let's explain each method, in particular the math that happens to get each color component.</p><p>In order to get a particular component (red, green, or blue), we need to first get rid of all the other color components in the pixel, while keeping the desired component.</p><p>To achieve this we apply a <strong>bitmask</strong>.</p><p><strong>A bitmask defines which bits we want to keep, and which bits we want to clear.</strong></p><p>We apply a bitwise AND with <strong>0x00</strong> (0000 0000 in binary) to get rid of a component since <strong>X AND 0 = 0, for any X</strong>.</p><p>We apply a bitwise AND with <strong>0xFF</strong> (1111 1111 in binary) to keep the value of a component since <strong>X AND 1 = X, for any X</strong>.</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-03_23-42-35-d36bb6e358d5345e51e982230bb969b9.png"></figure><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-03_23-42-48-0f7f7c81ee76d0cca9eebabd87820b0b.png"></figure><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-03_23-44-15-775423d393e4f4d47472c77b42b11510.png"></figure><p>However, after applying a bitmask we are not done. We still need to shift the byte representing our component to the lowest byte.</p><p>For example in the <code>getRed(..)</code> method, after we apply the bitmask on 0x76<strong>54</strong>3210 we end up with 0x00<strong>54</strong>0000, but what we need is 0x000000<strong>54</strong></p><p>So we need to <strong>shift</strong> all the bits in the result of the bitmask to the <strong>right</strong>., using the <code>&gt;&gt;</code> operator.</p><ul><li><p>For the blue color extraction, we don't need to perform any shifting since it's already the right-most byte.</p></li><li><p>For the green color extraction, we need to move all the bits 1 byte (8 bits) to the right.</p></li><li><p>For the red color extraction, we need to move all the bits 2 bytes (16 bits) to the right.</p></li></ul><h4><strong>Combining Color Components into a Pixel</strong></h4><p>When building a pixel's color from individual red, green and blue components we had the following method:</p><pre class="prettyprint linenums">public static int createRGBFromColors(int red, int green, int blue) {
    int rgb = 0;

    rgb |= blue;
    rgb |= green &lt;&lt; 8;
    rgb |= red &lt;&lt; 16;

    rgb |= 0xFF000000;

    return rgb;
}</pre><p>In the above code, we perform the opposite of color component extraction. We take each component and shift it to the right place in the ARGB pixel representation.</p><ul><li><p>Blue is placed at the lowest byte so we simply bitwise OR the pixel color representation with the blue component</p></li><li><p>Green needs to be placed at the second byte so it is first shifted 1 byte (8 bits) to the left, and then is bitwise ORed with the pixel color</p></li><li><p>Similarly, red needs to be placed at the third byte so its component is shifted 2 bytes (16 bits) to the left, and then it is bitwise ORed with the pixel color</p></li></ul><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-04_17-14-40-53920bfee8a26882b7405594bf71a86a.png"></figure><p>The final step is to set the transparency level to the highest, making the color completely opaque (0 levels mean fully transparent, 255 means fully opaque).</p><p>That is achieved by setting the left-most byte, representing the alpha component to 0xFF which is 1111 1111 in binary.</p><figure><img src="https://img-c.udemycdn.com/redactor/raw/article_lecture/2021-07-04_17-34-01-ba7570e9b96d9cfe33beb342a818e110.png"></figure>