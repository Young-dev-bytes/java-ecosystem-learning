{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/fake","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/amd.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/debugName.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/logging.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/autorun.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/base.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/derived.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/utils.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observableInternal/promise.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/observable.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/stream.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/buffer.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/amdX.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/core/eolCounter.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/encodedTokenAttributes.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/fixedArray.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/lineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousTokensEditing.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/tokens/contiguousMultilineTokensBuilder.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/languages/nullTokenize.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/editor/common/model/textModelTokens.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateWorkerTokenizer.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMScopeRegistry.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/common/TMGrammarFactory.ts","out-vscode-reh-web/vs/workbench/services/textMate/browser/backgroundTokenization/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// ESM-comment-begin\nexport const isESM = false;\n// ESM-comment-end\n// ESM-uncomment-begin\n// export const isESM = true;\n// ESM-uncomment-end\n\nexport abstract class LoaderStats {\n\tabstract get amdLoad(): [string, number][];\n\tabstract get amdInvoke(): [string, number][];\n\tabstract get nodeRequire(): [string, number][];\n\tabstract get nodeEval(): [string, number][];\n\tabstract get nodeRequireTotal(): number;\n\n\tstatic get(): LoaderStats {\n\t\tconst amdLoadScript = new Map<string, number>();\n\t\tconst amdInvokeFactory = new Map<string, number>();\n\t\tconst nodeRequire = new Map<string, number>();\n\t\tconst nodeEval = new Map<string, number>();\n\n\t\tfunction mark(map: Map<string, number>, stat: LoaderEvent) {\n\t\t\tif (map.has(stat.detail)) {\n\t\t\t\t// console.warn('BAD events, DOUBLE start', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(stat.detail, -stat.timestamp);\n\t\t}\n\n\t\tfunction diff(map: Map<string, number>, stat: LoaderEvent) {\n\t\t\tconst duration = map.get(stat.detail);\n\t\t\tif (!duration) {\n\t\t\t\t// console.warn('BAD events, end WITHOUT start', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (duration >= 0) {\n\t\t\t\t// console.warn('BAD events, DOUBLE end', stat);\n\t\t\t\t// map.delete(stat.detail);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmap.set(stat.detail, duration + stat.timestamp);\n\t\t}\n\n\t\tlet stats: readonly LoaderEvent[] = [];\n\t\tif (typeof require === 'function' && typeof require.getStats === 'function') {\n\t\t\tstats = require.getStats().slice(0).sort((a, b) => a.timestamp - b.timestamp);\n\t\t}\n\n\t\tfor (const stat of stats) {\n\t\t\tswitch (stat.type) {\n\t\t\t\tcase LoaderEventType.BeginLoadingScript:\n\t\t\t\t\tmark(amdLoadScript, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.EndLoadingScriptOK:\n\t\t\t\tcase LoaderEventType.EndLoadingScriptError:\n\t\t\t\t\tdiff(amdLoadScript, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.BeginInvokeFactory:\n\t\t\t\t\tmark(amdInvokeFactory, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.EndInvokeFactory:\n\t\t\t\t\tdiff(amdInvokeFactory, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.NodeBeginNativeRequire:\n\t\t\t\t\tmark(nodeRequire, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.NodeEndNativeRequire:\n\t\t\t\t\tdiff(nodeRequire, stat);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LoaderEventType.NodeBeginEvaluatingScript:\n\t\t\t\t\tmark(nodeEval, stat);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LoaderEventType.NodeEndEvaluatingScript:\n\t\t\t\t\tdiff(nodeEval, stat);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tlet nodeRequireTotal = 0;\n\t\tnodeRequire.forEach(value => nodeRequireTotal += value);\n\n\t\tfunction to2dArray(map: Map<string, number>): [string, number][] {\n\t\t\tconst res: [string, number][] = [];\n\t\t\tmap.forEach((value, index) => res.push([index, value]));\n\t\t\treturn res;\n\t\t}\n\n\t\treturn {\n\t\t\tamdLoad: to2dArray(amdLoadScript),\n\t\t\tamdInvoke: to2dArray(amdInvokeFactory),\n\t\t\tnodeRequire: to2dArray(nodeRequire),\n\t\t\tnodeEval: to2dArray(nodeEval),\n\t\t\tnodeRequireTotal\n\t\t};\n\t}\n\n\tstatic toMarkdownTable(header: string[], rows: Array<Array<{ toString(): string } | undefined>>): string {\n\t\tlet result = '';\n\n\t\tconst lengths: number[] = [];\n\t\theader.forEach((cell, ci) => {\n\t\t\tlengths[ci] = cell.length;\n\t\t});\n\t\trows.forEach(row => {\n\t\t\trow.forEach((cell, ci) => {\n\t\t\t\tif (typeof cell === 'undefined') {\n\t\t\t\t\tcell = row[ci] = '-';\n\t\t\t\t}\n\t\t\t\tconst len = cell.toString().length;\n\t\t\t\tlengths[ci] = Math.max(len, lengths[ci]);\n\t\t\t});\n\t\t});\n\n\t\t// header\n\t\theader.forEach((cell, ci) => { result += `| ${cell + ' '.repeat(lengths[ci] - cell.toString().length)} `; });\n\t\tresult += '|\\n';\n\t\theader.forEach((_cell, ci) => { result += `| ${'-'.repeat(lengths[ci])} `; });\n\t\tresult += '|\\n';\n\n\t\t// cells\n\t\trows.forEach(row => {\n\t\t\trow.forEach((cell, ci) => {\n\t\t\t\tif (typeof cell !== 'undefined') {\n\t\t\t\t\tresult += `| ${cell + ' '.repeat(lengths[ci] - cell.toString().length)} `;\n\t\t\t\t}\n\t\t\t});\n\t\t\tresult += '|\\n';\n\t\t});\n\n\t\treturn result;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface IDebugNameData {\n\t/**\n\t * The owner object of an observable.\n\t * Used for debugging only, such as computing a name for the observable by iterating over the fields of the owner.\n\t */\n\treadonly owner?: Owner | undefined;\n\n\t/**\n\t * A string or function that returns a string that represents the name of the observable.\n\t * Used for debugging only.\n\t */\n\treadonly debugName?: DebugNameSource | undefined;\n\n\t/**\n\t * A function that points to the defining function of the object.\n\t * Used for debugging only.\n\t */\n\treadonly debugReferenceFn?: Function | undefined;\n}\n\nexport class DebugNameData {\n\tconstructor(\n\t\tpublic readonly owner: Owner | undefined,\n\t\tpublic readonly debugNameSource: DebugNameSource | undefined,\n\t\tpublic readonly referenceFn: Function | undefined,\n\t) { }\n\n\tpublic getDebugName(target: object): string | undefined {\n\t\treturn getDebugName(target, this);\n\t}\n}\n\n/**\n * The owner object of an observable.\n * Is only used for debugging purposes, such as computing a name for the observable by iterating over the fields of the owner.\n */\nexport type Owner = object | undefined;\nexport type DebugNameSource = string | (() => string | undefined);\n\nconst countPerName = new Map<string, number>();\nconst cachedDebugName = new WeakMap<object, string>();\n\nexport function getDebugName(target: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(target);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst dbgName = computeDebugName(target, data);\n\tif (dbgName) {\n\t\tlet count = countPerName.get(dbgName) ?? 0;\n\t\tcount++;\n\t\tcountPerName.set(dbgName, count);\n\t\tconst result = count === 1 ? dbgName : `${dbgName}#${count}`;\n\t\tcachedDebugName.set(target, result);\n\t\treturn result;\n\t}\n\treturn undefined;\n}\n\nfunction computeDebugName(self: object, data: DebugNameData): string | undefined {\n\tconst cached = cachedDebugName.get(self);\n\tif (cached) {\n\t\treturn cached;\n\t}\n\n\tconst ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n\n\tlet result: string | undefined;\n\tconst debugNameSource = data.debugNameSource;\n\tif (debugNameSource !== undefined) {\n\t\tif (typeof debugNameSource === 'function') {\n\t\t\tresult = debugNameSource();\n\t\t\tif (result !== undefined) {\n\t\t\t\treturn ownerStr + result;\n\t\t\t}\n\t\t} else {\n\t\t\treturn ownerStr + debugNameSource;\n\t\t}\n\t}\n\n\tconst referenceFn = data.referenceFn;\n\tif (referenceFn !== undefined) {\n\t\tresult = getFunctionName(referenceFn);\n\t\tif (result !== undefined) {\n\t\t\treturn ownerStr + result;\n\t\t}\n\t}\n\n\tif (data.owner !== undefined) {\n\t\tconst key = findKey(data.owner, self);\n\t\tif (key !== undefined) {\n\t\t\treturn ownerStr + key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nfunction findKey(obj: object, value: object): string | undefined {\n\tfor (const key in obj) {\n\t\tif ((obj as any)[key] === value) {\n\t\t\treturn key;\n\t\t}\n\t}\n\treturn undefined;\n}\n\nconst countPerClassName = new Map<string, number>();\nconst ownerId = new WeakMap<object, string>();\n\nfunction formatOwner(owner: object): string {\n\tconst id = ownerId.get(owner);\n\tif (id) {\n\t\treturn id;\n\t}\n\tconst className = getClassName(owner);\n\tlet count = countPerClassName.get(className) ?? 0;\n\tcount++;\n\tcountPerClassName.set(className, count);\n\tconst result = count === 1 ? className : `${className}#${count}`;\n\townerId.set(owner, result);\n\treturn result;\n}\n\nfunction getClassName(obj: object): string {\n\tconst ctor = obj.constructor;\n\tif (ctor) {\n\t\treturn ctor.name;\n\t}\n\treturn 'Object';\n}\n\nexport function getFunctionName(fn: Function): string | undefined {\n\tconst fnSrc = fn.toString();\n\t// Pattern: /** @description ... */\n\tconst regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n\tconst match = regexp.exec(fnSrc);\n\tconst result = match ? match[1] : undefined;\n\treturn result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { AutorunObserver } from 'vs/base/common/observableInternal/autorun';\nimport { IObservable, ObservableValue, TransactionImpl } from 'vs/base/common/observableInternal/base';\nimport { Derived } from 'vs/base/common/observableInternal/derived';\nimport { FromEventObservable } from 'vs/base/common/observableInternal/utils';\n\nlet globalObservableLogger: IObservableLogger | undefined;\n\nexport function setLogger(logger: IObservableLogger): void {\n\tglobalObservableLogger = logger;\n}\n\nexport function getLogger(): IObservableLogger | undefined {\n\treturn globalObservableLogger;\n}\n\ninterface IChangeInformation {\n\toldValue: unknown;\n\tnewValue: unknown;\n\tchange: unknown;\n\tdidChange: boolean;\n\thadValue: boolean;\n}\n\nexport interface IObservableLogger {\n\thandleObservableChanged(observable: ObservableValue<any, any>, info: IChangeInformation): void;\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void;\n\n\thandleAutorunCreated(autorun: AutorunObserver): void;\n\thandleAutorunTriggered(autorun: AutorunObserver): void;\n\thandleAutorunFinished(autorun: AutorunObserver): void;\n\n\thandleDerivedCreated(observable: Derived<any>): void;\n\thandleDerivedRecomputed(observable: Derived<any>, info: IChangeInformation): void;\n\n\thandleBeginTransaction(transaction: TransactionImpl): void;\n\thandleEndTransaction(): void;\n}\n\nexport class ConsoleObservableLogger implements IObservableLogger {\n\tprivate indentation = 0;\n\n\tprivate textToConsoleArgs(text: ConsoleText): unknown[] {\n\t\treturn consoleTextToArgs([\n\t\t\tnormalText(repeat('|  ', this.indentation)),\n\t\t\ttext,\n\t\t]);\n\t}\n\n\tprivate formatInfo(info: IChangeInformation): ConsoleText[] {\n\t\tif (!info.hadValue) {\n\t\t\treturn [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t\tnormalText(` (initial)`),\n\t\t\t];\n\t\t}\n\t\treturn info.didChange\n\t\t\t? [\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.oldValue, 70), {\n\t\t\t\t\tcolor: 'red',\n\t\t\t\t\tstrikeThrough: true,\n\t\t\t\t}),\n\t\t\t\tnormalText(` `),\n\t\t\t\tstyled(formatValue(info.newValue, 60), {\n\t\t\t\t\tcolor: 'green',\n\t\t\t\t}),\n\t\t\t]\n\t\t\t: [normalText(` (unchanged)`)];\n\t}\n\n\thandleObservableChanged(observable: IObservable<unknown, unknown>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable value changed'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t]));\n\t}\n\n\tprivate readonly changedObservablesSets = new WeakMap<object, Set<IObservable<any, any>>>();\n\n\tformatChanges(changes: Set<IObservable<any, any>>): ConsoleText | undefined {\n\t\tif (changes.size === 0) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn styled(\n\t\t\t' (changed deps: ' +\n\t\t\t[...changes].map((o) => o.debugName).join(', ') +\n\t\t\t')',\n\t\t\t{ color: 'gray' }\n\t\t);\n\t}\n\n\thandleDerivedCreated(derived: Derived<unknown>): void {\n\t\tconst existingHandleChange = derived.handleChange;\n\t\tthis.changedObservablesSets.set(derived, new Set());\n\t\tderived.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(derived)!.add(observable);\n\t\t\treturn existingHandleChange.apply(derived, [observable, change]);\n\t\t};\n\t}\n\n\thandleDerivedRecomputed(derived: Derived<unknown>, info: IChangeInformation): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(derived)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('derived recomputed'),\n\t\t\tstyled(derived.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: derived._computeFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t}\n\n\thandleFromEventObservableTriggered(observable: FromEventObservable<any, any>, info: IChangeInformation): void {\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('observable from event triggered'),\n\t\t\tstyled(observable.debugName, { color: 'BlueViolet' }),\n\t\t\t...this.formatInfo(info),\n\t\t\t{ data: [{ fn: observable._getValue }] }\n\t\t]));\n\t}\n\n\thandleAutorunCreated(autorun: AutorunObserver): void {\n\t\tconst existingHandleChange = autorun.handleChange;\n\t\tthis.changedObservablesSets.set(autorun, new Set());\n\t\tautorun.handleChange = (observable, change) => {\n\t\t\tthis.changedObservablesSets.get(autorun)!.add(observable);\n\t\t\treturn existingHandleChange.apply(autorun, [observable, change]);\n\t\t};\n\t}\n\n\thandleAutorunTriggered(autorun: AutorunObserver): void {\n\t\tconst changedObservables = this.changedObservablesSets.get(autorun)!;\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('autorun'),\n\t\t\tstyled(autorun.debugName, { color: 'BlueViolet' }),\n\t\t\tthis.formatChanges(changedObservables),\n\t\t\t{ data: [{ fn: autorun._runFn }] }\n\t\t]));\n\t\tchangedObservables.clear();\n\t\tthis.indentation++;\n\t}\n\n\thandleAutorunFinished(autorun: AutorunObserver): void {\n\t\tthis.indentation--;\n\t}\n\n\thandleBeginTransaction(transaction: TransactionImpl): void {\n\t\tlet transactionName = transaction.getDebugName();\n\t\tif (transactionName === undefined) {\n\t\t\ttransactionName = '';\n\t\t}\n\t\tconsole.log(...this.textToConsoleArgs([\n\t\t\tformatKind('transaction'),\n\t\t\tstyled(transactionName, { color: 'BlueViolet' }),\n\t\t\t{ data: [{ fn: transaction._fn }] }\n\t\t]));\n\t\tthis.indentation++;\n\t}\n\n\thandleEndTransaction(): void {\n\t\tthis.indentation--;\n\t}\n}\n\ntype ConsoleText =\n\t| (ConsoleText | undefined)[]\n\t| { text: string; style: string; data?: unknown[] }\n\t| { data: unknown[] };\n\nfunction consoleTextToArgs(text: ConsoleText): unknown[] {\n\tconst styles = new Array<any>();\n\tconst data: unknown[] = [];\n\tlet firstArg = '';\n\n\tfunction process(t: ConsoleText): void {\n\t\tif ('length' in t) {\n\t\t\tfor (const item of t) {\n\t\t\t\tif (item) {\n\t\t\t\t\tprocess(item);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if ('text' in t) {\n\t\t\tfirstArg += `%c${t.text}`;\n\t\t\tstyles.push(t.style);\n\t\t\tif (t.data) {\n\t\t\t\tdata.push(...t.data);\n\t\t\t}\n\t\t} else if ('data' in t) {\n\t\t\tdata.push(...t.data);\n\t\t}\n\t}\n\n\tprocess(text);\n\n\tconst result = [firstArg, ...styles];\n\tresult.push(...data);\n\treturn result;\n}\n\nfunction normalText(text: string): ConsoleText {\n\treturn styled(text, { color: 'black' });\n}\n\nfunction formatKind(kind: string): ConsoleText {\n\treturn styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\n\nfunction styled(\n\ttext: string,\n\toptions: { color: string; strikeThrough?: boolean; bold?: boolean } = {\n\t\tcolor: 'black',\n\t}\n): ConsoleText {\n\tfunction objToCss(styleObj: Record<string, string>): string {\n\t\treturn Object.entries(styleObj).reduce(\n\t\t\t(styleString, [propName, propValue]) => {\n\t\t\t\treturn `${styleString}${propName}:${propValue};`;\n\t\t\t},\n\t\t\t''\n\t\t);\n\t}\n\n\tconst style: Record<string, string> = {\n\t\tcolor: options.color,\n\t};\n\tif (options.strikeThrough) {\n\t\tstyle['text-decoration'] = 'line-through';\n\t}\n\tif (options.bold) {\n\t\tstyle['font-weight'] = 'bold';\n\t}\n\n\treturn {\n\t\ttext,\n\t\tstyle: objToCss(style),\n\t};\n}\n\nfunction formatValue(value: unknown, availableLen: number): string {\n\tswitch (typeof value) {\n\t\tcase 'number':\n\t\t\treturn '' + value;\n\t\tcase 'string':\n\t\t\tif (value.length + 2 <= availableLen) {\n\t\t\t\treturn `\"${value}\"`;\n\t\t\t}\n\t\t\treturn `\"${value.substr(0, availableLen - 7)}\"+...`;\n\n\t\tcase 'boolean':\n\t\t\treturn value ? 'true' : 'false';\n\t\tcase 'undefined':\n\t\t\treturn 'undefined';\n\t\tcase 'object':\n\t\t\tif (value === null) {\n\t\t\t\treturn 'null';\n\t\t\t}\n\t\t\tif (Array.isArray(value)) {\n\t\t\t\treturn formatArray(value, availableLen);\n\t\t\t}\n\t\t\treturn formatObject(value, availableLen);\n\t\tcase 'symbol':\n\t\t\treturn value.toString();\n\t\tcase 'function':\n\t\t\treturn `[[Function${value.name ? ' ' + value.name : ''}]]`;\n\t\tdefault:\n\t\t\treturn '' + value;\n\t}\n}\n\nfunction formatArray(value: unknown[], availableLen: number): string {\n\tlet result = '[ ';\n\tlet first = true;\n\tfor (const val of value) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' ]';\n\treturn result;\n}\n\nfunction formatObject(value: object, availableLen: number): string {\n\tlet result = '{ ';\n\tlet first = true;\n\tfor (const [key, val] of Object.entries(value)) {\n\t\tif (!first) {\n\t\t\tresult += ', ';\n\t\t}\n\t\tif (result.length - 5 > availableLen) {\n\t\t\tresult += '...';\n\t\t\tbreak;\n\t\t}\n\t\tfirst = false;\n\t\tresult += `${key}: ${formatValue(val, availableLen - result.length)}`;\n\t}\n\tresult += ' }';\n\treturn result;\n}\n\nfunction repeat(str: string, count: number): string {\n\tlet result = '';\n\tfor (let i = 1; i <= count; i++) {\n\t\tresult += str;\n\t}\n\treturn result;\n}\n\nfunction padStr(str: string, length: number): string {\n\twhile (str.length < length) {\n\t\tstr += ' ';\n\t}\n\treturn str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable, markAsDisposed, toDisposable, trackDisposable } from 'vs/base/common/lifecycle';\nimport { IReader, IObservable, IObserver, IChangeContext } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, IDebugNameData } from 'vs/base/common/observableInternal/debugName';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(undefined, undefined, fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options: IDebugNameData & {}, fn: (reader: IReader) => void): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\tundefined,\n\t\tundefined\n\t);\n}\n\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary) => void\n): IDisposable {\n\treturn new AutorunObserver(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn),\n\t\tfn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange\n\t);\n}\n\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges<TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary?: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t},\n\tfn: (reader: IReader, changeSummary: TChangeSummary, store: DisposableStore) => void\n): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunHandleChanges(\n\t\t{\n\t\t\towner: options.owner,\n\t\t\tdebugName: options.debugName,\n\t\t\tdebugReferenceFn: options.debugReferenceFn,\n\t\t\tcreateEmptyChangeSummary: options.createEmptyChangeSummary,\n\t\t\thandleChange: options.handleChange,\n\t\t},\n\t\t(reader, changeSummary) => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, changeSummary, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn: (reader: IReader, store: DisposableStore) => void): IDisposable {\n\tconst store = new DisposableStore();\n\tconst disposable = autorunOpts(\n\t\t{\n\t\t\towner: undefined,\n\t\t\tdebugName: undefined,\n\t\t\tdebugReferenceFn: fn,\n\t\t},\n\t\treader => {\n\t\t\tstore.clear();\n\t\t\tfn(reader, store);\n\t\t}\n\t);\n\treturn toDisposable(() => {\n\t\tdisposable.dispose();\n\t\tstore.dispose();\n\t});\n}\n\nexport function autorunDelta<T>(\n\tobservable: IObservable<T>,\n\thandler: (args: { lastValue: T | undefined; newValue: T }) => void\n): IDisposable {\n\tlet _lastValue: T | undefined;\n\treturn autorunOpts({ debugReferenceFn: handler }, (reader) => {\n\t\tconst newValue = observable.read(reader);\n\t\tconst lastValue = _lastValue;\n\t\t_lastValue = newValue;\n\t\thandler({ lastValue, newValue });\n\t});\n}\n\n\nconst enum AutorunState {\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t */\n\tstale = 2,\n\tupToDate = 3,\n}\n\nexport class AutorunObserver<TChangeSummary = any> implements IObserver, IReader, IDisposable {\n\tprivate state = AutorunState.stale;\n\tprivate updateCount = 0;\n\tprivate disposed = false;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined;\n\n\tpublic get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _runFn: (reader: IReader, changeSummary: TChangeSummary) => void,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t) {\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleAutorunCreated(this);\n\t\tthis._runIfNeeded();\n\n\t\ttrackDisposable(this);\n\t}\n\n\tpublic dispose(): void {\n\t\tthis.disposed = true;\n\t\tfor (const o of this.dependencies) {\n\t\t\to.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tmarkAsDisposed(this);\n\t}\n\n\tprivate _runIfNeeded() {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tthis.state = AutorunState.upToDate;\n\n\t\tconst isDisposed = this.disposed;\n\t\ttry {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunTriggered(this);\n\t\t\t\tconst changeSummary = this.changeSummary!;\n\t\t\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\t\t\tthis._runFn(this, changeSummary);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (!isDisposed) {\n\t\t\t\tgetLogger()?.handleAutorunFinished(this);\n\t\t\t}\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\t}\n\n\tpublic toString(): string {\n\t\treturn `Autorun<${this.debugName}>`;\n\t}\n\n\t// IObserver implementation\n\tpublic beginUpdate(): void {\n\t\tif (this.state === AutorunState.upToDate) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t\tthis.updateCount++;\n\t}\n\n\tpublic endUpdate(): void {\n\t\tif (this.updateCount === 1) {\n\t\t\tdo {\n\t\t\t\tif (this.state === AutorunState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = AutorunState.upToDate;\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\td.reportChanges();\n\t\t\t\t\t\tif (this.state as AutorunState === AutorunState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis._runIfNeeded();\n\t\t\t} while (this.state !== AutorunState.upToDate);\n\t\t}\n\t\tthis.updateCount--;\n\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange(observable: IObservable<any>): void {\n\t\tif (this.state === AutorunState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = AutorunState.dependenciesMightHaveChanged;\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tif (shouldReact) {\n\t\t\t\tthis.state = AutorunState.stale;\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// In case the run action disposes the autorun\n\t\tif (this.disposed) {\n\t\t\treturn observable.get();\n\t\t}\n\n\t\tobservable.addObserver(this);\n\t\tconst value = observable.get();\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n}\n\nexport namespace autorun {\n\texport const Observer = AutorunObserver;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { keepObserved, recomputeInitiallyAndOnChange } from 'vs/base/common/observable';\nimport { DebugNameData, Owner, getFunctionName } from 'vs/base/common/observableInternal/debugName';\nimport type { derivedOpts } from 'vs/base/common/observableInternal/derived';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Represents an observable value.\n *\n * @template T The type of the values the observable can hold.\n * @template TChange The type used to describe value changes\n * (usually `void` and only used in advanced scenarios).\n * While observers can miss temporary values of an observable,\n * they will receive all change values (as long as they are subscribed)!\n */\nexport interface IObservable<T, TChange = unknown> {\n\t/**\n\t * Returns the current value.\n\t *\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\tget(): T;\n\n\t/**\n\t * Forces the observable to check for changes and report them.\n\t *\n\t * Has the same effect as calling {@link IObservable.get}, but does not force the observable\n\t * to actually construct the value, e.g. if change deltas are used.\n\t * Calls {@link IObserver.handleChange} if the observable notices that the value changed.\n\t * Must not be called from {@link IObserver.handleChange}!\n\t */\n\treportChanges(): void;\n\n\t/**\n\t * Adds the observer to the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\taddObserver(observer: IObserver): void;\n\n\t/**\n\t * Removes the observer from the set of subscribed observers.\n\t * This method is idempotent.\n\t */\n\tremoveObserver(observer: IObserver): void;\n\n\t/**\n\t * Reads the current value and subscribes the reader to this observable.\n\t *\n\t * Calls {@link IReader.readObservable} if a reader is given, otherwise {@link IObservable.get}\n\t * (see {@link ConvenientObservable.read} for the implementation).\n\t */\n\tread(reader: IReader | undefined): T;\n\n\t/**\n\t * Creates a derived observable that depends on this observable.\n\t * Use the reader to read other observables\n\t * (see {@link ConvenientObservable.map} for the implementation).\n\t */\n\tmap<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tmap<TNew>(owner: object, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\n\t/**\n\t * Makes sure this value is computed eagerly.\n\t */\n\trecomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T>;\n\n\t/**\n\t * Makes sure this value is cached.\n\t */\n\tkeepObserved(store: DisposableStore): IObservable<T>;\n\n\t/**\n\t * A human-readable name for debugging purposes.\n\t */\n\treadonly debugName: string;\n\n\t/**\n\t * This property captures the type of the change object. Do not use it at runtime!\n\t */\n\treadonly TChange: TChange;\n}\n\nexport interface IReader {\n\t/**\n\t * Reads the value of an observable and subscribes to it.\n\t */\n\treadObservable<T>(observable: IObservable<T, any>): T;\n}\n\n/**\n * Represents an observer that can be subscribed to an observable.\n *\n * If an observer is subscribed to an observable and that observable didn't signal\n * a change through one of the observer methods, the observer can assume that the\n * observable didn't change.\n * If an observable reported a possible change, {@link IObservable.reportChanges} forces\n * the observable to report an actual change if there was one.\n */\nexport interface IObserver {\n\t/**\n\t * Signals that the given observable might have changed and a transaction potentially modifying that observable started.\n\t * Before the given observable can call this method again, is must call {@link IObserver.endUpdate}.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t */\n\tbeginUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the transaction that potentially modified the given observable ended.\n\t * This is a good place to react to (potential) changes.\n\t */\n\tendUpdate<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given observable might have changed.\n\t * The method {@link IObservable.reportChanges} can be used to force the observable to report the changes.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t */\n\thandlePossibleChange<T>(observable: IObservable<T>): void;\n\n\t/**\n\t * Signals that the given {@link observable} changed.\n\t *\n\t * Implementations must not get/read the value of other observables, as they might not have received this event yet!\n\t * The change should be processed lazily or in {@link IObserver.endUpdate}.\n\t *\n\t * @param change Indicates how or why the value changed.\n\t */\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void;\n}\n\nexport interface ISettable<T, TChange = void> {\n\t/**\n\t * Sets the value of the observable.\n\t * Use a transaction to batch multiple changes (with a transaction, observers only react at the end of the transaction).\n\t *\n\t * @param transaction When given, value changes are handled on demand or when the transaction ends.\n\t * @param change Describes how or why the value changed.\n\t */\n\tset(value: T, transaction: ITransaction | undefined, change: TChange): void;\n}\n\nexport interface ITransaction {\n\t/**\n\t * Calls {@link Observer.beginUpdate} immediately\n\t * and {@link Observer.endUpdate} when the transaction ends.\n\t */\n\tupdateObserver(observer: IObserver, observable: IObservable<any, any>): void;\n}\n\nlet _recomputeInitiallyAndOnChange: typeof recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange: typeof _recomputeInitiallyAndOnChange) {\n\t_recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\n\nlet _keepObserved: typeof keepObserved;\nexport function _setKeepObserved(keepObserved: typeof _keepObserved) {\n\t_keepObserved = keepObserved;\n}\n\n\nlet _derived: typeof derivedOpts;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived: typeof _derived) {\n\t_derived = derived;\n}\n\nexport abstract class ConvenientObservable<T, TChange> implements IObservable<T, TChange> {\n\tget TChange(): TChange { return null!; }\n\n\tpublic abstract get(): T;\n\n\tpublic reportChanges(): void {\n\t\tthis.get();\n\t}\n\n\tpublic abstract addObserver(observer: IObserver): void;\n\tpublic abstract removeObserver(observer: IObserver): void;\n\n\t/** @sealed */\n\tpublic read(reader: IReader | undefined): T {\n\t\tif (reader) {\n\t\t\treturn reader.readObservable(this);\n\t\t} else {\n\t\t\treturn this.get();\n\t\t}\n\t}\n\n\t/** @sealed */\n\tpublic map<TNew>(fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(owner: Owner, fn: (value: T, reader: IReader) => TNew): IObservable<TNew>;\n\tpublic map<TNew>(fnOrOwner: Owner | ((value: T, reader: IReader) => TNew), fnOrUndefined?: (value: T, reader: IReader) => TNew): IObservable<TNew> {\n\t\tconst owner = fnOrUndefined === undefined ? undefined : fnOrOwner as Owner;\n\t\tconst fn = fnOrUndefined === undefined ? fnOrOwner as (value: T, reader: IReader) => TNew : fnOrUndefined;\n\n\t\treturn _derived(\n\t\t\t{\n\t\t\t\towner,\n\t\t\t\tdebugName: () => {\n\t\t\t\t\tconst name = getFunctionName(fn);\n\t\t\t\t\tif (name !== undefined) {\n\t\t\t\t\t\treturn name;\n\t\t\t\t\t}\n\n\t\t\t\t\t// regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n\t\t\t\t\tconst regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n\t\t\t\t\tconst match = regexp.exec(fn.toString());\n\t\t\t\t\tif (match) {\n\t\t\t\t\t\treturn `${this.debugName}.${match[2]}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (!owner) {\n\t\t\t\t\t\treturn `${this.debugName} (mapped)`;\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t},\n\t\t\t},\n\t\t\t(reader) => fn(this.read(reader), reader),\n\t\t);\n\t}\n\n\tpublic recomputeInitiallyAndOnChange(store: DisposableStore, handleValue?: (value: T) => void): IObservable<T> {\n\t\tstore.add(_recomputeInitiallyAndOnChange!(this, handleValue));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ensures that this observable is observed. This keeps the cache alive.\n\t * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n\t * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n\t */\n\tpublic keepObserved(store: DisposableStore): IObservable<T> {\n\t\tstore.add(_keepObserved!(this));\n\t\treturn this;\n\t}\n\n\tpublic abstract get debugName(): string;\n}\n\nexport abstract class BaseObservable<T, TChange = void> extends ConvenientObservable<T, TChange> {\n\tprotected readonly observers = new Set<IObserver>();\n\n\tpublic addObserver(observer: IObserver): void {\n\t\tconst len = this.observers.size;\n\t\tthis.observers.add(observer);\n\t\tif (len === 0) {\n\t\t\tthis.onFirstObserverAdded();\n\t\t}\n\t}\n\n\tpublic removeObserver(observer: IObserver): void {\n\t\tconst deleted = this.observers.delete(observer);\n\t\tif (deleted && this.observers.size === 0) {\n\t\t\tthis.onLastObserverRemoved();\n\t\t}\n\t}\n\n\tprotected onFirstObserverAdded(): void { }\n\tprotected onLastObserverRemoved(): void { }\n}\n\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\n\nexport function transaction(fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tfn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\nlet _globalTransaction: ITransaction | undefined = undefined;\n\nexport function globalTransaction(fn: (tx: ITransaction) => void) {\n\tif (_globalTransaction) {\n\t\tfn(_globalTransaction);\n\t} else {\n\t\tconst tx = new TransactionImpl(fn, undefined);\n\t\t_globalTransaction = tx;\n\t\ttry {\n\t\t\tfn(tx);\n\t\t} finally {\n\t\t\ttx.finish(); // During finish, more actions might be added to the transaction.\n\t\t\t// Which is why we only clear the global transaction after finish.\n\t\t\t_globalTransaction = undefined;\n\t\t}\n\t}\n}\n\nexport async function asyncTransaction(fn: (tx: ITransaction) => Promise<void>, getDebugName?: () => string): Promise<void> {\n\tconst tx = new TransactionImpl(fn, getDebugName);\n\ttry {\n\t\tawait fn(tx);\n\t} finally {\n\t\ttx.finish();\n\t}\n}\n\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx: ITransaction | undefined, fn: (tx: ITransaction) => void, getDebugName?: () => string): void {\n\tif (!tx) {\n\t\ttransaction(fn, getDebugName);\n\t} else {\n\t\tfn(tx);\n\t}\n}\n\nexport class TransactionImpl implements ITransaction {\n\tprivate updatingObservers: { observer: IObserver; observable: IObservable<any> }[] | null = [];\n\n\tconstructor(public readonly _fn: Function, private readonly _getDebugName?: () => string) {\n\t\tgetLogger()?.handleBeginTransaction(this);\n\t}\n\n\tpublic getDebugName(): string | undefined {\n\t\tif (this._getDebugName) {\n\t\t\treturn this._getDebugName();\n\t\t}\n\t\treturn getFunctionName(this._fn);\n\t}\n\n\tpublic updateObserver(observer: IObserver, observable: IObservable<any>): void {\n\t\t// When this gets called while finish is active, they will still get considered\n\t\tthis.updatingObservers!.push({ observer, observable });\n\t\tobserver.beginUpdate(observable);\n\t}\n\n\tpublic finish(): void {\n\t\tconst updatingObservers = this.updatingObservers!;\n\t\tfor (let i = 0; i < updatingObservers.length; i++) {\n\t\t\tconst { observer, observable } = updatingObservers[i];\n\t\t\tobserver.endUpdate(observable);\n\t\t}\n\t\t// Prevent anyone from updating observers from now on.\n\t\tthis.updatingObservers = null;\n\t\tgetLogger()?.handleEndTransaction();\n\t}\n}\n\n/**\n * A settable observable.\n */\nexport interface ISettableObservable<T, TChange = void> extends IObservable<T, TChange>, ISettable<T, TChange> {\n}\n\n/**\n * Creates an observable value.\n * Observers get informed when the value changes.\n * @template TChange An arbitrary type to describe how or why the value changed. Defaults to `void`.\n * Observers will receive every single change value.\n */\nexport function observableValue<T, TChange = void>(name: string, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(owner: object, initialValue: T): ISettableObservable<T, TChange>;\nexport function observableValue<T, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new ObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new ObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class ObservableValue<T, TChange = void>\n\textends BaseObservable<T, TChange>\n\timplements ISettableObservable<T, TChange> {\n\tprotected _value: T;\n\n\tget debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'ObservableValue';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _owner: Owner,\n\t\tprivate readonly _debugName: string | undefined,\n\t\tinitialValue: T\n\t) {\n\t\tsuper();\n\t\tthis._value = initialValue;\n\t}\n\tpublic get(): T {\n\t\treturn this._value;\n\t}\n\n\tpublic set(value: T, tx: ITransaction | undefined, change: TChange): void {\n\t\tif (this._value === value) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet _tx: TransactionImpl | undefined;\n\t\tif (!tx) {\n\t\t\ttx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n\t\t}\n\t\ttry {\n\t\t\tconst oldValue = this._value;\n\t\t\tthis._setValue(value);\n\t\t\tgetLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n\n\t\t\tfor (const observer of this.observers) {\n\t\t\t\ttx.updateObserver(observer, this);\n\t\t\t\tobserver.handleChange(this, change);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_tx) {\n\t\t\t\t_tx.finish();\n\t\t\t}\n\t\t}\n\t}\n\n\toverride toString(): string {\n\t\treturn `${this.debugName}: ${this._value}`;\n\t}\n\n\tprotected _setValue(newValue: T): void {\n\t\tthis._value = newValue;\n\t}\n}\n\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue<T extends IDisposable | undefined, TChange = void>(nameOrOwner: string | object, initialValue: T): ISettableObservable<T, TChange> & IDisposable {\n\tif (typeof nameOrOwner === 'string') {\n\t\treturn new DisposableObservableValue(undefined, nameOrOwner, initialValue);\n\t} else {\n\t\treturn new DisposableObservableValue(nameOrOwner, undefined, initialValue);\n\t}\n}\n\nexport class DisposableObservableValue<T extends IDisposable | undefined, TChange = void> extends ObservableValue<T, TChange> implements IDisposable {\n\tprotected override _setValue(newValue: T): void {\n\t\tif (this._value === newValue) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._value) {\n\t\t\tthis._value.dispose();\n\t\t}\n\t\tthis._value = newValue;\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._value?.dispose();\n\t}\n}\n\nexport interface IChangeTracker {\n\t/**\n\t * Returns if this change should cause an invalidation.\n\t * Implementations can record changes.\n\t*/\n\thandleChange(context: IChangeContext): boolean;\n}\n\nexport interface IChangeContext {\n\treadonly changedObservable: IObservable<any, any>;\n\treadonly change: unknown;\n\n\t/**\n\t * Returns if the given observable caused the change.\n\t */\n\tdidChange<T, TChange>(observable: IObservable<T, TChange>): this is { change: TChange };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { assertFn } from 'vs/base/common/assert';\nimport { DisposableStore, IDisposable } from 'vs/base/common/lifecycle';\nimport { BaseObservable, IChangeContext, IObservable, IObserver, IReader, _setDerivedOpts } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, IDebugNameData, Owner } from 'vs/base/common/observableInternal/debugName';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\nexport type EqualityComparer<T> = (a: T, b: T) => boolean;\nexport const defaultEqualityComparer: EqualityComparer<any> = (a, b) => a === b;\n\n/**\n * Creates an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n */\nexport function derived<T>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(owner: object, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derived<T>(computeFnOrOwner: ((reader: IReader) => T) | object, computeFn?: ((reader: IReader) => T) | undefined): IObservable<T> {\n\tif (computeFn !== undefined) {\n\t\treturn new Derived(\n\t\t\tnew DebugNameData(computeFnOrOwner, undefined, computeFn),\n\t\t\tcomputeFn,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tundefined,\n\t\t\tdefaultEqualityComparer\n\t\t);\n\t}\n\treturn new Derived(\n\t\tnew DebugNameData(undefined, undefined, computeFnOrOwner as any),\n\t\tcomputeFnOrOwner as any,\n\t\tundefined,\n\t\tundefined,\n\t\tundefined,\n\t\tdefaultEqualityComparer\n\t);\n}\n\nexport function derivedOpts<T>(\n\toptions: IDebugNameData & {\n\t\tequalityComparer?: EqualityComparer<T>;\n\t\tonLastObserverRemoved?: (() => void);\n\t},\n\tcomputeFn: (reader: IReader) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, options.debugReferenceFn),\n\t\tcomputeFn,\n\t\tundefined,\n\t\tundefined,\n\t\toptions.onLastObserverRemoved,\n\t\toptions.equalityComparer ?? defaultEqualityComparer\n\t);\n}\n\n_setDerivedOpts(derivedOpts);\n\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges<T, TChangeSummary>(\n\toptions: IDebugNameData & {\n\t\tcreateEmptyChangeSummary: () => TChangeSummary;\n\t\thandleChange: (context: IChangeContext, changeSummary: TChangeSummary) => boolean;\n\t\tequalityComparer?: EqualityComparer<T>;\n\t},\n\tcomputeFn: (reader: IReader, changeSummary: TChangeSummary) => T\n): IObservable<T> {\n\treturn new Derived(\n\t\tnew DebugNameData(options.owner, options.debugName, undefined),\n\t\tcomputeFn,\n\t\toptions.createEmptyChangeSummary,\n\t\toptions.handleChange,\n\t\tundefined,\n\t\toptions.equalityComparer ?? defaultEqualityComparer\n\t);\n}\n\nexport function derivedWithStore<T>(computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(owner: object, computeFn: (reader: IReader, store: DisposableStore) => T): IObservable<T>;\nexport function derivedWithStore<T>(computeFnOrOwner: ((reader: IReader, store: DisposableStore) => T) | object, computeFnOrUndefined?: ((reader: IReader, store: DisposableStore) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: DisposableStore) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\treturn computeFn(r, store);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tdefaultEqualityComparer\n\t);\n}\n\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(owner: Owner, computeFn: (reader: IReader) => T): IObservable<T>;\nexport function derivedDisposable<T extends IDisposable | undefined>(computeFnOrOwner: ((reader: IReader) => T) | Owner, computeFnOrUndefined?: ((reader: IReader) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tconst store = new DisposableStore();\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tstore.clear();\n\t\t\tconst result = computeFn(r);\n\t\t\tif (result) {\n\t\t\t\tstore.add(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => store.dispose(),\n\t\tdefaultEqualityComparer\n\t);\n}\n\nconst enum DerivedState {\n\t/** Initial state, no previous value, recomputation needed */\n\tinitial = 0,\n\n\t/**\n\t * A dependency could have changed.\n\t * We need to explicitly ask them if at least one dependency changed.\n\t */\n\tdependenciesMightHaveChanged = 1,\n\n\t/**\n\t * A dependency changed and we need to recompute.\n\t * After recomputation, we need to check the previous value to see if we changed as well.\n\t */\n\tstale = 2,\n\n\t/**\n\t * No change reported, our cached value is up to date.\n\t */\n\tupToDate = 3,\n}\n\nexport class Derived<T, TChangeSummary = any> extends BaseObservable<T, void> implements IReader, IObserver {\n\tprivate state = DerivedState.initial;\n\tprivate value: T | undefined = undefined;\n\tprivate updateCount = 0;\n\tprivate dependencies = new Set<IObservable<any>>();\n\tprivate dependenciesToBeRemoved = new Set<IObservable<any>>();\n\tprivate changeSummary: TChangeSummary | undefined = undefined;\n\n\tpublic override get debugName(): string {\n\t\treturn this._debugNameData.getDebugName(this) ?? '(anonymous)';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugNameData: DebugNameData,\n\t\tpublic readonly _computeFn: (reader: IReader, changeSummary: TChangeSummary) => T,\n\t\tprivate readonly createChangeSummary: (() => TChangeSummary) | undefined,\n\t\tprivate readonly _handleChange: ((context: IChangeContext, summary: TChangeSummary) => boolean) | undefined,\n\t\tprivate readonly _handleLastObserverRemoved: (() => void) | undefined = undefined,\n\t\tprivate readonly _equalityComparator: EqualityComparer<T>,\n\t) {\n\t\tsuper();\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\tgetLogger()?.handleDerivedCreated(this);\n\t}\n\n\tprotected override onLastObserverRemoved(): void {\n\t\t/**\n\t\t * We are not tracking changes anymore, thus we have to assume\n\t\t * that our cache is invalid.\n\t\t */\n\t\tthis.state = DerivedState.initial;\n\t\tthis.value = undefined;\n\t\tfor (const d of this.dependencies) {\n\t\t\td.removeObserver(this);\n\t\t}\n\t\tthis.dependencies.clear();\n\n\t\tthis._handleLastObserverRemoved?.();\n\t}\n\n\tpublic override get(): T {\n\t\tif (this.observers.size === 0) {\n\t\t\t// Without observers, we don't know when to clean up stuff.\n\t\t\t// Thus, we don't cache anything to prevent memory leaks.\n\t\t\tconst result = this._computeFn(this, this.createChangeSummary?.()!);\n\t\t\t// Clear new dependencies\n\t\t\tthis.onLastObserverRemoved();\n\t\t\treturn result;\n\t\t} else {\n\t\t\tdo {\n\t\t\t\t// We might not get a notification for a dependency that changed while it is updating,\n\t\t\t\t// thus we also have to ask all our depedencies if they changed in this case.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tfor (const d of this.dependencies) {\n\t\t\t\t\t\t/** might call {@link handleChange} indirectly, which could make us stale */\n\t\t\t\t\t\td.reportChanges();\n\n\t\t\t\t\t\tif (this.state as DerivedState === DerivedState.stale) {\n\t\t\t\t\t\t\t// The other dependencies will refresh on demand, so early break\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// We called report changes of all dependencies.\n\t\t\t\t// If we are still not stale, we can assume to be up to date again.\n\t\t\t\tif (this.state === DerivedState.dependenciesMightHaveChanged) {\n\t\t\t\t\tthis.state = DerivedState.upToDate;\n\t\t\t\t}\n\n\t\t\t\tthis._recomputeIfNeeded();\n\t\t\t\t// In case recomputation changed one of our dependencies, we need to recompute again.\n\t\t\t} while (this.state !== DerivedState.upToDate);\n\t\t\treturn this.value!;\n\t\t}\n\t}\n\n\tprivate _recomputeIfNeeded() {\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\treturn;\n\t\t}\n\t\tconst emptySet = this.dependenciesToBeRemoved;\n\t\tthis.dependenciesToBeRemoved = this.dependencies;\n\t\tthis.dependencies = emptySet;\n\n\t\tconst hadValue = this.state !== DerivedState.initial;\n\t\tconst oldValue = this.value;\n\t\tthis.state = DerivedState.upToDate;\n\n\t\tconst changeSummary = this.changeSummary!;\n\t\tthis.changeSummary = this.createChangeSummary?.();\n\t\ttry {\n\t\t\t/** might call {@link handleChange} indirectly, which could invalidate us */\n\t\t\tthis.value = this._computeFn(this, changeSummary);\n\t\t} finally {\n\t\t\t// We don't want our observed observables to think that they are (not even temporarily) not being observed.\n\t\t\t// Thus, we only unsubscribe from observables that are definitely not read anymore.\n\t\t\tfor (const o of this.dependenciesToBeRemoved) {\n\t\t\t\to.removeObserver(this);\n\t\t\t}\n\t\t\tthis.dependenciesToBeRemoved.clear();\n\t\t}\n\n\t\tconst didChange = hadValue && !(this._equalityComparator(oldValue!, this.value));\n\n\t\tgetLogger()?.handleDerivedRecomputed(this, {\n\t\t\toldValue,\n\t\t\tnewValue: this.value,\n\t\t\tchange: undefined,\n\t\t\tdidChange,\n\t\t\thadValue,\n\t\t});\n\n\t\tif (didChange) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handleChange(this, undefined);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic override toString(): string {\n\t\treturn `LazyDerived<${this.debugName}>`;\n\t}\n\n\t// IObserver Implementation\n\tpublic beginUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount++;\n\t\tconst propagateBeginUpdate = this.updateCount === 1;\n\t\tif (this.state === DerivedState.upToDate) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\t// If we propagate begin update, that will already signal a possible change.\n\t\t\tif (!propagateBeginUpdate) {\n\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (propagateBeginUpdate) {\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.beginUpdate(this); // This signals a possible change\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic endUpdate<T>(_observable: IObservable<T>): void {\n\t\tthis.updateCount--;\n\t\tif (this.updateCount === 0) {\n\t\t\t// End update could change the observer list.\n\t\t\tconst observers = [...this.observers];\n\t\t\tfor (const r of observers) {\n\t\t\t\tr.endUpdate(this);\n\t\t\t}\n\t\t}\n\t\tassertFn(() => this.updateCount >= 0);\n\t}\n\n\tpublic handlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// In all other states, observers already know that we might have changed.\n\t\tif (this.state === DerivedState.upToDate && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tthis.state = DerivedState.dependenciesMightHaveChanged;\n\t\t\tfor (const r of this.observers) {\n\t\t\t\tr.handlePossibleChange(this);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic handleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\tif (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n\t\t\tconst shouldReact = this._handleChange ? this._handleChange({\n\t\t\t\tchangedObservable: observable,\n\t\t\t\tchange,\n\t\t\t\tdidChange: o => o === observable as any,\n\t\t\t}, this.changeSummary!) : true;\n\t\t\tconst wasUpToDate = this.state === DerivedState.upToDate;\n\t\t\tif (shouldReact && (this.state === DerivedState.dependenciesMightHaveChanged || wasUpToDate)) {\n\t\t\t\tthis.state = DerivedState.stale;\n\t\t\t\tif (wasUpToDate) {\n\t\t\t\t\tfor (const r of this.observers) {\n\t\t\t\t\t\tr.handlePossibleChange(this);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// IReader Implementation\n\tpublic readObservable<T>(observable: IObservable<T>): T {\n\t\t// Subscribe before getting the value to enable caching\n\t\tobservable.addObserver(this);\n\t\t/** This might call {@link handleChange} indirectly, which could invalidate us */\n\t\tconst value = observable.get();\n\t\t// Which is why we only add the observable to the dependencies now.\n\t\tthis.dependencies.add(observable);\n\t\tthis.dependenciesToBeRemoved.delete(observable);\n\t\treturn value;\n\t}\n\n\tpublic override addObserver(observer: IObserver): void {\n\t\tconst shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.addObserver(observer);\n\n\t\tif (shouldCallBeginUpdate) {\n\t\t\tobserver.beginUpdate(this);\n\t\t}\n\t}\n\n\tpublic override removeObserver(observer: IObserver): void {\n\t\tconst shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n\t\tsuper.removeObserver(observer);\n\n\t\tif (shouldCallEndUpdate) {\n\t\t\t// Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n\t\t\tobserver.endUpdate(this);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Event } from 'vs/base/common/event';\nimport { DisposableStore, IDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { autorun } from 'vs/base/common/observableInternal/autorun';\nimport { BaseObservable, ConvenientObservable, IObservable, IObserver, IReader, ITransaction, _setKeepObserved, _setRecomputeInitiallyAndOnChange, observableValue, subtransaction, transaction } from 'vs/base/common/observableInternal/base';\nimport { DebugNameData, Owner, getFunctionName } from 'vs/base/common/observableInternal/debugName';\nimport { derived, derivedOpts } from 'vs/base/common/observableInternal/derived';\nimport { getLogger } from 'vs/base/common/observableInternal/logging';\n\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable<T>(value: T): IObservable<T> {\n\treturn new ConstObservable(value);\n}\n\nclass ConstObservable<T> extends ConvenientObservable<T, void> {\n\tconstructor(private readonly value: T) {\n\t\tsuper();\n\t}\n\n\tpublic override get debugName(): string {\n\t\treturn this.toString();\n\t}\n\n\tpublic get(): T {\n\t\treturn this.value;\n\t}\n\tpublic addObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\tpublic removeObserver(observer: IObserver): void {\n\t\t// NO OP\n\t}\n\n\toverride toString(): string {\n\t\treturn `Const: ${this.value}`;\n\t}\n}\n\n\nexport function observableFromPromise<T>(promise: Promise<T>): IObservable<{ value?: T }> {\n\tconst observable = observableValue<{ value?: T }>('promiseValue', {});\n\tpromise.then((value) => {\n\t\tobservable.set({ value }, undefined);\n\t});\n\treturn observable;\n}\n\nexport function observableFromEvent<T, TArgs = unknown>(\n\tevent: Event<TArgs>,\n\tgetValue: (args: TArgs | undefined) => T\n): IObservable<T> {\n\treturn new FromEventObservable(event, getValue);\n}\n\nexport class FromEventObservable<TArgs, T> extends BaseObservable<T> {\n\tpublic static globalTransaction: ITransaction | undefined;\n\n\tprivate value: T | undefined;\n\tprivate hasValue = false;\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tprivate readonly event: Event<TArgs>,\n\t\tpublic readonly _getValue: (args: TArgs | undefined) => T\n\t) {\n\t\tsuper();\n\t}\n\n\tprivate getDebugName(): string | undefined {\n\t\treturn getFunctionName(this._getValue);\n\t}\n\n\tpublic get debugName(): string {\n\t\tconst name = this.getDebugName();\n\t\treturn 'From Event' + (name ? `: ${name}` : '');\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = (args: TArgs | undefined) => {\n\t\tconst newValue = this._getValue(args);\n\t\tconst oldValue = this.value;\n\n\t\tconst didChange = !this.hasValue || oldValue !== newValue;\n\t\tlet didRunTransaction = false;\n\n\t\tif (didChange) {\n\t\t\tthis.value = newValue;\n\n\t\t\tif (this.hasValue) {\n\t\t\t\tdidRunTransaction = true;\n\t\t\t\tsubtransaction(\n\t\t\t\t\tFromEventObservable.globalTransaction,\n\t\t\t\t\t(tx) => {\n\t\t\t\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\n\t\t\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t() => {\n\t\t\t\t\t\tconst name = this.getDebugName();\n\t\t\t\t\t\treturn 'Event fired' + (name ? `: ${name}` : '');\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\tthis.hasValue = true;\n\t\t}\n\n\t\tif (!didRunTransaction) {\n\t\t\tgetLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n\t\t}\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t\tthis.hasValue = false;\n\t\tthis.value = undefined;\n\t}\n\n\tpublic get(): T {\n\t\tif (this.subscription) {\n\t\t\tif (!this.hasValue) {\n\t\t\t\tthis.handleEvent(undefined);\n\t\t\t}\n\t\t\treturn this.value!;\n\t\t} else {\n\t\t\t// no cache, as there are no subscribers to keep it updated\n\t\t\treturn this._getValue(undefined);\n\t\t}\n\t}\n}\n\nexport namespace observableFromEvent {\n\texport const Observer = FromEventObservable;\n\n\texport function batchEventsGlobally(tx: ITransaction, fn: () => void): void {\n\t\tlet didSet = false;\n\t\tif (FromEventObservable.globalTransaction === undefined) {\n\t\t\tFromEventObservable.globalTransaction = tx;\n\t\t\tdidSet = true;\n\t\t}\n\t\ttry {\n\t\t\tfn();\n\t\t} finally {\n\t\t\tif (didSet) {\n\t\t\t\tFromEventObservable.globalTransaction = undefined;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport function observableSignalFromEvent(\n\tdebugName: string,\n\tevent: Event<any>\n): IObservable<void> {\n\treturn new FromEventObservableSignal(debugName, event);\n}\n\nclass FromEventObservableSignal extends BaseObservable<void> {\n\tprivate subscription: IDisposable | undefined;\n\n\tconstructor(\n\t\tpublic readonly debugName: string,\n\t\tprivate readonly event: Event<any>,\n\t) {\n\t\tsuper();\n\t}\n\n\tprotected override onFirstObserverAdded(): void {\n\t\tthis.subscription = this.event(this.handleEvent);\n\t}\n\n\tprivate readonly handleEvent = () => {\n\t\ttransaction(\n\t\t\t(tx) => {\n\t\t\t\tfor (const o of this.observers) {\n\t\t\t\t\ttx.updateObserver(o, this);\n\t\t\t\t\to.handleChange(this, undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\t() => this.debugName\n\t\t);\n\t};\n\n\tprotected override onLastObserverRemoved(): void {\n\t\tthis.subscription!.dispose();\n\t\tthis.subscription = undefined;\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\n/**\n * Creates a signal that can be triggered to invalidate observers.\n * Signals don't have a value - when they are triggered they indicate a change.\n * However, signals can carry a delta that is passed to observers.\n */\nexport function observableSignal<TDelta = void>(debugName: string): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(owner: object): IObservableSignal<TDelta>;\nexport function observableSignal<TDelta = void>(debugNameOrOwner: string | object): IObservableSignal<TDelta> {\n\tif (typeof debugNameOrOwner === 'string') {\n\t\treturn new ObservableSignal<TDelta>(debugNameOrOwner);\n\t} else {\n\t\treturn new ObservableSignal<TDelta>(undefined, debugNameOrOwner);\n\t}\n}\n\nexport interface IObservableSignal<TChange> extends IObservable<void, TChange> {\n\ttrigger(tx: ITransaction | undefined, change: TChange): void;\n}\n\nclass ObservableSignal<TChange> extends BaseObservable<void, TChange> implements IObservableSignal<TChange> {\n\tpublic get debugName() {\n\t\treturn new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n\t}\n\n\tconstructor(\n\t\tprivate readonly _debugName: string | undefined,\n\t\tprivate readonly _owner?: object,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic trigger(tx: ITransaction | undefined, change: TChange): void {\n\t\tif (!tx) {\n\t\t\ttransaction(tx => {\n\t\t\t\tthis.trigger(tx, change);\n\t\t\t}, () => `Trigger signal ${this.debugName}`);\n\t\t\treturn;\n\t\t}\n\n\t\tfor (const o of this.observers) {\n\t\t\ttx.updateObserver(o, this);\n\t\t\to.handleChange(this, change);\n\t\t}\n\t}\n\n\tpublic override get(): void {\n\t\t// NO OP\n\t}\n}\n\nexport function debouncedObservable<T>(observable: IObservable<T>, debounceMs: number, disposableStore: DisposableStore): IObservable<T | undefined> {\n\tconst debouncedObservable = observableValue<T | undefined>('debounced', undefined);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(autorun(reader => {\n\t\t/** @description debounce */\n\t\tconst value = observable.read(reader);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\ttransaction(tx => {\n\t\t\t\tdebouncedObservable.set(value, tx);\n\t\t\t});\n\t\t}, debounceMs);\n\n\t}));\n\n\treturn debouncedObservable;\n}\n\nexport function wasEventTriggeredRecently(event: Event<any>, timeoutMs: number, disposableStore: DisposableStore): IObservable<boolean> {\n\tconst observable = observableValue('triggeredRecently', false);\n\n\tlet timeout: any = undefined;\n\n\tdisposableStore.add(event(() => {\n\t\tobservable.set(true, undefined);\n\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout);\n\t\t}\n\t\ttimeout = setTimeout(() => {\n\t\t\tobservable.set(false, undefined);\n\t\t}, timeoutMs);\n\t}));\n\n\treturn observable;\n}\n\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved<T>(observable: IObservable<T>): IDisposable {\n\tconst o = new KeepAliveObserver(false, undefined);\n\tobservable.addObserver(o);\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setKeepObserved(keepObserved);\n\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange<T>(observable: IObservable<T>, handleValue?: (value: T) => void): IDisposable {\n\tconst o = new KeepAliveObserver(true, handleValue);\n\tobservable.addObserver(o);\n\tif (handleValue) {\n\t\thandleValue(observable.get());\n\t} else {\n\t\tobservable.reportChanges();\n\t}\n\n\treturn toDisposable(() => {\n\t\tobservable.removeObserver(o);\n\t});\n}\n\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\n\nexport class KeepAliveObserver implements IObserver {\n\tprivate _counter = 0;\n\n\tconstructor(\n\t\tprivate readonly _forceRecompute: boolean,\n\t\tprivate readonly _handleValue: ((value: any) => void) | undefined,\n\t) { }\n\n\tbeginUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter++;\n\t}\n\n\tendUpdate<T>(observable: IObservable<T, void>): void {\n\t\tthis._counter--;\n\t\tif (this._counter === 0 && this._forceRecompute) {\n\t\t\tif (this._handleValue) {\n\t\t\t\tthis._handleValue(observable.get());\n\t\t\t} else {\n\t\t\t\tobservable.reportChanges();\n\t\t\t}\n\t\t}\n\t}\n\n\thandlePossibleChange<T>(observable: IObservable<T, unknown>): void {\n\t\t// NO OP\n\t}\n\n\thandleChange<T, TChange>(observable: IObservable<T, TChange>, change: TChange): void {\n\t\t// NO OP\n\t}\n}\n\nexport function derivedObservableWithCache<T>(computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> {\n\tlet lastValue: T | undefined = undefined;\n\tconst observable = derived(reader => {\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn observable;\n}\n\nexport function derivedObservableWithWritableCache<T>(owner: object, computeFn: (reader: IReader, lastValue: T | undefined) => T): IObservable<T> & { clearCache(transaction: ITransaction): void } {\n\tlet lastValue: T | undefined = undefined;\n\tconst counter = observableValue('derivedObservableWithWritableCache.counter', 0);\n\tconst observable = derived(owner, reader => {\n\t\tcounter.read(reader);\n\t\tlastValue = computeFn(reader, lastValue);\n\t\treturn lastValue;\n\t});\n\treturn Object.assign(observable, {\n\t\tclearCache: (transaction: ITransaction) => {\n\t\t\tlastValue = undefined;\n\t\t\tcounter.set(counter.get() + 1, transaction);\n\t\t},\n\t});\n}\n\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached<TIn, TOut, TKey = TIn>(owner: Owner, items: IObservable<readonly TIn[]>, map: (input: TIn, store: DisposableStore) => TOut, keySelector?: (input: TIn) => TKey): IObservable<readonly TOut[]> {\n\tlet m = new ArrayMap(map, keySelector);\n\tconst self = derivedOpts({\n\t\tdebugReferenceFn: map,\n\t\towner,\n\t\tonLastObserverRemoved: () => {\n\t\t\tm.dispose();\n\t\t\tm = new ArrayMap(map);\n\t\t}\n\t}, (reader) => {\n\t\tm.setItems(items.read(reader));\n\t\treturn m.getItems();\n\t});\n\treturn self;\n}\n\nclass ArrayMap<TIn, TOut, TKey> implements IDisposable {\n\tprivate readonly _cache = new Map<TKey, { out: TOut; store: DisposableStore }>();\n\tprivate _items: TOut[] = [];\n\tconstructor(\n\t\tprivate readonly _map: (input: TIn, store: DisposableStore) => TOut,\n\t\tprivate readonly _keySelector?: (input: TIn) => TKey,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._cache.forEach(entry => entry.store.dispose());\n\t\tthis._cache.clear();\n\t}\n\n\tpublic setItems(items: readonly TIn[]): void {\n\t\tconst newItems: TOut[] = [];\n\t\tconst itemsToRemove = new Set(this._cache.keys());\n\n\t\tfor (const item of items) {\n\t\t\tconst key = this._keySelector ? this._keySelector(item) : item as unknown as TKey;\n\n\t\t\tlet entry = this._cache.get(key);\n\t\t\tif (!entry) {\n\t\t\t\tconst store = new DisposableStore();\n\t\t\t\tconst out = this._map(item, store);\n\t\t\t\tentry = { out, store };\n\t\t\t\tthis._cache.set(key, entry);\n\t\t\t} else {\n\t\t\t\titemsToRemove.delete(key);\n\t\t\t}\n\t\t\tnewItems.push(entry.out);\n\t\t}\n\n\t\tfor (const item of itemsToRemove) {\n\t\t\tconst entry = this._cache.get(item)!;\n\t\t\tentry.store.dispose();\n\t\t\tthis._cache.delete(item);\n\t\t}\n\n\t\tthis._items = newItems;\n\t}\n\n\tpublic getItems(): TOut[] {\n\t\treturn this._items;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from 'vs/base/common/observableInternal/autorun';\nimport { IObservable, IReader, observableValue, transaction } from './base';\nimport { Derived, defaultEqualityComparer, derived } from 'vs/base/common/observableInternal/derived';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { DebugNameData, Owner } from 'vs/base/common/observableInternal/debugName';\n\nexport class ObservableLazy<T> {\n\tprivate readonly _value = observableValue<T | undefined>(this, undefined);\n\n\t/**\n\t * The cached value.\n\t * Does not force a computation of the value.\n\t */\n\tpublic get cachedValue(): IObservable<T | undefined> { return this._value; }\n\n\tconstructor(private readonly _computeValue: () => T) {\n\t}\n\n\t/**\n\t * Returns the cached value.\n\t * Computes the value if the value has not been cached yet.\n\t */\n\tpublic getValue() {\n\t\tlet v = this._value.get();\n\t\tif (!v) {\n\t\t\tv = this._computeValue();\n\t\t\tthis._value.set(v, undefined);\n\t\t}\n\t\treturn v;\n\t}\n}\n\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise<T> {\n\tprivate readonly _value = observableValue<PromiseResult<T> | undefined>(this, undefined);\n\n\t/**\n\t * The promise that this object wraps.\n\t */\n\tpublic readonly promise: Promise<T>;\n\n\t/**\n\t * The current state of the promise.\n\t * Is `undefined` if the promise didn't resolve yet.\n\t */\n\tpublic readonly promiseResult: IObservable<PromiseResult<T> | undefined> = this._value;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(value => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseResolved */\n\t\t\t\tthis._value.set(new PromiseResult(value, undefined), tx);\n\t\t\t});\n\t\t\treturn value;\n\t\t}, error => {\n\t\t\ttransaction(tx => {\n\t\t\t\t/** @description onPromiseRejected */\n\t\t\t\tthis._value.set(new PromiseResult<T>(undefined, error), tx);\n\t\t\t});\n\t\t\tthrow error;\n\t\t});\n\t}\n}\n\nexport class PromiseResult<T> {\n\tconstructor(\n\t\t/**\n\t\t * The value of the resolved promise.\n\t\t * Undefined if the promise rejected.\n\t\t */\n\t\tpublic readonly data: T | undefined,\n\n\t\t/**\n\t\t * The error in case of a rejected promise.\n\t\t * Undefined if the promise resolved.\n\t\t */\n\t\tpublic readonly error: unknown | undefined,\n\t) {\n\t}\n\n\t/**\n\t * Returns the value if the promise resolved, otherwise throws the error.\n\t */\n\tpublic getDataOrThrow(): T {\n\t\tif (this.error) {\n\t\t\tthrow this.error;\n\t\t}\n\t\treturn this.data!;\n\t}\n}\n\n/**\n * A lazy promise whose state is observable.\n */\nexport class ObservableLazyPromise<T> {\n\tprivate readonly _lazyValue = new ObservableLazy(() => new ObservablePromise(this._computePromise()));\n\n\t/**\n\t * Does not enforce evaluation of the promise compute function.\n\t * Is undefined if the promise has not been computed yet.\n\t */\n\tpublic readonly cachedPromiseResult = derived(this, reader => this._lazyValue.cachedValue.read(reader)?.promiseResult.read(reader));\n\n\tconstructor(private readonly _computePromise: () => Promise<T>) {\n\t}\n\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._lazyValue.getValue().promise;\n\t}\n}\n\n/**\n * Resolves the promise when the observables state matches the predicate.\n */\nexport function waitForState<T, TState extends T>(observable: IObservable<T>, predicate: (state: T) => state is TState, isError?: (state: T) => boolean | unknown | undefined): Promise<TState>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T>;\nexport function waitForState<T>(observable: IObservable<T>, predicate: (state: T) => boolean, isError?: (state: T) => boolean | unknown | undefined): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tlet isImmediateRun = true;\n\t\tlet shouldDispose = false;\n\t\tconst stateObs = observable.map(state => {\n\t\t\t/** @description waitForState.state */\n\t\t\treturn {\n\t\t\t\tisFinished: predicate(state),\n\t\t\t\terror: isError ? isError(state) : false,\n\t\t\t\tstate\n\t\t\t};\n\t\t});\n\t\tconst d = autorun(reader => {\n\t\t\t/** @description waitForState */\n\t\t\tconst { isFinished, error, state } = stateObs.read(reader);\n\t\t\tif (isFinished || error) {\n\t\t\t\tif (isImmediateRun) {\n\t\t\t\t\t// The variable `d` is not initialized yet\n\t\t\t\t\tshouldDispose = true;\n\t\t\t\t} else {\n\t\t\t\t\td.dispose();\n\t\t\t\t}\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error === true ? state : error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(state);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tisImmediateRun = false;\n\t\tif (shouldDispose) {\n\t\t\td.dispose();\n\t\t}\n\t});\n}\n\nexport function derivedWithCancellationToken<T>(computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(owner: object, computeFn: (reader: IReader, cancellationToken: CancellationToken) => T): IObservable<T>;\nexport function derivedWithCancellationToken<T>(computeFnOrOwner: ((reader: IReader, cancellationToken: CancellationToken) => T) | object, computeFnOrUndefined?: ((reader: IReader, cancellationToken: CancellationToken) => T)): IObservable<T> {\n\tlet computeFn: (reader: IReader, store: CancellationToken) => T;\n\tlet owner: Owner;\n\tif (computeFnOrUndefined === undefined) {\n\t\tcomputeFn = computeFnOrOwner as any;\n\t\towner = undefined;\n\t} else {\n\t\towner = computeFnOrOwner;\n\t\tcomputeFn = computeFnOrUndefined as any;\n\t}\n\n\tlet cancellationTokenSource: CancellationTokenSource | undefined = undefined;\n\treturn new Derived(\n\t\tnew DebugNameData(owner, undefined, computeFn),\n\t\tr => {\n\t\t\tif (cancellationTokenSource) {\n\t\t\t\tcancellationTokenSource.dispose(true);\n\t\t\t}\n\t\t\tcancellationTokenSource = new CancellationTokenSource();\n\t\t\treturn computeFn(r, cancellationTokenSource.token);\n\t\t}, undefined,\n\t\tundefined,\n\t\t() => cancellationTokenSource?.dispose(),\n\t\tdefaultEqualityComparer,\n\t);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// This is a facade for the observable implementation. Only import from here!\n\nexport {\n\tIObservable,\n\tIObserver,\n\tIReader,\n\tISettable,\n\tISettableObservable,\n\tITransaction,\n\tIChangeContext,\n\tIChangeTracker,\n\tobservableValue,\n\tdisposableObservableValue,\n\ttransaction,\n\tsubtransaction,\n} from 'vs/base/common/observableInternal/base';\nexport {\n\tderived,\n\tderivedOpts,\n\tderivedHandleChanges,\n\tderivedWithStore,\n} from 'vs/base/common/observableInternal/derived';\nexport {\n\tautorun,\n\tautorunDelta,\n\tautorunHandleChanges,\n\tautorunWithStore,\n\tautorunOpts,\n\tautorunWithStoreHandleChanges,\n} from 'vs/base/common/observableInternal/autorun';\nexport {\n\tIObservableSignal,\n\tconstObservable,\n\tdebouncedObservable,\n\tderivedObservableWithCache,\n\tderivedObservableWithWritableCache,\n\tkeepObserved,\n\trecomputeInitiallyAndOnChange,\n\tobservableFromEvent,\n\tobservableFromPromise,\n\tobservableSignal,\n\tobservableSignalFromEvent,\n\twasEventTriggeredRecently,\n} from 'vs/base/common/observableInternal/utils';\nexport {\n\tObservableLazy,\n\tObservableLazyPromise,\n\tObservablePromise,\n\tPromiseResult,\n\twaitForState,\n\tderivedWithCancellationToken,\n} from 'vs/base/common/observableInternal/promise';\n\nimport { ConsoleObservableLogger, setLogger } from 'vs/base/common/observableInternal/logging';\n\n// Remove \"//\" in the next line to enable logging\nconst enableLogging = false\n\t// || Boolean(\"true\") // done \"weirdly\" so that a lint warning prevents you from pushing this\n\t;\n\nif (enableLogging) {\n\tsetLogger(new ConsoleObservableLogger());\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken } from 'vs/base/common/cancellation';\nimport { onUnexpectedError } from 'vs/base/common/errors';\nimport { DisposableStore, toDisposable } from 'vs/base/common/lifecycle';\n\n/**\n * The payload that flows in readable stream events.\n */\nexport type ReadableStreamEventPayload<T> = T | Error | 'end';\n\nexport interface ReadableStreamEvents<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t *\n\t * NOTE: PLEASE UNDERSTAND THAT ADDING A DATA LISTENER CAN\n\t * TURN THE STREAM INTO FLOWING MODE. IT IS THEREFOR THE\n\t * LAST LISTENER THAT SHOULD BE ADDED AND NOT THE FIRST\n\t *\n\t * Use `listenStream` as a helper method to listen to\n\t * stream events in the right order.\n\t */\n\ton(event: 'data', callback: (data: T) => void): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\ton(event: 'error', callback: (err: Error) => void): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\ton(event: 'end', callback: () => void): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * stream for use in native and web environments.\n */\nexport interface ReadableStream<T> extends ReadableStreamEvents<T> {\n\n\t/**\n\t * Stops emitting any events until resume() is called.\n\t */\n\tpause(): void;\n\n\t/**\n\t * Starts emitting events again after pause() was called.\n\t */\n\tresume(): void;\n\n\t/**\n\t * Destroys the stream and stops emitting any event.\n\t */\n\tdestroy(): void;\n\n\t/**\n\t * Allows to remove a listener that was previously added.\n\t */\n\tremoveListener(event: string, callback: Function): void;\n}\n\n/**\n * A interface that emulates the API shape of a node.js readable\n * for use in native and web environments.\n */\nexport interface Readable<T> {\n\n\t/**\n\t * Read data from the underlying source. Will return\n\t * null to indicate that no more data can be read.\n\t */\n\tread(): T | null;\n}\n\nexport function isReadable<T>(obj: unknown): obj is Readable<T> {\n\tconst candidate = obj as Readable<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn typeof candidate.read === 'function';\n}\n\n/**\n * A interface that emulates the API shape of a node.js writeable\n * stream for use in native and web environments.\n */\nexport interface WriteableStream<T> extends ReadableStream<T> {\n\n\t/**\n\t * Writing data to the stream will trigger the on('data')\n\t * event listener if the stream is flowing and buffer the\n\t * data otherwise until the stream is flowing.\n\t *\n\t * If a `highWaterMark` is configured and writing to the\n\t * stream reaches this mark, a promise will be returned\n\t * that should be awaited on before writing more data.\n\t * Otherwise there is a risk of buffering a large number\n\t * of data chunks without consumer.\n\t */\n\twrite(data: T): void | Promise<void>;\n\n\t/**\n\t * Signals an error to the consumer of the stream via the\n\t * on('error') handler if the stream is flowing.\n\t *\n\t * NOTE: call `end` to signal that the stream has ended,\n\t * this DOES NOT happen automatically from `error`.\n\t */\n\terror(error: Error): void;\n\n\t/**\n\t * Signals the end of the stream to the consumer. If the\n\t * result is provided, will trigger the on('data') event\n\t * listener if the stream is flowing and buffer the data\n\t * otherwise until the stream is flowing.\n\t */\n\tend(result?: T): void;\n}\n\n/**\n * A stream that has a buffer already read. Returns the original stream\n * that was read as well as the chunks that got read.\n *\n * The `ended` flag indicates if the stream has been fully consumed.\n */\nexport interface ReadableBufferedStream<T> {\n\n\t/**\n\t * The original stream that is being read.\n\t */\n\tstream: ReadableStream<T>;\n\n\t/**\n\t * An array of chunks already read from this stream.\n\t */\n\tbuffer: T[];\n\n\t/**\n\t * Signals if the stream has ended or not. If not, consumers\n\t * should continue to read from the stream until consumed.\n\t */\n\tended: boolean;\n}\n\nexport function isReadableStream<T>(obj: unknown): obj is ReadableStream<T> {\n\tconst candidate = obj as ReadableStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn [candidate.on, candidate.pause, candidate.resume, candidate.destroy].every(fn => typeof fn === 'function');\n}\n\nexport function isReadableBufferedStream<T>(obj: unknown): obj is ReadableBufferedStream<T> {\n\tconst candidate = obj as ReadableBufferedStream<T> | undefined;\n\tif (!candidate) {\n\t\treturn false;\n\t}\n\n\treturn isReadableStream(candidate.stream) && Array.isArray(candidate.buffer) && typeof candidate.ended === 'boolean';\n}\n\nexport interface IReducer<T, R = T> {\n\t(data: T[]): R;\n}\n\nexport interface IDataTransformer<Original, Transformed> {\n\t(data: Original): Transformed;\n}\n\nexport interface IErrorTransformer {\n\t(error: Error): Error;\n}\n\nexport interface ITransformer<Original, Transformed> {\n\tdata: IDataTransformer<Original, Transformed>;\n\terror?: IErrorTransformer;\n}\n\nexport function newWriteableStream<T>(reducer: IReducer<T>, options?: WriteableStreamOptions): WriteableStream<T> {\n\treturn new WriteableStreamImpl<T>(reducer, options);\n}\n\nexport interface WriteableStreamOptions {\n\n\t/**\n\t * The number of objects to buffer before WriteableStream#write()\n\t * signals back that the buffer is full. Can be used to reduce\n\t * the memory pressure when the stream is not flowing.\n\t */\n\thighWaterMark?: number;\n}\n\nclass WriteableStreamImpl<T> implements WriteableStream<T> {\n\n\tprivate readonly state = {\n\t\tflowing: false,\n\t\tended: false,\n\t\tdestroyed: false\n\t};\n\n\tprivate readonly buffer = {\n\t\tdata: [] as T[],\n\t\terror: [] as Error[]\n\t};\n\n\tprivate readonly listeners = {\n\t\tdata: [] as { (data: T): void }[],\n\t\terror: [] as { (error: Error): void }[],\n\t\tend: [] as { (): void }[]\n\t};\n\n\tprivate readonly pendingWritePromises: Function[] = [];\n\n\tconstructor(private reducer: IReducer<T>, private options?: WriteableStreamOptions) { }\n\n\tpause(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.state.flowing = false;\n\t}\n\n\tresume(): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.state.flowing) {\n\t\t\tthis.state.flowing = true;\n\n\t\t\t// emit buffered events\n\t\t\tthis.flowData();\n\t\t\tthis.flowErrors();\n\t\t\tthis.flowEnd();\n\t\t}\n\t}\n\n\twrite(data: T): void | Promise<void> {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the data to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitData(data);\n\t\t}\n\n\t\t// not yet flowing: buffer data until flowing\n\t\telse {\n\t\t\tthis.buffer.data.push(data);\n\n\t\t\t// highWaterMark: if configured, signal back when buffer reached limits\n\t\t\tif (typeof this.options?.highWaterMark === 'number' && this.buffer.data.length > this.options.highWaterMark) {\n\t\t\t\treturn new Promise(resolve => this.pendingWritePromises.push(resolve));\n\t\t\t}\n\t\t}\n\t}\n\n\terror(error: Error): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// flowing: directly send the error to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitError(error);\n\t\t}\n\n\t\t// not yet flowing: buffer errors until flowing\n\t\telse {\n\t\t\tthis.buffer.error.push(error);\n\t\t}\n\t}\n\n\tend(result?: T): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\t// end with data if provided\n\t\tif (typeof result !== 'undefined') {\n\t\t\tthis.write(result);\n\t\t}\n\n\t\t// flowing: send end event to listeners\n\t\tif (this.state.flowing) {\n\t\t\tthis.emitEnd();\n\n\t\t\tthis.destroy();\n\t\t}\n\n\t\t// not yet flowing: remember state\n\t\telse {\n\t\t\tthis.state.ended = true;\n\t\t}\n\t}\n\n\tprivate emitData(data: T): void {\n\t\tthis.listeners.data.slice(0).forEach(listener => listener(data)); // slice to avoid listener mutation from delivering event\n\t}\n\n\tprivate emitError(error: Error): void {\n\t\tif (this.listeners.error.length === 0) {\n\t\t\tonUnexpectedError(error); // nobody listened to this error so we log it as unexpected\n\t\t} else {\n\t\t\tthis.listeners.error.slice(0).forEach(listener => listener(error)); // slice to avoid listener mutation from delivering event\n\t\t}\n\t}\n\n\tprivate emitEnd(): void {\n\t\tthis.listeners.end.slice(0).forEach(listener => listener()); // slice to avoid listener mutation from delivering event\n\t}\n\n\ton(event: 'data', callback: (data: T) => void): void;\n\ton(event: 'error', callback: (err: Error) => void): void;\n\ton(event: 'end', callback: () => void): void;\n\ton(event: 'data' | 'error' | 'end', callback: (arg0?: any) => void): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tthis.listeners.data.push(callback);\n\n\t\t\t\t// switch into flowing mode as soon as the first 'data'\n\t\t\t\t// listener is added and we are not yet in flowing mode\n\t\t\t\tthis.resume();\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tthis.listeners.end.push(callback);\n\n\t\t\t\t// emit 'end' event directly if we are flowing\n\t\t\t\t// and the end has already been reached\n\t\t\t\t//\n\t\t\t\t// finish() when it went through\n\t\t\t\tif (this.state.flowing && this.flowEnd()) {\n\t\t\t\t\tthis.destroy();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tthis.listeners.error.push(callback);\n\n\t\t\t\t// emit buffered 'error' events unless done already\n\t\t\t\t// now that we know that we have at least one listener\n\t\t\t\tif (this.state.flowing) {\n\t\t\t\t\tthis.flowErrors();\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tremoveListener(event: string, callback: Function): void {\n\t\tif (this.state.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet listeners: unknown[] | undefined = undefined;\n\n\t\tswitch (event) {\n\t\t\tcase 'data':\n\t\t\t\tlisteners = this.listeners.data;\n\t\t\t\tbreak;\n\n\t\t\tcase 'end':\n\t\t\t\tlisteners = this.listeners.end;\n\t\t\t\tbreak;\n\n\t\t\tcase 'error':\n\t\t\t\tlisteners = this.listeners.error;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (listeners) {\n\t\t\tconst index = listeners.indexOf(callback);\n\t\t\tif (index >= 0) {\n\t\t\t\tlisteners.splice(index, 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate flowData(): void {\n\t\tif (this.buffer.data.length > 0) {\n\t\t\tconst fullDataBuffer = this.reducer(this.buffer.data);\n\n\t\t\tthis.emitData(fullDataBuffer);\n\n\t\t\tthis.buffer.data.length = 0;\n\n\t\t\t// When the buffer is empty, resolve all pending writers\n\t\t\tconst pendingWritePromises = [...this.pendingWritePromises];\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t\tpendingWritePromises.forEach(pendingWritePromise => pendingWritePromise());\n\t\t}\n\t}\n\n\tprivate flowErrors(): void {\n\t\tif (this.listeners.error.length > 0) {\n\t\t\tfor (const error of this.buffer.error) {\n\t\t\t\tthis.emitError(error);\n\t\t\t}\n\n\t\t\tthis.buffer.error.length = 0;\n\t\t}\n\t}\n\n\tprivate flowEnd(): boolean {\n\t\tif (this.state.ended) {\n\t\t\tthis.emitEnd();\n\n\t\t\treturn this.listeners.end.length > 0;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tdestroy(): void {\n\t\tif (!this.state.destroyed) {\n\t\t\tthis.state.destroyed = true;\n\t\t\tthis.state.ended = true;\n\n\t\t\tthis.buffer.data.length = 0;\n\t\t\tthis.buffer.error.length = 0;\n\n\t\t\tthis.listeners.data.length = 0;\n\t\t\tthis.listeners.error.length = 0;\n\t\t\tthis.listeners.end.length = 0;\n\n\t\t\tthis.pendingWritePromises.length = 0;\n\t\t}\n\t}\n}\n\n/**\n * Helper to fully read a T readable into a T.\n */\nexport function consumeReadable<T>(readable: Readable<T>, reducer: IReducer<T>): T {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null;\n\twhile ((chunk = readable.read()) !== null) {\n\t\tchunks.push(chunk);\n\t}\n\n\treturn reducer(chunks);\n}\n\n/**\n * Helper to read a T readable up to a maximum of chunks. If the limit is\n * reached, will return a readable instead to ensure all data can still\n * be read.\n */\nexport function peekReadable<T>(readable: Readable<T>, reducer: IReducer<T>, maxChunks: number): T | Readable<T> {\n\tconst chunks: T[] = [];\n\n\tlet chunk: T | null | undefined = undefined;\n\twhile ((chunk = readable.read()) !== null && chunks.length < maxChunks) {\n\t\tchunks.push(chunk);\n\t}\n\n\t// If the last chunk is null, it means we reached the end of\n\t// the readable and return all the data at once\n\tif (chunk === null && chunks.length > 0) {\n\t\treturn reducer(chunks);\n\t}\n\n\t// Otherwise, we still have a chunk, it means we reached the maxChunks\n\t// value and as such we return a new Readable that first returns\n\t// the existing read chunks and then continues with reading from\n\t// the underlying readable.\n\treturn {\n\t\tread: () => {\n\n\t\t\t// First consume chunks from our array\n\t\t\tif (chunks.length > 0) {\n\t\t\t\treturn chunks.shift()!;\n\t\t\t}\n\n\t\t\t// Then ensure to return our last read chunk\n\t\t\tif (typeof chunk !== 'undefined') {\n\t\t\t\tconst lastReadChunk = chunk;\n\n\t\t\t\t// explicitly use undefined here to indicate that we consumed\n\t\t\t\t// the chunk, which could have either been null or valued.\n\t\t\t\tchunk = undefined;\n\n\t\t\t\treturn lastReadChunk;\n\t\t\t}\n\n\t\t\t// Finally delegate back to the Readable\n\t\t\treturn readable.read();\n\t\t}\n\t};\n}\n\n/**\n * Helper to fully read a T stream into a T or consuming\n * a stream fully, awaiting all the events without caring\n * about the data.\n */\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer: IReducer<T, R>): Promise<R>;\nexport function consumeStream(stream: ReadableStreamEvents<unknown>): Promise<undefined>;\nexport function consumeStream<T, R = T>(stream: ReadableStreamEvents<T>, reducer?: IReducer<T, R>): Promise<R | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst chunks: T[] = [];\n\n\t\tlistenStream(stream, {\n\t\t\tonData: chunk => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tchunks.push(chunk);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonError: error => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t},\n\t\t\tonEnd: () => {\n\t\t\t\tif (reducer) {\n\t\t\t\t\tresolve(reducer(chunks));\n\t\t\t\t} else {\n\t\t\t\t\tresolve(undefined);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\nexport interface IStreamListener<T> {\n\n\t/**\n\t * The 'data' event is emitted whenever the stream is\n\t * relinquishing ownership of a chunk of data to a consumer.\n\t */\n\tonData(data: T): void;\n\n\t/**\n\t * Emitted when any error occurs.\n\t */\n\tonError(err: Error): void;\n\n\t/**\n\t * The 'end' event is emitted when there is no more data\n\t * to be consumed from the stream. The 'end' event will\n\t * not be emitted unless the data is completely consumed.\n\t */\n\tonEnd(): void;\n}\n\n/**\n * Helper to listen to all events of a T stream in proper order.\n */\nexport function listenStream<T>(stream: ReadableStreamEvents<T>, listener: IStreamListener<T>, token?: CancellationToken): void {\n\n\tstream.on('error', error => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onError(error);\n\t\t}\n\t});\n\n\tstream.on('end', () => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onEnd();\n\t\t}\n\t});\n\n\t// Adding the `data` listener will turn the stream\n\t// into flowing mode. As such it is important to\n\t// add this listener last (DO NOT CHANGE!)\n\tstream.on('data', data => {\n\t\tif (!token?.isCancellationRequested) {\n\t\t\tlistener.onData(data);\n\t\t}\n\t});\n}\n\n/**\n * Helper to peek up to `maxChunks` into a stream. The return type signals if\n * the stream has ended or not. If not, caller needs to add a `data` listener\n * to continue reading.\n */\nexport function peekStream<T>(stream: ReadableStream<T>, maxChunks: number): Promise<ReadableBufferedStream<T>> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst streamListeners = new DisposableStore();\n\t\tconst buffer: T[] = [];\n\n\t\t// Data Listener\n\t\tconst dataListener = (chunk: T) => {\n\n\t\t\t// Add to buffer\n\t\t\tbuffer.push(chunk);\n\n\t\t\t// We reached maxChunks and thus need to return\n\t\t\tif (buffer.length > maxChunks) {\n\n\t\t\t\t// Dispose any listeners and ensure to pause the\n\t\t\t\t// stream so that it can be consumed again by caller\n\t\t\t\tstreamListeners.dispose();\n\t\t\t\tstream.pause();\n\n\t\t\t\treturn resolve({ stream, buffer, ended: false });\n\t\t\t}\n\t\t};\n\n\t\t// Error Listener\n\t\tconst errorListener = (error: Error) => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn reject(error);\n\t\t};\n\n\t\t// End Listener\n\t\tconst endListener = () => {\n\t\t\tstreamListeners.dispose();\n\n\t\t\treturn resolve({ stream, buffer, ended: true });\n\t\t};\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('error', errorListener)));\n\t\tstream.on('error', errorListener);\n\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('end', endListener)));\n\t\tstream.on('end', endListener);\n\n\t\t// Important: leave the `data` listener last because\n\t\t// this can turn the stream into flowing mode and we\n\t\t// want `error` events to be received as well.\n\t\tstreamListeners.add(toDisposable(() => stream.removeListener('data', dataListener)));\n\t\tstream.on('data', dataListener);\n\t});\n}\n\n/**\n * Helper to create a readable stream from an existing T.\n */\nexport function toStream<T>(t: T, reducer: IReducer<T>): ReadableStream<T> {\n\tconst stream = newWriteableStream<T>(reducer);\n\n\tstream.end(t);\n\n\treturn stream;\n}\n\n/**\n * Helper to create an empty stream\n */\nexport function emptyStream(): ReadableStream<never> {\n\tconst stream = newWriteableStream<never>(() => { throw new Error('not supported'); });\n\tstream.end();\n\n\treturn stream;\n}\n\n/**\n * Helper to convert a T into a Readable<T>.\n */\nexport function toReadable<T>(t: T): Readable<T> {\n\tlet consumed = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tif (consumed) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tconsumed = true;\n\n\t\t\treturn t;\n\t\t}\n\t};\n}\n\n/**\n * Helper to transform a readable stream into another stream.\n */\nexport function transform<Original, Transformed>(stream: ReadableStreamEvents<Original>, transformer: ITransformer<Original, Transformed>, reducer: IReducer<Transformed>): ReadableStream<Transformed> {\n\tconst target = newWriteableStream<Transformed>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => target.write(transformer.data(data)),\n\t\tonError: error => target.error(transformer.error ? transformer.error(error) : error),\n\t\tonEnd: () => target.end()\n\t});\n\n\treturn target;\n}\n\n/**\n * Helper to take an existing readable that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedReadable<T>(prefix: T, readable: Readable<T>, reducer: IReducer<T>): Readable<T> {\n\tlet prefixHandled = false;\n\n\treturn {\n\t\tread: () => {\n\t\t\tconst chunk = readable.read();\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\t// If we have also a read-result, make\n\t\t\t\t// sure to reduce it to a single result\n\t\t\t\tif (chunk !== null) {\n\t\t\t\t\treturn reducer([prefix, chunk]);\n\t\t\t\t}\n\n\t\t\t\t// Otherwise, just return prefix directly\n\t\t\t\treturn prefix;\n\t\t\t}\n\n\t\t\treturn chunk;\n\t\t}\n\t};\n}\n\n/**\n * Helper to take an existing stream that will\n * have a prefix injected to the beginning.\n */\nexport function prefixedStream<T>(prefix: T, stream: ReadableStream<T>, reducer: IReducer<T>): ReadableStream<T> {\n\tlet prefixHandled = false;\n\n\tconst target = newWriteableStream<T>(reducer);\n\n\tlistenStream(stream, {\n\t\tonData: data => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\treturn target.write(reducer([prefix, data]));\n\t\t\t}\n\n\t\t\treturn target.write(data);\n\t\t},\n\t\tonError: error => target.error(error),\n\t\tonEnd: () => {\n\n\t\t\t// Handle prefix only once\n\t\t\tif (!prefixHandled) {\n\t\t\t\tprefixHandled = true;\n\n\t\t\t\ttarget.write(prefix);\n\t\t\t}\n\n\t\t\ttarget.end();\n\t\t}\n\t});\n\n\treturn target;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Lazy } from 'vs/base/common/lazy';\nimport * as streams from 'vs/base/common/stream';\n\ndeclare const Buffer: any;\n\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\n\nlet textEncoder: TextEncoder | null;\nlet textDecoder: TextDecoder | null;\n\nexport class VSBuffer {\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic alloc(byteLength: number): VSBuffer {\n\t\tif (hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.allocUnsafe(byteLength));\n\t\t} else {\n\t\t\treturn new VSBuffer(new Uint8Array(byteLength));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n\t * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n\t * which is not transferrable.\n\t */\n\tstatic wrap(actual: Uint8Array): VSBuffer {\n\t\tif (hasBuffer && !(Buffer.isBuffer(actual))) {\n\t\t\t// https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n\t\t\t// Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n\t\t\tactual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n\t\t}\n\t\treturn new VSBuffer(actual);\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromString(source: string, options?: { dontUseNodeBuffer?: boolean }): VSBuffer {\n\t\tconst dontUseNodeBuffer = options?.dontUseNodeBuffer || false;\n\t\tif (!dontUseNodeBuffer && hasBuffer) {\n\t\t\treturn new VSBuffer(Buffer.from(source));\n\t\t} else {\n\t\t\tif (!textEncoder) {\n\t\t\t\ttextEncoder = new TextEncoder();\n\t\t\t}\n\t\t\treturn new VSBuffer(textEncoder.encode(source));\n\t\t}\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic fromByteArray(source: number[]): VSBuffer {\n\t\tconst result = VSBuffer.alloc(source.length);\n\t\tfor (let i = 0, len = source.length; i < len; i++) {\n\t\t\tresult.buffer[i] = source[i];\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tstatic concat(buffers: VSBuffer[], totalLength?: number): VSBuffer {\n\t\tif (typeof totalLength === 'undefined') {\n\t\t\ttotalLength = 0;\n\t\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\t\ttotalLength += buffers[i].byteLength;\n\t\t\t}\n\t\t}\n\n\t\tconst ret = VSBuffer.alloc(totalLength);\n\t\tlet offset = 0;\n\t\tfor (let i = 0, len = buffers.length; i < len; i++) {\n\t\t\tconst element = buffers[i];\n\t\t\tret.set(element, offset);\n\t\t\toffset += element.byteLength;\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\treadonly buffer: Uint8Array;\n\treadonly byteLength: number;\n\n\tprivate constructor(buffer: Uint8Array) {\n\t\tthis.buffer = buffer;\n\t\tthis.byteLength = this.buffer.byteLength;\n\t}\n\n\t/**\n\t * When running in a nodejs context, the backing store for the returned `VSBuffer` instance\n\t * might use a nodejs Buffer allocated from node's Buffer pool, which is not transferrable.\n\t */\n\tclone(): VSBuffer {\n\t\tconst result = VSBuffer.alloc(this.byteLength);\n\t\tresult.set(this);\n\t\treturn result;\n\t}\n\n\ttoString(): string {\n\t\tif (hasBuffer) {\n\t\t\treturn this.buffer.toString();\n\t\t} else {\n\t\t\tif (!textDecoder) {\n\t\t\t\ttextDecoder = new TextDecoder();\n\t\t\t}\n\t\t\treturn textDecoder.decode(this.buffer);\n\t\t}\n\t}\n\n\tslice(start?: number, end?: number): VSBuffer {\n\t\t// IMPORTANT: use subarray instead of slice because TypedArray#slice\n\t\t// creates shallow copy and NodeBuffer#slice doesn't. The use of subarray\n\t\t// ensures the same, performance, behaviour.\n\t\treturn new VSBuffer(this.buffer.subarray(start, end));\n\t}\n\n\tset(array: VSBuffer, offset?: number): void;\n\tset(array: Uint8Array, offset?: number): void;\n\tset(array: ArrayBuffer, offset?: number): void;\n\tset(array: ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void;\n\tset(array: VSBuffer | Uint8Array | ArrayBuffer | ArrayBufferView, offset?: number): void {\n\t\tif (array instanceof VSBuffer) {\n\t\t\tthis.buffer.set(array.buffer, offset);\n\t\t} else if (array instanceof Uint8Array) {\n\t\t\tthis.buffer.set(array, offset);\n\t\t} else if (array instanceof ArrayBuffer) {\n\t\t\tthis.buffer.set(new Uint8Array(array), offset);\n\t\t} else if (ArrayBuffer.isView(array)) {\n\t\t\tthis.buffer.set(new Uint8Array(array.buffer, array.byteOffset, array.byteLength), offset);\n\t\t} else {\n\t\t\tthrow new Error(`Unknown argument 'array'`);\n\t\t}\n\t}\n\n\treadUInt32BE(offset: number): number {\n\t\treturn readUInt32BE(this.buffer, offset);\n\t}\n\n\twriteUInt32BE(value: number, offset: number): void {\n\t\twriteUInt32BE(this.buffer, value, offset);\n\t}\n\n\treadUInt32LE(offset: number): number {\n\t\treturn readUInt32LE(this.buffer, offset);\n\t}\n\n\twriteUInt32LE(value: number, offset: number): void {\n\t\twriteUInt32LE(this.buffer, value, offset);\n\t}\n\n\treadUInt8(offset: number): number {\n\t\treturn readUInt8(this.buffer, offset);\n\t}\n\n\twriteUInt8(value: number, offset: number): void {\n\t\twriteUInt8(this.buffer, value, offset);\n\t}\n\n\tindexOf(subarray: VSBuffer | Uint8Array, offset = 0) {\n\t\treturn binaryIndexOf(this.buffer, subarray instanceof VSBuffer ? subarray.buffer : subarray, offset);\n\t}\n}\n\n/**\n * Like String.indexOf, but works on Uint8Arrays.\n * Uses the boyer-moore-horspool algorithm to be reasonably speedy.\n */\nexport function binaryIndexOf(haystack: Uint8Array, needle: Uint8Array, offset = 0): number {\n\tconst needleLen = needle.byteLength;\n\tconst haystackLen = haystack.byteLength;\n\n\tif (needleLen === 0) {\n\t\treturn 0;\n\t}\n\n\tif (needleLen === 1) {\n\t\treturn haystack.indexOf(needle[0]);\n\t}\n\n\tif (needleLen > haystackLen - offset) {\n\t\treturn -1;\n\t}\n\n\t// find index of the subarray using boyer-moore-horspool algorithm\n\tconst table = indexOfTable.value;\n\ttable.fill(needle.length);\n\tfor (let i = 0; i < needle.length; i++) {\n\t\ttable[needle[i]] = needle.length - i - 1;\n\t}\n\n\tlet i = offset + needle.length - 1;\n\tlet j = i;\n\tlet result = -1;\n\twhile (i < haystackLen) {\n\t\tif (haystack[i] === needle[j]) {\n\t\t\tif (j === 0) {\n\t\t\t\tresult = i;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ti--;\n\t\t\tj--;\n\t\t} else {\n\t\t\ti += Math.max(needle.length - j, table[haystack[i]]);\n\t\t\tj = needle.length - 1;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nexport function readUInt16LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0)\n\t);\n}\n\nexport function writeUInt16LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n}\n\nexport function readUInt32BE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\tsource[offset] * 2 ** 24\n\t\t+ source[offset + 1] * 2 ** 16\n\t\t+ source[offset + 2] * 2 ** 8\n\t\t+ source[offset + 3]\n\t);\n}\n\nexport function writeUInt32BE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 3] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = value;\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = value;\n\tvalue = value >>> 8;\n\tdestination[offset] = value;\n}\n\nexport function readUInt32LE(source: Uint8Array, offset: number): number {\n\treturn (\n\t\t((source[offset + 0] << 0) >>> 0) |\n\t\t((source[offset + 1] << 8) >>> 0) |\n\t\t((source[offset + 2] << 16) >>> 0) |\n\t\t((source[offset + 3] << 24) >>> 0)\n\t);\n}\n\nexport function writeUInt32LE(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset + 0] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 1] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 2] = (value & 0b11111111);\n\tvalue = value >>> 8;\n\tdestination[offset + 3] = (value & 0b11111111);\n}\n\nexport function readUInt8(source: Uint8Array, offset: number): number {\n\treturn source[offset];\n}\n\nexport function writeUInt8(destination: Uint8Array, value: number, offset: number): void {\n\tdestination[offset] = value;\n}\n\nexport interface VSBufferReadable extends streams.Readable<VSBuffer> { }\n\nexport interface VSBufferReadableStream extends streams.ReadableStream<VSBuffer> { }\n\nexport interface VSBufferWriteableStream extends streams.WriteableStream<VSBuffer> { }\n\nexport interface VSBufferReadableBufferedStream extends streams.ReadableBufferedStream<VSBuffer> { }\n\nexport function readableToBuffer(readable: VSBufferReadable): VSBuffer {\n\treturn streams.consumeReadable<VSBuffer>(readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function bufferToReadable(buffer: VSBuffer): VSBufferReadable {\n\treturn streams.toReadable<VSBuffer>(buffer);\n}\n\nexport function streamToBuffer(stream: streams.ReadableStream<VSBuffer>): Promise<VSBuffer> {\n\treturn streams.consumeStream<VSBuffer>(stream, chunks => VSBuffer.concat(chunks));\n}\n\nexport async function bufferedStreamToBuffer(bufferedStream: streams.ReadableBufferedStream<VSBuffer>): Promise<VSBuffer> {\n\tif (bufferedStream.ended) {\n\t\treturn VSBuffer.concat(bufferedStream.buffer);\n\t}\n\n\treturn VSBuffer.concat([\n\n\t\t// Include already read chunks...\n\t\t...bufferedStream.buffer,\n\n\t\t// ...and all additional chunks\n\t\tawait streamToBuffer(bufferedStream.stream)\n\t]);\n}\n\nexport function bufferToStream(buffer: VSBuffer): streams.ReadableStream<VSBuffer> {\n\treturn streams.toStream<VSBuffer>(buffer, chunks => VSBuffer.concat(chunks));\n}\n\nexport function streamToBufferReadableStream(stream: streams.ReadableStreamEvents<Uint8Array | string>): streams.ReadableStream<VSBuffer> {\n\treturn streams.transform<Uint8Array | string, VSBuffer>(stream, { data: data => typeof data === 'string' ? VSBuffer.fromString(data) : VSBuffer.wrap(data) }, chunks => VSBuffer.concat(chunks));\n}\n\nexport function newWriteableBufferStream(options?: streams.WriteableStreamOptions): streams.WriteableStream<VSBuffer> {\n\treturn streams.newWriteableStream<VSBuffer>(chunks => VSBuffer.concat(chunks), options);\n}\n\nexport function prefixedBufferReadable(prefix: VSBuffer, readable: VSBufferReadable): VSBufferReadable {\n\treturn streams.prefixedReadable(prefix, readable, chunks => VSBuffer.concat(chunks));\n}\n\nexport function prefixedBufferStream(prefix: VSBuffer, stream: VSBufferReadableStream): VSBufferReadableStream {\n\treturn streams.prefixedStream(prefix, stream, chunks => VSBuffer.concat(chunks));\n}\n\n/** Decodes base64 to a uint8 array. URL-encoded and unpadded base64 is allowed. */\nexport function decodeBase64(encoded: string) {\n\tlet building = 0;\n\tlet remainder = 0;\n\tlet bufi = 0;\n\n\t// The simpler way to do this is `Uint8Array.from(atob(str), c => c.charCodeAt(0))`,\n\t// but that's about 10-20x slower than this function in current Chromium versions.\n\n\tconst buffer = new Uint8Array(Math.floor(encoded.length / 4 * 3));\n\tconst append = (value: number) => {\n\t\tswitch (remainder) {\n\t\t\tcase 3:\n\t\t\t\tbuffer[bufi++] = building | value;\n\t\t\t\tremainder = 0;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 2);\n\t\t\t\tbuilding = value << 6;\n\t\t\t\tremainder = 3;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tbuffer[bufi++] = building | (value >>> 4);\n\t\t\t\tbuilding = value << 4;\n\t\t\t\tremainder = 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbuilding = value << 2;\n\t\t\t\tremainder = 1;\n\t\t}\n\t};\n\n\tfor (let i = 0; i < encoded.length; i++) {\n\t\tconst code = encoded.charCodeAt(i);\n\t\t// See https://datatracker.ietf.org/doc/html/rfc4648#section-4\n\t\t// This branchy code is about 3x faster than an indexOf on a base64 char string.\n\t\tif (code >= 65 && code <= 90) {\n\t\t\tappend(code - 65); // A-Z starts ranges from char code 65 to 90\n\t\t} else if (code >= 97 && code <= 122) {\n\t\t\tappend(code - 97 + 26); // a-z starts ranges from char code 97 to 122, starting at byte 26\n\t\t} else if (code >= 48 && code <= 57) {\n\t\t\tappend(code - 48 + 52); // 0-9 starts ranges from char code 48 to 58, starting at byte 52\n\t\t} else if (code === 43 || code === 45) {\n\t\t\tappend(62); // \"+\" or \"-\" for URLS\n\t\t} else if (code === 47 || code === 95) {\n\t\t\tappend(63); // \"/\" or \"_\" for URLS\n\t\t} else if (code === 61) {\n\t\t\tbreak; // \"=\"\n\t\t} else {\n\t\t\tthrow new SyntaxError(`Unexpected base64 character ${encoded[i]}`);\n\t\t}\n\t}\n\n\tconst unpadded = bufi;\n\twhile (remainder > 0) {\n\t\tappend(0);\n\t}\n\n\t// slice is needed to account for overestimation due to padding\n\treturn VSBuffer.wrap(buffer).slice(0, unpadded);\n}\n\nconst base64Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst base64UrlSafeAlphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';\n\n/** Encodes a buffer to a base64 string. */\nexport function encodeBase64({ buffer }: VSBuffer, padded = true, urlSafe = false) {\n\tconst dictionary = urlSafe ? base64UrlSafeAlphabet : base64Alphabet;\n\tlet output = '';\n\n\tconst remainder = buffer.byteLength % 3;\n\n\tlet i = 0;\n\tfor (; i < buffer.byteLength - remainder; i += 3) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\tconst c = buffer[i + 2];\n\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2 | c >>> 6) & 0b111111];\n\t\toutput += dictionary[c & 0b111111];\n\t}\n\n\tif (remainder === 1) {\n\t\tconst a = buffer[i + 0];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4) & 0b111111];\n\t\tif (padded) { output += '=='; }\n\t} else if (remainder === 2) {\n\t\tconst a = buffer[i + 0];\n\t\tconst b = buffer[i + 1];\n\t\toutput += dictionary[a >>> 2];\n\t\toutput += dictionary[(a << 4 | b >>> 4) & 0b111111];\n\t\toutput += dictionary[(b << 2) & 0b111111];\n\t\tif (padded) { output += '='; }\n\t}\n\n\treturn output;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n\n\t/**\n\t * Scheme used for special rendering of features in the release notes\n\t */\n\texport const codeFeature = 'code-feature';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _remoteResourcesPath: string = `/${Schemas.vscodeRemoteResource}`;\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(serverRootPath: string): void {\n\t\tthis._remoteResourcesPath = `${serverRootPath}/${Schemas.vscodeRemoteResource}`;\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isESM } from 'vs/base/common/amd';\nimport { AppResourcePath, FileAccess, nodeModulesAsarPath, nodeModulesPath } from 'vs/base/common/network';\nimport * as platform from 'vs/base/common/platform';\nimport { IProductConfiguration } from 'vs/base/common/product';\nimport { URI } from 'vs/base/common/uri';\n\n\nclass DefineCall {\n\tconstructor(\n\t\tpublic readonly id: string | null | undefined,\n\t\tpublic readonly dependencies: string[] | null | undefined,\n\t\tpublic readonly callback: any\n\t) { }\n}\n\nclass AMDModuleImporter {\n\tpublic static INSTANCE = new AMDModuleImporter();\n\n\tprivate readonly _isWebWorker = (typeof self === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope');\n\tprivate readonly _isRenderer = typeof document === 'object';\n\n\tprivate readonly _defineCalls: DefineCall[] = [];\n\tprivate _initialized = false;\n\tprivate _amdPolicy: Pick<TrustedTypePolicy<{\n\t\tcreateScriptURL(value: string): string;\n\t}>, 'name' | 'createScriptURL'> | undefined;\n\n\tconstructor() { }\n\n\tprivate _initialize(): void {\n\t\tif (this._initialized) {\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\t(<any>globalThis).define = (id: any, dependencies: any, callback: any) => {\n\t\t\tif (typeof id !== 'string') {\n\t\t\t\tcallback = dependencies;\n\t\t\t\tdependencies = id;\n\t\t\t\tid = null;\n\t\t\t}\n\t\t\tif (typeof dependencies !== 'object' || !Array.isArray(dependencies)) {\n\t\t\t\tcallback = dependencies;\n\t\t\t\tdependencies = null;\n\t\t\t}\n\t\t\t// if (!dependencies) {\n\t\t\t// \tdependencies = ['require', 'exports', 'module'];\n\t\t\t// }\n\t\t\tthis._defineCalls.push(new DefineCall(id, dependencies, callback));\n\t\t};\n\n\t\t(<any>globalThis).define.amd = true;\n\n\t\tif (this._isRenderer) {\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\tthis._amdPolicy = window.trustedTypes?.createPolicy('amdLoader', {\n\t\t\t\tcreateScriptURL(value) {\n\t\t\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\t\t\tif (value.startsWith(window.location.origin)) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tif (value.startsWith('vscode-file://vscode-app')) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(`[trusted_script_src] Invalid script url: ${value}`);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (this._isWebWorker) {\n\t\t\tthis._amdPolicy = (<any>globalThis).trustedTypes?.createPolicy('amdLoader', {\n\t\t\t\tcreateScriptURL(value: string) {\n\t\t\t\t\treturn value;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic async load<T>(scriptSrc: string): Promise<T> {\n\t\tthis._initialize();\n\t\tconst defineCall = await (this._isWebWorker ? this._workerLoadScript(scriptSrc) : this._isRenderer ? this._rendererLoadScript(scriptSrc) : this._nodeJSLoadScript(scriptSrc));\n\t\tif (!defineCall) {\n\t\t\tthrow new Error(`Did not receive a define call from script ${scriptSrc}`);\n\t\t}\n\t\t// TODO require, exports, module\n\t\tif (Array.isArray(defineCall.dependencies) && defineCall.dependencies.length > 0) {\n\t\t\tthrow new Error(`Cannot resolve dependencies for script ${scriptSrc}. The dependencies are: ${defineCall.dependencies.join(', ')}`);\n\t\t}\n\t\tif (typeof defineCall.callback === 'function') {\n\t\t\treturn defineCall.callback([]);\n\t\t} else {\n\t\t\treturn defineCall.callback;\n\t\t}\n\t}\n\n\tprivate _rendererLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\treturn new Promise<DefineCall | undefined>((resolve, reject) => {\n\t\t\tconst scriptElement = document.createElement('script');\n\t\t\tscriptElement.setAttribute('async', 'async');\n\t\t\tscriptElement.setAttribute('type', 'text/javascript');\n\n\t\t\tconst unbind = () => {\n\t\t\t\tscriptElement.removeEventListener('load', loadEventListener);\n\t\t\t\tscriptElement.removeEventListener('error', errorEventListener);\n\t\t\t};\n\n\t\t\tconst loadEventListener = (e: any) => {\n\t\t\t\tunbind();\n\t\t\t\tresolve(this._defineCalls.pop());\n\t\t\t};\n\n\t\t\tconst errorEventListener = (e: any) => {\n\t\t\t\tunbind();\n\t\t\t\treject(e);\n\t\t\t};\n\n\t\t\tscriptElement.addEventListener('load', loadEventListener);\n\t\t\tscriptElement.addEventListener('error', errorEventListener);\n\t\t\tif (this._amdPolicy) {\n\t\t\t\tscriptSrc = this._amdPolicy.createScriptURL(scriptSrc) as any as string;\n\t\t\t}\n\t\t\tscriptElement.setAttribute('src', scriptSrc);\n\t\t\t// eslint-disable-next-line no-restricted-globals\n\t\t\twindow.document.getElementsByTagName('head')[0].appendChild(scriptElement);\n\t\t});\n\t}\n\n\tprivate _workerLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\treturn new Promise<DefineCall | undefined>((resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tif (this._amdPolicy) {\n\t\t\t\t\tscriptSrc = this._amdPolicy.createScriptURL(scriptSrc) as any as string;\n\t\t\t\t}\n\t\t\t\timportScripts(scriptSrc);\n\t\t\t\tresolve(this._defineCalls.pop());\n\t\t\t} catch (err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate async _nodeJSLoadScript(scriptSrc: string): Promise<DefineCall | undefined> {\n\t\ttry {\n\t\t\tconst fs = <typeof import('fs')>globalThis._VSCODE_NODE_MODULES['fs'];\n\t\t\tconst vm = <typeof import('vm')>globalThis._VSCODE_NODE_MODULES['vm'];\n\t\t\tconst module = <typeof import('module')>globalThis._VSCODE_NODE_MODULES['module'];\n\n\t\t\tconst filePath = URI.parse(scriptSrc).fsPath;\n\t\t\tconst content = fs.readFileSync(filePath).toString();\n\t\t\tconst scriptSource = module.wrap(content.replace(/^#!.*/, ''));\n\t\t\tconst script = new vm.Script(scriptSource);\n\t\t\tconst compileWrapper = script.runInThisContext();\n\t\t\tcompileWrapper.apply();\n\t\t\treturn this._defineCalls.pop();\n\n\t\t} catch (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n\nconst cache = new Map<string, Promise<any>>();\n\nlet _paths: Record<string, string> = {};\nif (typeof globalThis.require === 'object') {\n\t_paths = (<Record<string, any>>globalThis.require).paths ?? {};\n}\n\n/**\n * Utility for importing an AMD node module. This util supports AMD and ESM contexts and should be used while the ESM adoption\n * is on its way.\n *\n * e.g. pass in `vscode-textmate/release/main.js`\n */\nexport async function importAMDNodeModule<T>(nodeModuleName: string, pathInsideNodeModule: string, isBuilt?: boolean): Promise<T> {\n\tif (isESM) {\n\n\t\tif (isBuilt === undefined) {\n\t\t\tconst product = globalThis._VSCODE_PRODUCT_JSON as unknown as IProductConfiguration;\n\t\t\tisBuilt = Boolean((product ?? (<any>globalThis).vscode?.context?.configuration()?.product)?.commit);\n\t\t}\n\n\t\tif (_paths[nodeModuleName]) {\n\t\t\tnodeModuleName = _paths[nodeModuleName];\n\t\t}\n\n\t\tconst nodeModulePath = `${nodeModuleName}/${pathInsideNodeModule}`;\n\t\tif (cache.has(nodeModulePath)) {\n\t\t\treturn cache.get(nodeModulePath)!;\n\t\t}\n\t\tlet scriptSrc: string;\n\t\tif (/^\\w[\\w\\d+.-]*:\\/\\//.test(nodeModulePath)) {\n\t\t\t// looks like a URL\n\t\t\t// bit of a special case for: src/vs/workbench/services/languageDetection/browser/languageDetectionSimpleWorker.ts\n\t\t\tscriptSrc = nodeModulePath;\n\t\t} else {\n\t\t\tconst useASAR = (isBuilt && !platform.isWeb);\n\t\t\tconst actualNodeModulesPath = (useASAR ? nodeModulesAsarPath : nodeModulesPath);\n\t\t\tconst resourcePath: AppResourcePath = `${actualNodeModulesPath}/${nodeModulePath}`;\n\t\t\tscriptSrc = FileAccess.asBrowserUri(resourcePath).toString(true);\n\t\t}\n\t\tconst result = AMDModuleImporter.INSTANCE.load<T>(scriptSrc);\n\t\tcache.set(nodeModulePath, result);\n\t\treturn result;\n\t} else {\n\t\treturn await import(nodeModuleName);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { BugIndicatingError, CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\nimport { Lazy } from 'vs/base/common/lazy';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tif (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: IdleApi, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitFn: (item: T) => void;\n\n\tconstructor() {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitFn = (item: T) => emitter.emitOne(item);\n\t\t\treturn this._deferred.p;\n\t\t});\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\t\tthis._emitFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitFn(item);\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\n\nexport const enum StringEOL {\n\tUnknown = 0,\n\tInvalid = 3,\n\tLF = 1,\n\tCRLF = 2\n}\n\nexport function countEOL(text: string): [number, number, number, StringEOL] {\n\tlet eolCount = 0;\n\tlet firstLineLength = 0;\n\tlet lastLineStart = 0;\n\tlet eol: StringEOL = StringEOL.Unknown;\n\tfor (let i = 0, len = text.length; i < len; i++) {\n\t\tconst chr = text.charCodeAt(i);\n\n\t\tif (chr === CharCode.CarriageReturn) {\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tif (i + 1 < len && text.charCodeAt(i + 1) === CharCode.LineFeed) {\n\t\t\t\t// \\r\\n... case\n\t\t\t\teol |= StringEOL.CRLF;\n\t\t\t\ti++; // skip \\n\n\t\t\t} else {\n\t\t\t\t// \\r... case\n\t\t\t\teol |= StringEOL.Invalid;\n\t\t\t}\n\t\t\tlastLineStart = i + 1;\n\t\t} else if (chr === CharCode.LineFeed) {\n\t\t\t// \\n... case\n\t\t\teol |= StringEOL.LF;\n\t\t\tif (eolCount === 0) {\n\t\t\t\tfirstLineLength = i;\n\t\t\t}\n\t\t\teolCount++;\n\t\t\tlastLineStart = i + 1;\n\t\t}\n\t}\n\tif (eolCount === 0) {\n\t\tfirstLineLength = text.length;\n\t}\n\treturn [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Open ended enum at runtime\n */\nexport const enum LanguageId {\n\tNull = 0,\n\tPlainText = 1\n}\n\n/**\n * A font style. Values are 2^x such that a bit mask can be used.\n */\nexport const enum FontStyle {\n\tNotSet = -1,\n\tNone = 0,\n\tItalic = 1,\n\tBold = 2,\n\tUnderline = 4,\n\tStrikethrough = 8,\n}\n\n/**\n * Open ended enum at runtime\n */\nexport const enum ColorId {\n\tNone = 0,\n\tDefaultForeground = 1,\n\tDefaultBackground = 2\n}\n\n/**\n * A standard token type.\n */\nexport const enum StandardTokenType {\n\tOther = 0,\n\tComment = 1,\n\tString = 2,\n\tRegEx = 3\n}\n\n/**\n * Helpers to manage the \"collapsed\" metadata of an entire StackElement stack.\n * The following assumptions have been made:\n *  - languageId < 256 => needs 8 bits\n *  - unique color count < 512 => needs 9 bits\n *\n * The binary format is:\n * - -------------------------------------------\n *     3322 2222 2222 1111 1111 1100 0000 0000\n *     1098 7654 3210 9876 5432 1098 7654 3210\n * - -------------------------------------------\n *     xxxx xxxx xxxx xxxx xxxx xxxx xxxx xxxx\n *     bbbb bbbb ffff ffff fFFF FBTT LLLL LLLL\n * - -------------------------------------------\n *  - L = LanguageId (8 bits)\n *  - T = StandardTokenType (2 bits)\n *  - B = Balanced bracket (1 bit)\n *  - F = FontStyle (4 bits)\n *  - f = foreground color (9 bits)\n *  - b = background color (9 bits)\n *\n */\nexport const enum MetadataConsts {\n\tLANGUAGEID_MASK = 0b00000000000000000000000011111111,\n\tTOKEN_TYPE_MASK = 0b00000000000000000000001100000000,\n\tBALANCED_BRACKETS_MASK = 0b00000000000000000000010000000000,\n\tFONT_STYLE_MASK = 0b00000000000000000111100000000000,\n\tFOREGROUND_MASK = 0b00000000111111111000000000000000,\n\tBACKGROUND_MASK = 0b11111111000000000000000000000000,\n\n\tITALIC_MASK = 0b00000000000000000000100000000000,\n\tBOLD_MASK = 0b00000000000000000001000000000000,\n\tUNDERLINE_MASK = 0b00000000000000000010000000000000,\n\tSTRIKETHROUGH_MASK = 0b00000000000000000100000000000000,\n\n\t// Semantic tokens cannot set the language id, so we can\n\t// use the first 8 bits for control purposes\n\tSEMANTIC_USE_ITALIC = 0b00000000000000000000000000000001,\n\tSEMANTIC_USE_BOLD = 0b00000000000000000000000000000010,\n\tSEMANTIC_USE_UNDERLINE = 0b00000000000000000000000000000100,\n\tSEMANTIC_USE_STRIKETHROUGH = 0b00000000000000000000000000001000,\n\tSEMANTIC_USE_FOREGROUND = 0b00000000000000000000000000010000,\n\tSEMANTIC_USE_BACKGROUND = 0b00000000000000000000000000100000,\n\n\tLANGUAGEID_OFFSET = 0,\n\tTOKEN_TYPE_OFFSET = 8,\n\tBALANCED_BRACKETS_OFFSET = 10,\n\tFONT_STYLE_OFFSET = 11,\n\tFOREGROUND_OFFSET = 15,\n\tBACKGROUND_OFFSET = 24\n}\n\n/**\n */\nexport class TokenMetadata {\n\n\tpublic static getLanguageId(metadata: number): LanguageId {\n\t\treturn (metadata & MetadataConsts.LANGUAGEID_MASK) >>> MetadataConsts.LANGUAGEID_OFFSET;\n\t}\n\n\tpublic static getTokenType(metadata: number): StandardTokenType {\n\t\treturn (metadata & MetadataConsts.TOKEN_TYPE_MASK) >>> MetadataConsts.TOKEN_TYPE_OFFSET;\n\t}\n\n\tpublic static containsBalancedBrackets(metadata: number): boolean {\n\t\treturn (metadata & MetadataConsts.BALANCED_BRACKETS_MASK) !== 0;\n\t}\n\n\tpublic static getFontStyle(metadata: number): FontStyle {\n\t\treturn (metadata & MetadataConsts.FONT_STYLE_MASK) >>> MetadataConsts.FONT_STYLE_OFFSET;\n\t}\n\n\tpublic static getForeground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.FOREGROUND_MASK) >>> MetadataConsts.FOREGROUND_OFFSET;\n\t}\n\n\tpublic static getBackground(metadata: number): ColorId {\n\t\treturn (metadata & MetadataConsts.BACKGROUND_MASK) >>> MetadataConsts.BACKGROUND_OFFSET;\n\t}\n\n\tpublic static getClassNameFromMetadata(metadata: number): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tlet className = 'mtk' + foreground;\n\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tclassName += ' mtki';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tclassName += ' mtkb';\n\t\t}\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\tclassName += ' mtku';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\tclassName += ' mtks';\n\t\t}\n\n\t\treturn className;\n\t}\n\n\tpublic static getInlineStyleFromMetadata(metadata: number, colorMap: string[]): string {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\tlet result = `color: ${colorMap[foreground]};`;\n\t\tif (fontStyle & FontStyle.Italic) {\n\t\t\tresult += 'font-style: italic;';\n\t\t}\n\t\tif (fontStyle & FontStyle.Bold) {\n\t\t\tresult += 'font-weight: bold;';\n\t\t}\n\t\tlet textDecoration = '';\n\t\tif (fontStyle & FontStyle.Underline) {\n\t\t\ttextDecoration += ' underline';\n\t\t}\n\t\tif (fontStyle & FontStyle.Strikethrough) {\n\t\t\ttextDecoration += ' line-through';\n\t\t}\n\t\tif (textDecoration) {\n\t\t\tresult += `text-decoration:${textDecoration};`;\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static getPresentationFromMetadata(metadata: number): ITokenPresentation {\n\t\tconst foreground = this.getForeground(metadata);\n\t\tconst fontStyle = this.getFontStyle(metadata);\n\n\t\treturn {\n\t\t\tforeground: foreground,\n\t\t\titalic: Boolean(fontStyle & FontStyle.Italic),\n\t\t\tbold: Boolean(fontStyle & FontStyle.Bold),\n\t\t\tunderline: Boolean(fontStyle & FontStyle.Underline),\n\t\t\tstrikethrough: Boolean(fontStyle & FontStyle.Strikethrough),\n\t\t};\n\t}\n}\n\n/**\n */\nexport interface ITokenPresentation {\n\tforeground: ColorId;\n\titalic: boolean;\n\tbold: boolean;\n\tunderline: boolean;\n\tstrikethrough: boolean;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { arrayInsert } from 'vs/base/common/arrays';\n\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray<T> {\n\tprivate _store: T[] = [];\n\n\tconstructor(\n\t\tprivate readonly _default: T\n\t) { }\n\n\tpublic get(index: number): T {\n\t\tif (index < this._store.length) {\n\t\t\treturn this._store[index];\n\t\t}\n\t\treturn this._default;\n\t}\n\n\tpublic set(index: number, value: T): void {\n\t\twhile (index >= this._store.length) {\n\t\t\tthis._store[this._store.length] = this._default;\n\t\t}\n\t\tthis._store[index] = value;\n\t}\n\n\tpublic replace(index: number, oldLength: number, newLength: number): void {\n\t\tif (index >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (oldLength === 0) {\n\t\t\tthis.insert(index, newLength);\n\t\t\treturn;\n\t\t} else if (newLength === 0) {\n\t\t\tthis.delete(index, oldLength);\n\t\t\treturn;\n\t\t}\n\n\t\tconst before = this._store.slice(0, index);\n\t\tconst after = this._store.slice(index + oldLength);\n\t\tconst insertArr = arrayFill(newLength, this._default);\n\t\tthis._store = before.concat(insertArr, after);\n\t}\n\n\tpublic delete(deleteIndex: number, deleteCount: number): void {\n\t\tif (deleteCount === 0 || deleteIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tthis._store.splice(deleteIndex, deleteCount);\n\t}\n\n\tpublic insert(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0 || insertIndex >= this._store.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst arr: T[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tarr[i] = this._default;\n\t\t}\n\t\tthis._store = arrayInsert(this._store, insertIndex, arr);\n\t}\n}\n\nfunction arrayFill<T>(length: number, value: T): T[] {\n\tconst arr: T[] = [];\n\tfor (let i = 0; i < length; i++) {\n\t\tarr[i] = value;\n\t}\n\treturn arr;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ILanguageIdCodec } from 'vs/editor/common/languages';\nimport { FontStyle, ColorId, StandardTokenType, MetadataConsts, TokenMetadata, ITokenPresentation } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IViewLineTokens {\n\tequals(other: IViewLineTokens): boolean;\n\tgetCount(): number;\n\tgetForeground(tokenIndex: number): ColorId;\n\tgetEndOffset(tokenIndex: number): number;\n\tgetClassName(tokenIndex: number): string;\n\tgetInlineStyle(tokenIndex: number, colorMap: string[]): string;\n\tgetPresentation(tokenIndex: number): ITokenPresentation;\n\tfindTokenIndexAtOffset(offset: number): number;\n\tgetLineContent(): string;\n\tgetMetadata(tokenIndex: number): number;\n\tgetLanguageId(tokenIndex: number): string;\n}\n\nexport class LineTokens implements IViewLineTokens {\n\t_lineTokensBrand: void = undefined;\n\n\tprivate readonly _tokens: Uint32Array;\n\tprivate readonly _tokensCount: number;\n\tprivate readonly _text: string;\n\tprivate readonly _languageIdCodec: ILanguageIdCodec;\n\n\tpublic static defaultTokenMetadata = (\n\t\t(FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\tpublic static createEmpty(lineContent: string, decoder: ILanguageIdCodec): LineTokens {\n\t\tconst defaultMetadata = LineTokens.defaultTokenMetadata;\n\n\t\tconst tokens = new Uint32Array(2);\n\t\ttokens[0] = lineContent.length;\n\t\ttokens[1] = defaultMetadata;\n\n\t\treturn new LineTokens(tokens, lineContent, decoder);\n\t}\n\n\tconstructor(tokens: Uint32Array, text: string, decoder: ILanguageIdCodec) {\n\t\tthis._tokens = tokens;\n\t\tthis._tokensCount = (this._tokens.length >>> 1);\n\t\tthis._text = text;\n\t\tthis._languageIdCodec = decoder;\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof LineTokens) {\n\t\t\treturn this.slicedEquals(other, 0, this._tokensCount);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic slicedEquals(other: LineTokens, sliceFromTokenIndex: number, sliceTokenCount: number): boolean {\n\t\tif (this._text !== other._text) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._tokensCount !== other._tokensCount) {\n\t\t\treturn false;\n\t\t}\n\t\tconst from = (sliceFromTokenIndex << 1);\n\t\tconst to = from + (sliceTokenCount << 1);\n\t\tfor (let i = from; i < to; i++) {\n\t\t\tif (this._tokens[i] !== other._tokens[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._text;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getStartOffset(tokenIndex: number): number {\n\t\tif (tokenIndex > 0) {\n\t\t\treturn this._tokens[(tokenIndex - 1) << 1];\n\t\t}\n\t\treturn 0;\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn metadata;\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\t\treturn this._languageIdCodec.decodeLanguageId(languageId);\n\t}\n\n\tpublic getStandardTokenType(tokenIndex: number): StandardTokenType {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getTokenType(metadata);\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getForeground(metadata);\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getClassNameFromMetadata(metadata);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\tconst metadata = this._tokens[(tokenIndex << 1) + 1];\n\t\treturn TokenMetadata.getPresentationFromMetadata(metadata);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\treturn this._tokens[tokenIndex << 1];\n\t}\n\n\t/**\n\t * Find the token containing offset `offset`.\n\t * @param offset The search offset\n\t * @return The index of the token containing the offset.\n\t */\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn LineTokens.findIndexInTokensArray(this._tokens, offset);\n\t}\n\n\tpublic inflate(): IViewLineTokens {\n\t\treturn this;\n\t}\n\n\tpublic sliceAndInflate(startOffset: number, endOffset: number, deltaOffset: number): IViewLineTokens {\n\t\treturn new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n\t}\n\n\tpublic static convertToEndOffset(tokens: Uint32Array, lineTextLength: number): void {\n\t\tconst tokenCount = (tokens.length >>> 1);\n\t\tconst lastTokenIndex = tokenCount - 1;\n\t\tfor (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n\t\t}\n\t\ttokens[lastTokenIndex << 1] = lineTextLength;\n\t}\n\n\tpublic static findIndexInTokensArray(tokens: Uint32Array, desiredIndex: number): number {\n\t\tif (tokens.length <= 2) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet low = 0;\n\t\tlet high = (tokens.length >>> 1) - 1;\n\n\t\twhile (low < high) {\n\n\t\t\tconst mid = low + Math.floor((high - low) / 2);\n\t\t\tconst endOffset = tokens[(mid << 1)];\n\n\t\t\tif (endOffset === desiredIndex) {\n\t\t\t\treturn mid + 1;\n\t\t\t} else if (endOffset < desiredIndex) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (endOffset > desiredIndex) {\n\t\t\t\thigh = mid;\n\t\t\t}\n\t\t}\n\n\t\treturn low;\n\t}\n\n\t/**\n\t * @pure\n\t * @param insertTokens Must be sorted by offset.\n\t*/\n\tpublic withInserted(insertTokens: { offset: number; text: string; tokenMetadata: number }[]): LineTokens {\n\t\tif (insertTokens.length === 0) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet nextOriginalTokenIdx = 0;\n\t\tlet nextInsertTokenIdx = 0;\n\t\tlet text = '';\n\t\tconst newTokens = new Array<number>();\n\n\t\tlet originalEndOffset = 0;\n\t\twhile (true) {\n\t\t\tconst nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n\t\t\tconst nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n\n\t\t\tif (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n\t\t\t\t// original token ends before next insert token\n\t\t\t\ttext += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\tnextOriginalTokenIdx++;\n\t\t\t\toriginalEndOffset = nextOriginalTokenEndOffset;\n\n\t\t\t} else if (nextInsertToken) {\n\t\t\t\tif (nextInsertToken.offset > originalEndOffset) {\n\t\t\t\t\t// insert token is in the middle of the next token.\n\t\t\t\t\ttext += this._text.substring(originalEndOffset, nextInsertToken.offset);\n\t\t\t\t\tconst metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n\t\t\t\t\tnewTokens.push(text.length, metadata);\n\t\t\t\t\toriginalEndOffset = nextInsertToken.offset;\n\t\t\t\t}\n\n\t\t\t\ttext += nextInsertToken.text;\n\t\t\t\tnewTokens.push(text.length, nextInsertToken.tokenMetadata);\n\t\t\t\tnextInsertTokenIdx++;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn new LineTokens(new Uint32Array(newTokens), text, this._languageIdCodec);\n\t}\n}\n\nclass SliceLineTokens implements IViewLineTokens {\n\n\tprivate readonly _source: LineTokens;\n\tprivate readonly _startOffset: number;\n\tprivate readonly _endOffset: number;\n\tprivate readonly _deltaOffset: number;\n\n\tprivate readonly _firstTokenIndex: number;\n\tprivate readonly _tokensCount: number;\n\n\tconstructor(source: LineTokens, startOffset: number, endOffset: number, deltaOffset: number) {\n\t\tthis._source = source;\n\t\tthis._startOffset = startOffset;\n\t\tthis._endOffset = endOffset;\n\t\tthis._deltaOffset = deltaOffset;\n\t\tthis._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n\n\t\tthis._tokensCount = 0;\n\t\tfor (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n\t\t\tconst tokenStartOffset = source.getStartOffset(i);\n\t\t\tif (tokenStartOffset >= endOffset) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis._tokensCount++;\n\t\t}\n\t}\n\n\tpublic getMetadata(tokenIndex: number): number {\n\t\treturn this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLanguageId(tokenIndex: number): string {\n\t\treturn this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getLineContent(): string {\n\t\treturn this._source.getLineContent().substring(this._startOffset, this._endOffset);\n\t}\n\n\tpublic equals(other: IViewLineTokens): boolean {\n\t\tif (other instanceof SliceLineTokens) {\n\t\t\treturn (\n\t\t\t\tthis._startOffset === other._startOffset\n\t\t\t\t&& this._endOffset === other._endOffset\n\t\t\t\t&& this._deltaOffset === other._deltaOffset\n\t\t\t\t&& this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount)\n\t\t\t);\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic getCount(): number {\n\t\treturn this._tokensCount;\n\t}\n\n\tpublic getForeground(tokenIndex: number): ColorId {\n\t\treturn this._source.getForeground(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getEndOffset(tokenIndex: number): number {\n\t\tconst tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n\t\treturn Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n\t}\n\n\tpublic getClassName(tokenIndex: number): string {\n\t\treturn this._source.getClassName(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic getInlineStyle(tokenIndex: number, colorMap: string[]): string {\n\t\treturn this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n\t}\n\n\tpublic getPresentation(tokenIndex: number): ITokenPresentation {\n\t\treturn this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n\t}\n\n\tpublic findTokenIndexAtOffset(offset: number): number {\n\t\treturn this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\n\nexport class ContiguousTokensEditing {\n\n\tpublic static deleteBeginning(lineTokens: Uint32Array | ArrayBuffer | null, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\treturn ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n\t}\n\n\tpublic static deleteEnding(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst lineTextLength = tokens[tokens.length - 2];\n\t\treturn ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n\t}\n\n\tpublic static delete(lineTokens: Uint32Array | ArrayBuffer | null, fromChIndex: number, toChIndex: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\t// special case: deleting everything\n\t\tif (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n\t\t\treturn EMPTY_LINE_TOKENS;\n\t\t}\n\n\t\tconst fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n\t\tconst fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n\t\tconst fromTokenEndOffset = tokens[fromTokenIndex << 1];\n\n\t\tif (toChIndex < fromTokenEndOffset) {\n\t\t\t// the delete range is inside a single token\n\t\t\tconst delta = (toChIndex - fromChIndex);\n\t\t\tfor (let i = fromTokenIndex; i < tokensCount; i++) {\n\t\t\t\ttokens[i << 1] -= delta;\n\t\t\t}\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tlet dest: number;\n\t\tlet lastEnd: number;\n\t\tif (fromTokenStartOffset !== fromChIndex) {\n\t\t\ttokens[fromTokenIndex << 1] = fromChIndex;\n\t\t\tdest = ((fromTokenIndex + 1) << 1);\n\t\t\tlastEnd = fromChIndex;\n\t\t} else {\n\t\t\tdest = (fromTokenIndex << 1);\n\t\t\tlastEnd = fromTokenStartOffset;\n\t\t}\n\n\t\tconst delta = (toChIndex - fromChIndex);\n\t\tfor (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\tconst tokenEndOffset = tokens[tokenIndex << 1] - delta;\n\t\t\tif (tokenEndOffset > lastEnd) {\n\t\t\t\ttokens[dest++] = tokenEndOffset;\n\t\t\t\ttokens[dest++] = tokens[(tokenIndex << 1) + 1];\n\t\t\t\tlastEnd = tokenEndOffset;\n\t\t\t}\n\t\t}\n\n\t\tif (dest === tokens.length) {\n\t\t\t// nothing to trim\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tmp = new Uint32Array(dest);\n\t\ttmp.set(tokens.subarray(0, dest), 0);\n\t\treturn tmp.buffer;\n\t}\n\n\tpublic static append(lineTokens: Uint32Array | ArrayBuffer | null, _otherTokens: Uint32Array | ArrayBuffer | null): Uint32Array | ArrayBuffer | null {\n\t\tif (_otherTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\treturn _otherTokens;\n\t\t}\n\t\tif (lineTokens === null) {\n\t\t\treturn lineTokens;\n\t\t}\n\t\tif (_otherTokens === null) {\n\t\t\t// cannot determine combined line length...\n\t\t\treturn null;\n\t\t}\n\t\tconst myTokens = toUint32Array(lineTokens);\n\t\tconst otherTokens = toUint32Array(_otherTokens);\n\t\tconst otherTokensCount = (otherTokens.length >>> 1);\n\n\t\tconst result = new Uint32Array(myTokens.length + otherTokens.length);\n\t\tresult.set(myTokens, 0);\n\t\tlet dest = myTokens.length;\n\t\tconst delta = myTokens[myTokens.length - 2];\n\t\tfor (let i = 0; i < otherTokensCount; i++) {\n\t\t\tresult[dest++] = otherTokens[(i << 1)] + delta;\n\t\t\tresult[dest++] = otherTokens[(i << 1) + 1];\n\t\t}\n\t\treturn result.buffer;\n\t}\n\n\tpublic static insert(lineTokens: Uint32Array | ArrayBuffer | null, chIndex: number, textLength: number): Uint32Array | ArrayBuffer | null {\n\t\tif (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n\t\t\t// nothing to do\n\t\t\treturn lineTokens;\n\t\t}\n\n\t\tconst tokens = toUint32Array(lineTokens);\n\t\tconst tokensCount = (tokens.length >>> 1);\n\n\t\tlet fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n\t\tif (fromTokenIndex > 0) {\n\t\t\tconst fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n\t\t\tif (fromTokenStartOffset === chIndex) {\n\t\t\t\tfromTokenIndex--;\n\t\t\t}\n\t\t}\n\t\tfor (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n\t\t\ttokens[tokenIndex << 1] += textLength;\n\t\t}\n\t\treturn lineTokens;\n\t}\n}\n\nexport function toUint32Array(arr: Uint32Array | ArrayBuffer): Uint32Array {\n\tif (arr instanceof Uint32Array) {\n\t\treturn arr;\n\t} else {\n\t\treturn new Uint32Array(arr);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as arrays from 'vs/base/common/arrays';\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { Position } from 'vs/editor/common/core/position';\nimport { IRange } from 'vs/editor/common/core/range';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { ContiguousTokensEditing } from 'vs/editor/common/tokens/contiguousTokensEditing';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\n\n/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n\tpublic static deserialize(buff: Uint8Array, offset: number, result: ContiguousMultilineTokens[]): number {\n\t\tconst view32 = new Uint32Array(buff.buffer);\n\t\tconst startLineNumber = readUInt32BE(buff, offset); offset += 4;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst tokens: Uint32Array[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst byteCount = readUInt32BE(buff, offset); offset += 4;\n\t\t\ttokens.push(view32.subarray(offset / 4, offset / 4 + byteCount / 4));\n\t\t\toffset += byteCount;\n\t\t}\n\t\tresult.push(new ContiguousMultilineTokens(startLineNumber, tokens));\n\t\treturn offset;\n\t}\n\n\t/**\n\t * The start line number for this block of tokens.\n\t */\n\tprivate _startLineNumber: number;\n\n\t/**\n\t * The tokens are stored in a binary format. There is an element for each line,\n\t * so `tokens[index]` contains all tokens on line `startLineNumber + index`.\n\t *\n\t * On a specific line, each token occupies two array indices. For token i:\n\t *  - at offset 2*i => endOffset\n\t *  - at offset 2*i + 1 => metadata\n\t *\n\t */\n\tprivate _tokens: (Uint32Array | ArrayBuffer | null)[];\n\n\t/**\n\t * (Inclusive) start line number for these tokens.\n\t */\n\tpublic get startLineNumber(): number {\n\t\treturn this._startLineNumber;\n\t}\n\n\t/**\n\t * (Inclusive) end line number for these tokens.\n\t */\n\tpublic get endLineNumber(): number {\n\t\treturn this._startLineNumber + this._tokens.length - 1;\n\t}\n\n\tconstructor(startLineNumber: number, tokens: Uint32Array[]) {\n\t\tthis._startLineNumber = startLineNumber;\n\t\tthis._tokens = tokens;\n\t}\n\n\tgetLineRange(): LineRange {\n\t\treturn new LineRange(this._startLineNumber, this._startLineNumber + this._tokens.length);\n\t}\n\n\t/**\n\t * @see {@link _tokens}\n\t */\n\tpublic getLineTokens(lineNumber: number): Uint32Array | ArrayBuffer | null {\n\t\treturn this._tokens[lineNumber - this._startLineNumber];\n\t}\n\n\tpublic appendLineTokens(lineTokens: Uint32Array): void {\n\t\tthis._tokens.push(lineTokens);\n\t}\n\n\tpublic serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the start line number\n\t\tresult += 4; // 4 bytes for the line count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\tresult += 4; // 4 bytes for the byte count\n\t\t\tresult += lineTokens.byteLength;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic serialize(destination: Uint8Array, offset: number): number {\n\t\twriteUInt32BE(destination, this._startLineNumber, offset); offset += 4;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tconst lineTokens = this._tokens[i];\n\t\t\tif (!(lineTokens instanceof Uint32Array)) {\n\t\t\t\tthrow new Error(`Not supported!`);\n\t\t\t}\n\t\t\twriteUInt32BE(destination, lineTokens.byteLength, offset); offset += 4;\n\t\t\tdestination.set(new Uint8Array(lineTokens.buffer), offset); offset += lineTokens.byteLength;\n\t\t}\n\t\treturn offset;\n\t}\n\n\tpublic applyEdit(range: IRange, text: string): void {\n\t\tconst [eolCount, firstLineLength] = countEOL(text);\n\t\tthis._acceptDeleteRange(range);\n\t\tthis._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n\t}\n\n\tprivate _acceptDeleteRange(range: IRange): void {\n\t\tif (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n\t\t\t// Nothing to delete\n\t\t\treturn;\n\t\t}\n\n\t\tconst firstLineIndex = range.startLineNumber - this._startLineNumber;\n\t\tconst lastLineIndex = range.endLineNumber - this._startLineNumber;\n\n\t\tif (lastLineIndex < 0) {\n\t\t\t// this deletion occurs entirely before this block, so we only need to adjust line numbers\n\t\t\tconst deletedLinesCount = lastLineIndex - firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedLinesCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= this._tokens.length) {\n\t\t\t// this deletion occurs entirely after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex < 0 && lastLineIndex >= this._tokens.length) {\n\t\t\t// this deletion completely encompasses this block\n\t\t\tthis._startLineNumber = 0;\n\t\t\tthis._tokens = [];\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex === lastLineIndex) {\n\t\t\t// a delete on a single line\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.delete(this._tokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n\t\t\treturn;\n\t\t}\n\n\t\tif (firstLineIndex >= 0) {\n\t\t\t// The first line survives\n\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[firstLineIndex], range.startColumn - 1);\n\n\t\t\tif (lastLineIndex < this._tokens.length) {\n\t\t\t\t// The last line survives\n\t\t\t\tconst lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], lastLineTokens);\n\n\t\t\t\t// Delete middle lines\n\t\t\t\tthis._tokens.splice(firstLineIndex + 1, lastLineIndex - firstLineIndex);\n\t\t\t} else {\n\t\t\t\t// The last line does not survive\n\n\t\t\t\t// Take remaining text on last line and append it to remaining text on first line\n\t\t\t\tthis._tokens[firstLineIndex] = ContiguousTokensEditing.append(this._tokens[firstLineIndex], null);\n\n\t\t\t\t// Delete lines\n\t\t\t\tthis._tokens = this._tokens.slice(0, firstLineIndex + 1);\n\t\t\t}\n\t\t} else {\n\t\t\t// The first line does not survive\n\n\t\t\tconst deletedBefore = -firstLineIndex;\n\t\t\tthis._startLineNumber -= deletedBefore;\n\n\t\t\t// Remove beginning from last line\n\t\t\tthis._tokens[lastLineIndex] = ContiguousTokensEditing.deleteBeginning(this._tokens[lastLineIndex], range.endColumn - 1);\n\n\t\t\t// Delete lines\n\t\t\tthis._tokens = this._tokens.slice(lastLineIndex);\n\t\t}\n\t}\n\n\tprivate _acceptInsertText(position: Position, eolCount: number, firstLineLength: number): void {\n\n\t\tif (eolCount === 0 && firstLineLength === 0) {\n\t\t\t// Nothing to insert\n\t\t\treturn;\n\t\t}\n\n\t\tconst lineIndex = position.lineNumber - this._startLineNumber;\n\n\t\tif (lineIndex < 0) {\n\t\t\t// this insertion occurs before this block, so we only need to adjust line numbers\n\t\t\tthis._startLineNumber += eolCount;\n\t\t\treturn;\n\t\t}\n\n\t\tif (lineIndex >= this._tokens.length) {\n\t\t\t// this insertion occurs after this block, so there is nothing to do\n\t\t\treturn;\n\t\t}\n\n\t\tif (eolCount === 0) {\n\t\t\t// Inserting text on one line\n\t\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._tokens[lineIndex], position.column - 1);\n\t\tthis._tokens[lineIndex] = ContiguousTokensEditing.insert(this._tokens[lineIndex], position.column - 1, firstLineLength);\n\n\t\tthis._insertLines(position.lineNumber, eolCount);\n\t}\n\n\tprivate _insertLines(insertIndex: number, insertCount: number): void {\n\t\tif (insertCount === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst lineTokens: (Uint32Array | ArrayBuffer | null)[] = [];\n\t\tfor (let i = 0; i < insertCount; i++) {\n\t\t\tlineTokens[i] = null;\n\t\t}\n\t\tthis._tokens = arrays.arrayInsert(this._tokens, insertIndex, lineTokens);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { readUInt32BE, writeUInt32BE } from 'vs/base/common/buffer';\nimport { ContiguousMultilineTokens } from 'vs/editor/common/tokens/contiguousMultilineTokens';\n\nexport class ContiguousMultilineTokensBuilder {\n\n\tpublic static deserialize(buff: Uint8Array): ContiguousMultilineTokens[] {\n\t\tlet offset = 0;\n\t\tconst count = readUInt32BE(buff, offset); offset += 4;\n\t\tconst result: ContiguousMultilineTokens[] = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\toffset = ContiguousMultilineTokens.deserialize(buff, offset, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate readonly _tokens: ContiguousMultilineTokens[];\n\n\tconstructor() {\n\t\tthis._tokens = [];\n\t}\n\n\tpublic add(lineNumber: number, lineTokens: Uint32Array): void {\n\t\tif (this._tokens.length > 0) {\n\t\t\tconst last = this._tokens[this._tokens.length - 1];\n\t\t\tif (last.endLineNumber + 1 === lineNumber) {\n\t\t\t\t// append\n\t\t\t\tlast.appendLineTokens(lineTokens);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n\t}\n\n\tpublic finalize(): ContiguousMultilineTokens[] {\n\t\treturn this._tokens;\n\t}\n\n\tpublic serialize(): Uint8Array {\n\t\tconst size = this._serializeSize();\n\t\tconst result = new Uint8Array(size);\n\t\tthis._serialize(result);\n\t\treturn result;\n\t}\n\n\tprivate _serializeSize(): number {\n\t\tlet result = 0;\n\t\tresult += 4; // 4 bytes for the count\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\tresult += this._tokens[i].serializeSize();\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate _serialize(destination: Uint8Array): void {\n\t\tlet offset = 0;\n\t\twriteUInt32BE(destination, this._tokens.length, offset); offset += 4;\n\t\tfor (let i = 0; i < this._tokens.length; i++) {\n\t\t\toffset = this._tokens[i].serialize(destination, offset);\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Token, TokenizationResult, EncodedTokenizationResult, IState } from 'vs/editor/common/languages';\nimport { LanguageId, FontStyle, ColorId, StandardTokenType, MetadataConsts } from 'vs/editor/common/encodedTokenAttributes';\n\nexport const NullState: IState = new class implements IState {\n\tpublic clone(): IState {\n\t\treturn this;\n\t}\n\tpublic equals(other: IState): boolean {\n\t\treturn (this === other);\n\t}\n};\n\nexport function nullTokenize(languageId: string, state: IState): TokenizationResult {\n\treturn new TokenizationResult([new Token(0, '', languageId)], state);\n}\n\nexport function nullTokenizeEncoded(languageId: LanguageId, state: IState | null): EncodedTokenizationResult {\n\tconst tokens = new Uint32Array(2);\n\ttokens[0] = 0;\n\ttokens[1] = (\n\t\t(languageId << MetadataConsts.LANGUAGEID_OFFSET)\n\t\t| (StandardTokenType.Other << MetadataConsts.TOKEN_TYPE_OFFSET)\n\t\t| (FontStyle.None << MetadataConsts.FONT_STYLE_OFFSET)\n\t\t| (ColorId.DefaultForeground << MetadataConsts.FOREGROUND_OFFSET)\n\t\t| (ColorId.DefaultBackground << MetadataConsts.BACKGROUND_OFFSET)\n\t) >>> 0;\n\n\treturn new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IdleDeadline, runWhenGlobalIdle } from 'vs/base/common/async';\nimport { BugIndicatingError, onUnexpectedError } from 'vs/base/common/errors';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { countEOL } from 'vs/editor/common/core/eolCounter';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { OffsetRange } from 'vs/editor/common/core/offsetRange';\nimport { Position } from 'vs/editor/common/core/position';\nimport { StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, ILanguageIdCodec, IState, ITokenizationSupport } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { FixedArray } from 'vs/editor/common/model/fixedArray';\nimport { IModelContentChange } from 'vs/editor/common/textModelEvents';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\n\nconst enum Constants {\n\tCHEAP_TOKENIZATION_LENGTH_LIMIT = 2048\n}\n\nexport class TokenizerWithStateStore<TState extends IState = IState> {\n\tprivate readonly initialState = this.tokenizationSupport.getInitialState() as TState;\n\n\tpublic readonly store: TrackingTokenizationStateStore<TState>;\n\n\tconstructor(\n\t\tlineCount: number,\n\t\tpublic readonly tokenizationSupport: ITokenizationSupport\n\t) {\n\t\tthis.store = new TrackingTokenizationStateStore<TState>(lineCount);\n\t}\n\n\tpublic getStartState(lineNumber: number): TState | null {\n\t\treturn this.store.getStartState(lineNumber, this.initialState);\n\t}\n\n\tpublic getFirstInvalidLine(): { lineNumber: number; startState: TState } | null {\n\t\treturn this.store.getFirstInvalidLine(this.initialState);\n\t}\n}\n\nexport class TokenizerWithStateStoreAndTextModel<TState extends IState = IState> extends TokenizerWithStateStore<TState> {\n\tconstructor(\n\t\tlineCount: number,\n\t\ttokenizationSupport: ITokenizationSupport,\n\t\tpublic readonly _textModel: ITextModel,\n\t\tpublic readonly _languageIdCodec: ILanguageIdCodec\n\t) {\n\t\tsuper(lineCount, tokenizationSupport);\n\t}\n\n\tpublic updateTokensUntilLine(builder: ContiguousMultilineTokensBuilder, lineNumber: number): void {\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\twhile (true) {\n\t\t\tconst lineToTokenize = this.getFirstInvalidLine();\n\t\t\tif (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n\t\t\tbuilder.add(lineToTokenize.lineNumber, r.tokens);\n\t\t\tthis.store.setEndState(lineToTokenize.lineNumber, r.endState as TState);\n\t\t}\n\t}\n\n\t/** assumes state is up to date */\n\tpublic getTokenTypeIfInsertingCharacter(position: Position, character: string): StandardTokenType {\n\t\t// TODO@hediet: use tokenizeLineWithEdit\n\t\tconst lineStartState = this.getStartState(position.lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tconst lineContent = this._textModel.getLineContent(position.lineNumber);\n\n\t\t// Create the text as if `character` was inserted\n\t\tconst text = (\n\t\t\tlineContent.substring(0, position.column - 1)\n\t\t\t+ character\n\t\t\t+ lineContent.substring(position.column - 1)\n\t\t);\n\n\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n\t\tconst lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n\t\tif (lineTokens.getCount() === 0) {\n\t\t\treturn StandardTokenType.Other;\n\t\t}\n\n\t\tconst tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n\t\treturn lineTokens.getStandardTokenType(tokenIndex);\n\t}\n\n\t/** assumes state is up to date */\n\tpublic tokenizeLineWithEdit(position: Position, length: number, newText: string): LineTokens | null {\n\t\tconst lineNumber = position.lineNumber;\n\t\tconst column = position.column;\n\n\t\tconst lineStartState = this.getStartState(lineNumber);\n\t\tif (!lineStartState) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst curLineContent = this._textModel.getLineContent(lineNumber);\n\t\tconst newLineContent = curLineContent.substring(0, column - 1)\n\t\t\t+ newText + curLineContent.substring(column - 1 + length);\n\n\t\tconst languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n\t\tconst result = safeTokenize(\n\t\t\tthis._languageIdCodec,\n\t\t\tlanguageId,\n\t\t\tthis.tokenizationSupport,\n\t\t\tnewLineContent,\n\t\t\ttrue,\n\t\t\tlineStartState\n\t\t);\n\n\t\tconst lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n\t\treturn lineTokens;\n\t}\n\n\tpublic isCheapToTokenize(lineNumber: number): boolean {\n\t\tconst firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n\t\tif (lineNumber < firstInvalidLineNumber) {\n\t\t\treturn true;\n\t\t}\n\t\tif (lineNumber === firstInvalidLineNumber\n\t\t\t&& this._textModel.getLineLength(lineNumber) < Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * The result is not cached.\n\t */\n\tpublic tokenizeHeuristically(builder: ContiguousMultilineTokensBuilder, startLineNumber: number, endLineNumber: number): { heuristicTokens: boolean } {\n\t\tif (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// nothing to do\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tif (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n\t\t\t// tokenization has reached the viewport start...\n\t\t\tthis.updateTokensUntilLine(builder, endLineNumber);\n\t\t\treturn { heuristicTokens: false };\n\t\t}\n\n\t\tlet state = this.guessStartState(startLineNumber);\n\t\tconst languageId = this._textModel.getLanguageId();\n\n\t\tfor (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n\t\t\tconst text = this._textModel.getLineContent(lineNumber);\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n\t\t\tbuilder.add(lineNumber, r.tokens);\n\t\t\tstate = r.endState;\n\t\t}\n\n\t\treturn { heuristicTokens: true };\n\t}\n\n\tprivate guessStartState(lineNumber: number): IState {\n\t\tlet nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n\t\tconst likelyRelevantLines: string[] = [];\n\t\tlet initialState: IState | null = null;\n\t\tfor (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n\t\t\tconst newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n\t\t\t// Ignore lines full of whitespace\n\t\t\tif (newNonWhitespaceIndex === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (newNonWhitespaceIndex < nonWhitespaceColumn) {\n\t\t\t\tlikelyRelevantLines.push(this._textModel.getLineContent(i));\n\t\t\t\tnonWhitespaceColumn = newNonWhitespaceIndex;\n\t\t\t\tinitialState = this.getStartState(i);\n\t\t\t\tif (initialState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!initialState) {\n\t\t\tinitialState = this.tokenizationSupport.getInitialState();\n\t\t}\n\t\tlikelyRelevantLines.reverse();\n\n\t\tconst languageId = this._textModel.getLanguageId();\n\t\tlet state = initialState;\n\t\tfor (const line of likelyRelevantLines) {\n\t\t\tconst r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n\t\t\tstate = r.endState;\n\t\t}\n\t\treturn state;\n\t}\n}\n\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore<TState extends IState> {\n\tprivate readonly _tokenizationStateStore = new TokenizationStateStore<TState>();\n\tprivate readonly _invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n\n\tconstructor(private lineCount: number) {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n\t}\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._tokenizationStateStore.getEndState(lineNumber);\n\t}\n\n\t/**\n\t * @returns if the end state has changed.\n\t */\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tif (!state) {\n\t\t\tthrow new BugIndicatingError('Cannot set null/undefined state');\n\t\t}\n\n\t\tthis._invalidEndStatesLineNumbers.delete(lineNumber);\n\t\tconst r = this._tokenizationStateStore.setEndState(lineNumber, state);\n\t\tif (r && lineNumber < this.lineCount) {\n\t\t\t// because the state changed, we cannot trust the next state anymore and have to invalidate it.\n\t\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n\t\t}\n\n\t\treturn r;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tthis.lineCount += newLineCount - range.length;\n\t\tthis._tokenizationStateStore.acceptChange(range, newLineCount);\n\t\tthis._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n\n\tpublic invalidateEndStateRange(range: LineRange): void {\n\t\tthis._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n\t}\n\n\tpublic getFirstInvalidEndStateLineNumber(): number | null { return this._invalidEndStatesLineNumbers.min; }\n\n\tpublic getFirstInvalidEndStateLineNumberOrMax(): number {\n\t\treturn this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n\t}\n\n\tpublic allStatesValid(): boolean { return this._invalidEndStatesLineNumbers.min === null; }\n\n\tpublic getStartState(lineNumber: number, initialState: TState): TState | null {\n\t\tif (lineNumber === 1) { return initialState; }\n\t\treturn this.getEndState(lineNumber - 1);\n\t}\n\n\tpublic getFirstInvalidLine(initialState: TState): { lineNumber: number; startState: TState } | null {\n\t\tconst lineNumber = this.getFirstInvalidEndStateLineNumber();\n\t\tif (lineNumber === null) {\n\t\t\treturn null;\n\t\t}\n\t\tconst startState = this.getStartState(lineNumber, initialState);\n\t\tif (!startState) {\n\t\t\tthrow new BugIndicatingError('Start state must be defined');\n\t\t}\n\n\t\treturn { lineNumber, startState };\n\t}\n}\n\nexport class TokenizationStateStore<TState extends IState> {\n\tprivate readonly _lineEndStates = new FixedArray<TState | null>(null);\n\n\tpublic getEndState(lineNumber: number): TState | null {\n\t\treturn this._lineEndStates.get(lineNumber);\n\t}\n\n\tpublic setEndState(lineNumber: number, state: TState): boolean {\n\t\tconst oldState = this._lineEndStates.get(lineNumber);\n\t\tif (oldState && oldState.equals(state)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis._lineEndStates.set(lineNumber, state);\n\t\treturn true;\n\t}\n\n\tpublic acceptChange(range: LineRange, newLineCount: number): void {\n\t\tlet length = range.length;\n\t\tif (newLineCount > 0 && length > 0) {\n\t\t\t// Keep the last state, even though it is unrelated.\n\t\t\t// But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n\t\t\tlength--;\n\t\t\tnewLineCount--;\n\t\t}\n\n\t\tthis._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n\t}\n\n\tpublic acceptChanges(changes: IModelContentChange[]) {\n\t\tfor (const c of changes) {\n\t\t\tconst [eolCount] = countEOL(c.text);\n\t\t\tthis.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n\t\t}\n\t}\n}\n\ninterface RangePriorityQueue {\n\tget min(): number | null;\n\tremoveMin(): number | null;\n\n\taddRange(range: OffsetRange): void;\n\n\taddRangeAndResize(range: OffsetRange, newLength: number): void;\n}\n\nexport class RangePriorityQueueImpl implements RangePriorityQueue {\n\tprivate readonly _ranges: OffsetRange[] = [];\n\n\tpublic getRanges(): OffsetRange[] {\n\t\treturn this._ranges;\n\t}\n\n\tpublic get min(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._ranges[0].start;\n\t}\n\n\tpublic removeMin(): number | null {\n\t\tif (this._ranges.length === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst range = this._ranges[0];\n\t\tif (range.start + 1 === range.endExclusive) {\n\t\t\tthis._ranges.shift();\n\t\t} else {\n\t\t\tthis._ranges[0] = new OffsetRange(range.start + 1, range.endExclusive);\n\t\t}\n\t\treturn range.start;\n\t}\n\n\tpublic delete(value: number): void {\n\t\tconst idx = this._ranges.findIndex(r => r.contains(value));\n\t\tif (idx !== -1) {\n\t\t\tconst range = this._ranges[idx];\n\t\t\tif (range.start === value) {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges.splice(idx, 1);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (range.endExclusive === value + 1) {\n\t\t\t\t\tthis._ranges[idx] = new OffsetRange(range.start, value);\n\t\t\t\t} else {\n\t\t\t\t\tthis._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic addRange(range: OffsetRange): void {\n\t\tOffsetRange.addRange(range, this._ranges);\n\t}\n\n\tpublic addRangeAndResize(range: OffsetRange, newLength: number): void {\n\t\tlet idxFirstMightBeIntersecting = 0;\n\t\twhile (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n\t\t\tidxFirstMightBeIntersecting++;\n\t\t}\n\t\tlet idxFirstIsAfter = idxFirstMightBeIntersecting;\n\t\twhile (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n\t\t\tidxFirstIsAfter++;\n\t\t}\n\t\tconst delta = newLength - range.length;\n\n\t\tfor (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n\t\t\tthis._ranges[i] = this._ranges[i].delta(delta);\n\t\t}\n\n\t\tif (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n\t\t\tconst newRange = new OffsetRange(range.start, range.start + newLength);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n\t\t\t}\n\t\t} else {\n\t\t\tconst start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n\t\t\tconst endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n\n\t\t\tconst newRange = new OffsetRange(start, endEx + delta);\n\t\t\tif (!newRange.isEmpty) {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n\t\t\t} else {\n\t\t\t\tthis._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n\t\t\t}\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn this._ranges.map(r => r.toString()).join(' + ');\n\t}\n}\n\n\nfunction safeTokenize(languageIdCodec: ILanguageIdCodec, languageId: string, tokenizationSupport: ITokenizationSupport | null, text: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\tlet r: EncodedTokenizationResult | null = null;\n\n\tif (tokenizationSupport) {\n\t\ttry {\n\t\t\tr = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n\t\t} catch (e) {\n\t\t\tonUnexpectedError(e);\n\t\t}\n\t}\n\n\tif (!r) {\n\t\tr = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n\t}\n\n\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\treturn r;\n}\n\nexport class DefaultBackgroundTokenizer implements IBackgroundTokenizer {\n\tprivate _isDisposed = false;\n\n\tconstructor(\n\t\tprivate readonly _tokenizerWithStateStore: TokenizerWithStateStoreAndTextModel,\n\t\tprivate readonly _backgroundTokenStore: IBackgroundTokenizationStore,\n\t) {\n\t}\n\n\tpublic dispose(): void {\n\t\tthis._isDisposed = true;\n\t}\n\n\tpublic handleChanges(): void {\n\t\tthis._beginBackgroundTokenization();\n\t}\n\n\tprivate _isScheduled = false;\n\tprivate _beginBackgroundTokenization(): void {\n\t\tif (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isScheduled = true;\n\t\trunWhenGlobalIdle((deadline) => {\n\t\t\tthis._isScheduled = false;\n\n\t\t\tthis._backgroundTokenizeWithDeadline(deadline);\n\t\t});\n\t}\n\n\t/**\n\t * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n\t */\n\tprivate _backgroundTokenizeWithDeadline(deadline: IdleDeadline): void {\n\t\t// Read the time remaining from the `deadline` immediately because it is unclear\n\t\t// if the `deadline` object will be valid after execution leaves this function.\n\t\tconst endTime = Date.now() + deadline.timeRemaining();\n\n\t\tconst execute = () => {\n\t\t\tif (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n\t\t\t\t// disposed in the meantime or detached or finished\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._backgroundTokenizeForAtLeast1ms();\n\n\t\t\tif (Date.now() < endTime) {\n\t\t\t\t// There is still time before reaching the deadline, so yield to the browser and then\n\t\t\t\t// continue execution\n\t\t\t\tsetTimeout0(execute);\n\t\t\t} else {\n\t\t\t\t// The deadline has been reached, so schedule a new idle callback if necessary\n\t\t\t\tthis._beginBackgroundTokenization();\n\t\t\t}\n\t\t};\n\t\texecute();\n\t}\n\n\t/**\n\t * Tokenize for at least 1ms.\n\t */\n\tprivate _backgroundTokenizeForAtLeast1ms(): void {\n\t\tconst lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n\t\tconst builder = new ContiguousMultilineTokensBuilder();\n\t\tconst sw = StopWatch.create(false);\n\n\t\tdo {\n\t\t\tif (sw.elapsed() > 1) {\n\t\t\t\t// the comparison is intentionally > 1 and not >= 1 to ensure that\n\t\t\t\t// a full millisecond has elapsed, given how microseconds are rounded\n\t\t\t\t// to milliseconds\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n\n\t\t\tif (tokenizedLineNumber >= lineCount) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (this._hasLinesToTokenize());\n\n\t\tthis._backgroundTokenStore.setTokens(builder.finalize());\n\t\tthis.checkFinished();\n\t}\n\n\tprivate _hasLinesToTokenize(): boolean {\n\t\tif (!this._tokenizerWithStateStore) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !this._tokenizerWithStateStore.store.allStatesValid();\n\t}\n\n\tprivate _tokenizeOneInvalidLine(builder: ContiguousMultilineTokensBuilder): number {\n\t\tconst firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n\t\tif (!firstInvalidLine) {\n\t\t\treturn this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n\t\t}\n\t\tthis._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n\t\treturn firstInvalidLine.lineNumber;\n\t}\n\n\tpublic checkFinished(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._tokenizerWithStateStore.store.allStatesValid()) {\n\t\t\tthis._backgroundTokenStore.backgroundTokenizationFinished();\n\t\t}\n\t}\n\n\tpublic requestTokens(startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { StopWatch } from 'vs/base/common/stopwatch';\nimport { LanguageId, TokenMetadata } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { ITextModel } from 'vs/editor/common/model';\nimport type { IGrammar, StateStack } from 'vscode-textmate';\n\nexport class TextMateTokenizationSupport extends Disposable implements ITokenizationSupport {\n\tprivate readonly _seenLanguages: boolean[] = [];\n\tprivate readonly _onDidEncounterLanguage: Emitter<LanguageId> = this._register(new Emitter<LanguageId>());\n\tpublic readonly onDidEncounterLanguage: Event<LanguageId> = this._onDidEncounterLanguage.event;\n\n\tconstructor(\n\t\tprivate readonly _grammar: IGrammar,\n\t\tprivate readonly _initialState: StateStack,\n\t\tprivate readonly _containsEmbeddedLanguages: boolean,\n\t\tprivate readonly _createBackgroundTokenizer: ((textModel: ITextModel, tokenStore: IBackgroundTokenizationStore) => IBackgroundTokenizer | undefined) | undefined,\n\t\tprivate readonly _backgroundTokenizerShouldOnlyVerifyTokens: () => boolean,\n\t\tprivate readonly _reportTokenizationTime: (timeMs: number, lineLength: number, isRandomSample: boolean) => void,\n\t\tprivate readonly _reportSlowTokenization: boolean,\n\t) {\n\t\tsuper();\n\t}\n\n\tpublic get backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._backgroundTokenizerShouldOnlyVerifyTokens();\n\t}\n\n\tpublic getInitialState(): IState {\n\t\treturn this._initialState;\n\t}\n\n\tpublic tokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\tpublic createBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._createBackgroundTokenizer) {\n\t\t\treturn this._createBackgroundTokenizer(textModel, store);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic tokenizeEncoded(line: string, hasEOL: boolean, state: StateStack): EncodedTokenizationResult {\n\t\tconst isRandomSample = Math.random() * 10_000 < 1;\n\t\tconst shouldMeasure = this._reportSlowTokenization || isRandomSample;\n\t\tconst sw = shouldMeasure ? new StopWatch(true) : undefined;\n\t\tconst textMateResult = this._grammar.tokenizeLine2(line, state, 500);\n\t\tif (shouldMeasure) {\n\t\t\tconst timeMS = sw!.elapsed();\n\t\t\tif (isRandomSample || timeMS > 32) {\n\t\t\t\tthis._reportTokenizationTime(timeMS, line.length, isRandomSample);\n\t\t\t}\n\t\t}\n\n\t\tif (textMateResult.stoppedEarly) {\n\t\t\tconsole.warn(`Time limit reached when tokenizing line: ${line.substring(0, 100)}`);\n\t\t\t// return the state at the beginning of the line\n\t\t\treturn new EncodedTokenizationResult(textMateResult.tokens, state);\n\t\t}\n\n\t\tif (this._containsEmbeddedLanguages) {\n\t\t\tconst seenLanguages = this._seenLanguages;\n\t\t\tconst tokens = textMateResult.tokens;\n\n\t\t\t// Must check if any of the embedded languages was hit\n\t\t\tfor (let i = 0, len = (tokens.length >>> 1); i < len; i++) {\n\t\t\t\tconst metadata = tokens[(i << 1) + 1];\n\t\t\t\tconst languageId = TokenMetadata.getLanguageId(metadata);\n\n\t\t\t\tif (!seenLanguages[languageId]) {\n\t\t\t\t\tseenLanguages[languageId] = true;\n\t\t\t\t\tthis._onDidEncounterLanguage.fire(languageId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet endState: StateStack;\n\t\t// try to save an object if possible\n\t\tif (state.equals(textMateResult.ruleStack)) {\n\t\t\tendState = state;\n\t\t} else {\n\t\t\tendState = textMateResult.ruleStack;\n\t\t}\n\n\t\treturn new EncodedTokenizationResult(textMateResult.tokens, endState);\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { EncodedTokenizationResult, IBackgroundTokenizationStore, IBackgroundTokenizer, IState, ITokenizationSupport, TokenizationResult } from 'vs/editor/common/languages';\nimport { nullTokenizeEncoded } from 'vs/editor/common/languages/nullTokenize';\nimport { ITextModel } from 'vs/editor/common/model';\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { IObservable, keepObserved } from 'vs/base/common/observable';\n\nexport class TokenizationSupportWithLineLimit extends Disposable implements ITokenizationSupport {\n\tget backgroundTokenizerShouldOnlyVerifyTokens(): boolean | undefined {\n\t\treturn this._actual.backgroundTokenizerShouldOnlyVerifyTokens;\n\t}\n\n\tconstructor(\n\t\tprivate readonly _encodedLanguageId: LanguageId,\n\t\tprivate readonly _actual: ITokenizationSupport,\n\t\tprivate readonly _maxTokenizationLineLength: IObservable<number>,\n\t) {\n\t\tsuper();\n\n\t\tthis._register(keepObserved(this._maxTokenizationLineLength));\n\t}\n\n\tgetInitialState(): IState {\n\t\treturn this._actual.getInitialState();\n\t}\n\n\ttokenize(line: string, hasEOL: boolean, state: IState): TokenizationResult {\n\t\tthrow new Error('Not supported!');\n\t}\n\n\ttokenizeEncoded(line: string, hasEOL: boolean, state: IState): EncodedTokenizationResult {\n\t\t// Do not attempt to tokenize if a line is too long\n\t\tif (line.length >= this._maxTokenizationLineLength.get()) {\n\t\t\treturn nullTokenizeEncoded(this._encodedLanguageId, state);\n\t\t}\n\n\t\treturn this._actual.tokenizeEncoded(line, hasEOL, state);\n\t}\n\n\tcreateBackgroundTokenizer(textModel: ITextModel, store: IBackgroundTokenizationStore): IBackgroundTokenizer | undefined {\n\t\tif (this._actual.createBackgroundTokenizer) {\n\t\t\treturn this._actual.createBackgroundTokenizer(textModel, store);\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { importAMDNodeModule } from 'vs/amdX';\nimport { RunOnceScheduler } from 'vs/base/common/async';\nimport { observableValue } from 'vs/base/common/observable';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { URI } from 'vs/base/common/uri';\nimport { LineRange } from 'vs/editor/common/core/lineRange';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent, MirrorTextModel } from 'vs/editor/common/model/mirrorTextModel';\nimport { TokenizerWithStateStore } from 'vs/editor/common/model/textModelTokens';\nimport { ContiguousMultilineTokensBuilder } from 'vs/editor/common/tokens/contiguousMultilineTokensBuilder';\nimport { LineTokens } from 'vs/editor/common/tokens/lineTokens';\nimport { TextMateTokenizationSupport } from 'vs/workbench/services/textMate/browser/tokenizationSupport/textMateTokenizationSupport';\nimport { TokenizationSupportWithLineLimit } from 'vs/workbench/services/textMate/browser/tokenizationSupport/tokenizationSupportWithLineLimit';\nimport type { StackDiff, StateStack, diffStateStacksRefEq } from 'vscode-textmate';\nimport { ICreateGrammarResult } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { StateDeltas } from 'vs/workbench/services/textMate/browser/backgroundTokenization/worker/textMateTokenizationWorker.worker';\n\nexport interface TextMateModelTokenizerHost {\n\tgetOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null>;\n\tsetTokensAndStates(versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void;\n\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void;\n}\n\nexport class TextMateWorkerTokenizer extends MirrorTextModel {\n\tprivate _tokenizerWithStateStore: TokenizerWithStateStore<StateStack> | null = null;\n\tprivate _isDisposed: boolean = false;\n\tprivate readonly _maxTokenizationLineLength = observableValue(this, -1);\n\tprivate _diffStateStacksRefEqFn?: typeof diffStateStacksRefEq;\n\tprivate readonly _tokenizeDebouncer = new RunOnceScheduler(() => this._tokenize(), 10);\n\n\tconstructor(\n\t\turi: URI,\n\t\tlines: string[],\n\t\teol: string,\n\t\tversionId: number,\n\t\tprivate readonly _host: TextMateModelTokenizerHost,\n\t\tprivate _languageId: string,\n\t\tprivate _encodedLanguageId: LanguageId,\n\t\tmaxTokenizationLineLength: number,\n\t) {\n\t\tsuper(uri, lines, eol, versionId);\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t\tthis._resetTokenization();\n\t}\n\n\tpublic override dispose(): void {\n\t\tthis._isDisposed = true;\n\t\tsuper.dispose();\n\t}\n\n\tpublic onLanguageId(languageId: string, encodedLanguageId: LanguageId): void {\n\t\tthis._languageId = languageId;\n\t\tthis._encodedLanguageId = encodedLanguageId;\n\t\tthis._resetTokenization();\n\t}\n\n\toverride onEvents(e: IModelChangedEvent): void {\n\t\tsuper.onEvents(e);\n\n\t\tthis._tokenizerWithStateStore?.store.acceptChanges(e.changes);\n\t\tthis._tokenizeDebouncer.schedule();\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(maxTokenizationLineLength: number): void {\n\t\tthis._maxTokenizationLineLength.set(maxTokenizationLineLength, undefined);\n\t}\n\n\tpublic retokenize(startLineNumber: number, endLineNumberExclusive: number) {\n\t\tif (this._tokenizerWithStateStore) {\n\t\t\tthis._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n\t\t\tthis._tokenizeDebouncer.schedule();\n\t\t}\n\t}\n\n\tprivate async _resetTokenization() {\n\t\tthis._tokenizerWithStateStore = null;\n\n\t\tconst languageId = this._languageId;\n\t\tconst encodedLanguageId = this._encodedLanguageId;\n\n\t\tconst r = await this._host.getOrCreateGrammar(languageId, encodedLanguageId);\n\n\t\tif (this._isDisposed || languageId !== this._languageId || encodedLanguageId !== this._encodedLanguageId || !r) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (r.grammar) {\n\t\t\tconst tokenizationSupport = new TokenizationSupportWithLineLimit(\n\t\t\t\tthis._encodedLanguageId,\n\t\t\t\tnew TextMateTokenizationSupport(r.grammar, r.initialState, false, undefined, () => false,\n\t\t\t\t\t(timeMs, lineLength, isRandomSample) => {\n\t\t\t\t\t\tthis._host.reportTokenizationTime(timeMs, languageId, r.sourceExtensionId, lineLength, isRandomSample);\n\t\t\t\t\t},\n\t\t\t\t\tfalse\n\t\t\t\t),\n\t\t\t\tthis._maxTokenizationLineLength\n\t\t\t);\n\t\t\tthis._tokenizerWithStateStore = new TokenizerWithStateStore(this._lines.length, tokenizationSupport);\n\t\t} else {\n\t\t\tthis._tokenizerWithStateStore = null;\n\t\t}\n\t\tthis._tokenize();\n\t}\n\n\tprivate async _tokenize(): Promise<void> {\n\t\tif (this._isDisposed || !this._tokenizerWithStateStore) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this._diffStateStacksRefEqFn) {\n\t\t\tconst { diffStateStacksRefEq } = await importAMDNodeModule<typeof import('vscode-textmate')>('vscode-textmate', 'release/main.js');\n\t\t\tthis._diffStateStacksRefEqFn = diffStateStacksRefEq;\n\t\t}\n\n\t\tconst startTime = new Date().getTime();\n\n\t\twhile (true) {\n\t\t\tlet tokenizedLines = 0;\n\t\t\tconst tokenBuilder = new ContiguousMultilineTokensBuilder();\n\t\t\tconst stateDeltaBuilder = new StateDeltaBuilder();\n\n\t\t\twhile (true) {\n\t\t\t\tconst lineToTokenize = this._tokenizerWithStateStore.getFirstInvalidLine();\n\t\t\t\tif (lineToTokenize === null || tokenizedLines > 200) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttokenizedLines++;\n\n\t\t\t\tconst text = this._lines[lineToTokenize.lineNumber - 1];\n\t\t\t\tconst r = this._tokenizerWithStateStore.tokenizationSupport.tokenizeEncoded(text, true, lineToTokenize.startState);\n\t\t\t\tif (this._tokenizerWithStateStore.store.setEndState(lineToTokenize.lineNumber, r.endState as StateStack)) {\n\t\t\t\t\tconst delta = this._diffStateStacksRefEqFn(lineToTokenize.startState, r.endState as StateStack);\n\t\t\t\t\tstateDeltaBuilder.setState(lineToTokenize.lineNumber, delta);\n\t\t\t\t} else {\n\t\t\t\t\tstateDeltaBuilder.setState(lineToTokenize.lineNumber, null);\n\t\t\t\t}\n\n\t\t\t\tLineTokens.convertToEndOffset(r.tokens, text.length);\n\t\t\t\ttokenBuilder.add(lineToTokenize.lineNumber, r.tokens);\n\n\t\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\t\tif (deltaMs > 20) {\n\t\t\t\t\t// yield to check for changes\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tokenizedLines === 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst stateDeltas = stateDeltaBuilder.getStateDeltas();\n\t\t\tthis._host.setTokensAndStates(\n\t\t\t\tthis._versionId,\n\t\t\t\ttokenBuilder.serialize(),\n\t\t\t\tstateDeltas\n\t\t\t);\n\n\t\t\tconst deltaMs = new Date().getTime() - startTime;\n\t\t\tif (deltaMs > 20) {\n\t\t\t\t// yield to check for changes\n\t\t\t\tsetTimeout0(() => this._tokenize());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass StateDeltaBuilder {\n\tprivate _lastStartLineNumber: number = -1;\n\tprivate _stateDeltas: StateDeltas[] = [];\n\n\tpublic setState(lineNumber: number, stackDiff: StackDiff | null): void {\n\t\tif (lineNumber === this._lastStartLineNumber + 1) {\n\t\t\tthis._stateDeltas[this._stateDeltas.length - 1].stateDeltas.push(stackDiff);\n\t\t} else {\n\t\t\tthis._stateDeltas.push({ startLineNumber: lineNumber, stateDeltas: [stackDiff] });\n\t\t}\n\t\tthis._lastStartLineNumber = lineNumber;\n\t}\n\n\tpublic getStateDeltas(): StateDeltas[] {\n\t\treturn this._stateDeltas;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as resources from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { LanguageId, StandardTokenType } from 'vs/editor/common/encodedTokenAttributes';\n\nexport interface IValidGrammarDefinition {\n\tlocation: URI;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport interface IValidTokenTypeMap {\n\t[selector: string]: StandardTokenType;\n}\n\nexport interface IValidEmbeddedLanguagesMap {\n\t[scopeName: string]: LanguageId;\n}\n\nexport class TMScopeRegistry {\n\n\tprivate _scopeNameToLanguageRegistration: { [scopeName: string]: IValidGrammarDefinition };\n\n\tconstructor() {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic reset(): void {\n\t\tthis._scopeNameToLanguageRegistration = Object.create(null);\n\t}\n\n\tpublic register(def: IValidGrammarDefinition): void {\n\t\tif (this._scopeNameToLanguageRegistration[def.scopeName]) {\n\t\t\tconst existingRegistration = this._scopeNameToLanguageRegistration[def.scopeName];\n\t\t\tif (!resources.isEqual(existingRegistration.location, def.location)) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`Overwriting grammar scope name to file mapping for scope ${def.scopeName}.\\n` +\n\t\t\t\t\t`Old grammar file: ${existingRegistration.location.toString()}.\\n` +\n\t\t\t\t\t`New grammar file: ${def.location.toString()}`\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tthis._scopeNameToLanguageRegistration[def.scopeName] = def;\n\t}\n\n\tpublic getGrammarDefinition(scopeName: string): IValidGrammarDefinition | null {\n\t\treturn this._scopeNameToLanguageRegistration[scopeName] || null;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { Disposable } from 'vs/base/common/lifecycle';\nimport { URI } from 'vs/base/common/uri';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, TMScopeRegistry } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport type { IGrammar, IOnigLib, IRawTheme, Registry, StateStack } from 'vscode-textmate';\n\ninterface ITMGrammarFactoryHost {\n\tlogTrace(msg: string): void;\n\tlogError(msg: string, err: any): void;\n\treadFile(resource: URI): Promise<string>;\n}\n\nexport interface ICreateGrammarResult {\n\tlanguageId: string;\n\tgrammar: IGrammar | null;\n\tinitialState: StateStack;\n\tcontainsEmbeddedLanguages: boolean;\n\tsourceExtensionId?: string;\n}\n\nexport const missingTMGrammarErrorMessage = 'No TM Grammar registered for this language.';\n\nexport class TMGrammarFactory extends Disposable {\n\n\tprivate readonly _host: ITMGrammarFactoryHost;\n\tprivate readonly _initialState: StateStack;\n\tprivate readonly _scopeRegistry: TMScopeRegistry;\n\tprivate readonly _injections: { [scopeName: string]: string[] };\n\tprivate readonly _injectedEmbeddedLanguages: { [scopeName: string]: IValidEmbeddedLanguagesMap[] };\n\tprivate readonly _languageToScope: Map<string, string>;\n\tprivate readonly _grammarRegistry: Registry;\n\n\tconstructor(host: ITMGrammarFactoryHost, grammarDefinitions: IValidGrammarDefinition[], vscodeTextmate: typeof import('vscode-textmate'), onigLib: Promise<IOnigLib>) {\n\t\tsuper();\n\t\tthis._host = host;\n\t\tthis._initialState = vscodeTextmate.INITIAL;\n\t\tthis._scopeRegistry = new TMScopeRegistry();\n\t\tthis._injections = {};\n\t\tthis._injectedEmbeddedLanguages = {};\n\t\tthis._languageToScope = new Map<string, string>();\n\t\tthis._grammarRegistry = this._register(new vscodeTextmate.Registry({\n\t\t\tonigLib: onigLib,\n\t\t\tloadGrammar: async (scopeName: string) => {\n\t\t\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\t\t\tif (!grammarDefinition) {\n\t\t\t\t\tthis._host.logTrace(`No grammar found for scope ${scopeName}`);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tconst location = grammarDefinition.location;\n\t\t\t\ttry {\n\t\t\t\t\tconst content = await this._host.readFile(location);\n\t\t\t\t\treturn vscodeTextmate.parseRawGrammar(content, location.path);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tthis._host.logError(`Unable to load and parse grammar for scope ${scopeName} from ${location}`, e);\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t},\n\t\t\tgetInjections: (scopeName: string) => {\n\t\t\t\tconst scopeParts = scopeName.split('.');\n\t\t\t\tlet injections: string[] = [];\n\t\t\t\tfor (let i = 1; i <= scopeParts.length; i++) {\n\t\t\t\t\tconst subScopeName = scopeParts.slice(0, i).join('.');\n\t\t\t\t\tinjections = [...injections, ...(this._injections[subScopeName] || [])];\n\t\t\t\t}\n\t\t\t\treturn injections;\n\t\t\t}\n\t\t}));\n\n\t\tfor (const validGrammar of grammarDefinitions) {\n\t\t\tthis._scopeRegistry.register(validGrammar);\n\n\t\t\tif (validGrammar.injectTo) {\n\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\tlet injections = this._injections[injectScope];\n\t\t\t\t\tif (!injections) {\n\t\t\t\t\t\tthis._injections[injectScope] = injections = [];\n\t\t\t\t\t}\n\t\t\t\t\tinjections.push(validGrammar.scopeName);\n\t\t\t\t}\n\n\t\t\t\tif (validGrammar.embeddedLanguages) {\n\t\t\t\t\tfor (const injectScope of validGrammar.injectTo) {\n\t\t\t\t\t\tlet injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[injectScope];\n\t\t\t\t\t\tif (!injectedEmbeddedLanguages) {\n\t\t\t\t\t\t\tthis._injectedEmbeddedLanguages[injectScope] = injectedEmbeddedLanguages = [];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinjectedEmbeddedLanguages.push(validGrammar.embeddedLanguages);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (validGrammar.language) {\n\t\t\t\tthis._languageToScope.set(validGrammar.language, validGrammar.scopeName);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic has(languageId: string): boolean {\n\t\treturn this._languageToScope.has(languageId);\n\t}\n\n\tpublic setTheme(theme: IRawTheme, colorMap: string[]): void {\n\t\tthis._grammarRegistry.setTheme(theme, colorMap);\n\t}\n\n\tpublic getColorMap(): string[] {\n\t\treturn this._grammarRegistry.getColorMap();\n\t}\n\n\tpublic async createGrammar(languageId: string, encodedLanguageId: number): Promise<ICreateGrammarResult> {\n\t\tconst scopeName = this._languageToScope.get(languageId);\n\t\tif (typeof scopeName !== 'string') {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst grammarDefinition = this._scopeRegistry.getGrammarDefinition(scopeName);\n\t\tif (!grammarDefinition) {\n\t\t\t// No TM grammar defined\n\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t}\n\n\t\tconst embeddedLanguages = grammarDefinition.embeddedLanguages;\n\t\tif (this._injectedEmbeddedLanguages[scopeName]) {\n\t\t\tconst injectedEmbeddedLanguages = this._injectedEmbeddedLanguages[scopeName];\n\t\t\tfor (const injected of injectedEmbeddedLanguages) {\n\t\t\t\tfor (const scope of Object.keys(injected)) {\n\t\t\t\t\tembeddedLanguages[scope] = injected[scope];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst containsEmbeddedLanguages = (Object.keys(embeddedLanguages).length > 0);\n\n\t\tlet grammar: IGrammar | null;\n\n\t\ttry {\n\t\t\tgrammar = await this._grammarRegistry.loadGrammarWithConfiguration(\n\t\t\t\tscopeName,\n\t\t\t\tencodedLanguageId,\n\t\t\t\t{\n\t\t\t\t\tembeddedLanguages,\n\t\t\t\t\ttokenTypes: <any>grammarDefinition.tokenTypes,\n\t\t\t\t\tbalancedBracketSelectors: grammarDefinition.balancedBracketSelectors,\n\t\t\t\t\tunbalancedBracketSelectors: grammarDefinition.unbalancedBracketSelectors,\n\t\t\t\t}\n\t\t\t);\n\t\t} catch (err) {\n\t\t\tif (err.message && err.message.startsWith('No grammar provided for')) {\n\t\t\t\t// No TM grammar defined\n\t\t\t\tthrow new Error(missingTMGrammarErrorMessage);\n\t\t\t}\n\t\t\tthrow err;\n\t\t}\n\n\t\treturn {\n\t\t\tlanguageId: languageId,\n\t\t\tgrammar: grammar,\n\t\t\tinitialState: this._initialState,\n\t\t\tcontainsEmbeddedLanguages: containsEmbeddedLanguages,\n\t\t\tsourceExtensionId: grammarDefinition.sourceExtensionId,\n\t\t};\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport { LanguageId } from 'vs/editor/common/encodedTokenAttributes';\nimport { IModelChangedEvent } from 'vs/editor/common/model/mirrorTextModel';\nimport { IWorkerContext } from 'vs/editor/common/services/editorSimpleWorker';\nimport { ICreateGrammarResult, TMGrammarFactory } from 'vs/workbench/services/textMate/common/TMGrammarFactory';\nimport { IValidEmbeddedLanguagesMap, IValidGrammarDefinition, IValidTokenTypeMap } from 'vs/workbench/services/textMate/common/TMScopeRegistry';\nimport type { IOnigLib, IRawTheme, StackDiff } from 'vscode-textmate';\nimport { TextMateWorkerTokenizer } from './textMateWorkerTokenizer';\n\n/**\n * Defines the worker entry point. Must be exported and named `create`.\n */\nexport function create(ctx: IWorkerContext<ITextMateWorkerHost>, createData: ICreateData): TextMateTokenizationWorker {\n\treturn new TextMateTokenizationWorker(ctx, createData);\n}\n\nexport interface ITextMateWorkerHost {\n\treadFile(_resource: UriComponents): Promise<string>;\n\tsetTokensAndStates(controllerId: number, versionId: number, tokens: Uint8Array, lineEndStateDeltas: StateDeltas[]): Promise<void>;\n\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void;\n}\n\nexport interface ICreateData {\n\tgrammarDefinitions: IValidGrammarDefinitionDTO[];\n\ttextmateMainUri: string;\n\tonigurumaMainUri: string;\n\tonigurumaWASMUri: string;\n}\n\nexport interface IValidGrammarDefinitionDTO {\n\tlocation: UriComponents;\n\tlanguage?: string;\n\tscopeName: string;\n\tembeddedLanguages: IValidEmbeddedLanguagesMap;\n\ttokenTypes: IValidTokenTypeMap;\n\tinjectTo?: string[];\n\tbalancedBracketSelectors: string[];\n\tunbalancedBracketSelectors: string[];\n\tsourceExtensionId?: string;\n}\n\nexport interface StateDeltas {\n\tstartLineNumber: number;\n\t// null means the state for that line did not change\n\tstateDeltas: (StackDiff | null)[];\n}\n\nexport class TextMateTokenizationWorker {\n\tprivate readonly _host: ITextMateWorkerHost;\n\tprivate readonly _models = new Map</* controllerId */ number, TextMateWorkerTokenizer>();\n\tprivate readonly _grammarCache: Promise<ICreateGrammarResult>[] = [];\n\tprivate readonly _grammarFactory: Promise<TMGrammarFactory | null>;\n\n\tconstructor(\n\t\tctx: IWorkerContext<ITextMateWorkerHost>,\n\t\tprivate readonly _createData: ICreateData\n\t) {\n\t\tthis._host = ctx.host;\n\t\tconst grammarDefinitions = _createData.grammarDefinitions.map<IValidGrammarDefinition>((def) => {\n\t\t\treturn {\n\t\t\t\tlocation: URI.revive(def.location),\n\t\t\t\tlanguage: def.language,\n\t\t\t\tscopeName: def.scopeName,\n\t\t\t\tembeddedLanguages: def.embeddedLanguages,\n\t\t\t\ttokenTypes: def.tokenTypes,\n\t\t\t\tinjectTo: def.injectTo,\n\t\t\t\tbalancedBracketSelectors: def.balancedBracketSelectors,\n\t\t\t\tunbalancedBracketSelectors: def.unbalancedBracketSelectors,\n\t\t\t\tsourceExtensionId: def.sourceExtensionId,\n\t\t\t};\n\t\t});\n\t\tthis._grammarFactory = this._loadTMGrammarFactory(grammarDefinitions);\n\t}\n\n\tprivate async _loadTMGrammarFactory(grammarDefinitions: IValidGrammarDefinition[]): Promise<TMGrammarFactory> {\n\t\tconst uri = this._createData.textmateMainUri;\n\t\tconst vscodeTextmate = await import(uri);\n\t\tconst vscodeOniguruma = await import(this._createData.onigurumaMainUri);\n\t\tconst response = await fetch(this._createData.onigurumaWASMUri);\n\n\t\t// Using the response directly only works if the server sets the MIME type 'application/wasm'.\n\t\t// Otherwise, a TypeError is thrown when using the streaming compiler.\n\t\t// We therefore use the non-streaming compiler :(.\n\t\tconst bytes = await response.arrayBuffer();\n\t\tawait vscodeOniguruma.loadWASM(bytes);\n\n\t\tconst onigLib: Promise<IOnigLib> = Promise.resolve({\n\t\t\tcreateOnigScanner: (sources) => vscodeOniguruma.createOnigScanner(sources),\n\t\t\tcreateOnigString: (str) => vscodeOniguruma.createOnigString(str)\n\t\t});\n\n\t\treturn new TMGrammarFactory({\n\t\t\tlogTrace: (msg: string) => {/* console.log(msg) */ },\n\t\t\tlogError: (msg: string, err: any) => console.error(msg, err),\n\t\t\treadFile: (resource: URI) => this._host.readFile(resource)\n\t\t}, grammarDefinitions, vscodeTextmate, onigLib);\n\t}\n\n\t// These methods are called by the renderer\n\n\tpublic acceptNewModel(data: IRawModelData): void {\n\t\tconst uri = URI.revive(data.uri);\n\t\tconst that = this;\n\t\tthis._models.set(data.controllerId, new TextMateWorkerTokenizer(uri, data.lines, data.EOL, data.versionId, {\n\t\t\tasync getOrCreateGrammar(languageId: string, encodedLanguageId: LanguageId): Promise<ICreateGrammarResult | null> {\n\t\t\t\tconst grammarFactory = await that._grammarFactory;\n\t\t\t\tif (!grammarFactory) {\n\t\t\t\t\treturn Promise.resolve(null);\n\t\t\t\t}\n\t\t\t\tif (!that._grammarCache[encodedLanguageId]) {\n\t\t\t\t\tthat._grammarCache[encodedLanguageId] = grammarFactory.createGrammar(languageId, encodedLanguageId);\n\t\t\t\t}\n\t\t\t\treturn that._grammarCache[encodedLanguageId];\n\t\t\t},\n\t\t\tsetTokensAndStates(versionId: number, tokens: Uint8Array, stateDeltas: StateDeltas[]): void {\n\t\t\t\tthat._host.setTokensAndStates(data.controllerId, versionId, tokens, stateDeltas);\n\t\t\t},\n\t\t\treportTokenizationTime(timeMs: number, languageId: string, sourceExtensionId: string | undefined, lineLength: number, isRandomSample: boolean): void {\n\t\t\t\tthat._host.reportTokenizationTime(timeMs, languageId, sourceExtensionId, lineLength, isRandomSample);\n\t\t\t},\n\t\t}, data.languageId, data.encodedLanguageId, data.maxTokenizationLineLength));\n\t}\n\n\tpublic acceptModelChanged(controllerId: number, e: IModelChangedEvent): void {\n\t\tthis._models.get(controllerId)!.onEvents(e);\n\t}\n\n\tpublic retokenize(controllerId: number, startLineNumber: number, endLineNumberExclusive: number): void {\n\t\tthis._models.get(controllerId)!.retokenize(startLineNumber, endLineNumberExclusive);\n\t}\n\n\tpublic acceptModelLanguageChanged(controllerId: number, newLanguageId: string, newEncodedLanguageId: LanguageId): void {\n\t\tthis._models.get(controllerId)!.onLanguageId(newLanguageId, newEncodedLanguageId);\n\t}\n\n\tpublic acceptRemovedModel(controllerId: number): void {\n\t\tconst model = this._models.get(controllerId);\n\t\tif (model) {\n\t\t\tmodel.dispose();\n\t\t\tthis._models.delete(controllerId);\n\t\t}\n\t}\n\n\tpublic async acceptTheme(theme: IRawTheme, colorMap: string[]): Promise<void> {\n\t\tconst grammarFactory = await this._grammarFactory;\n\t\tgrammarFactory?.setTheme(theme, colorMap);\n\t}\n\n\tpublic acceptMaxTokenizationLineLength(controllerId: number, value: number): void {\n\t\tthis._models.get(controllerId)!.acceptMaxTokenizationLineLength(value);\n\t}\n}\n\nexport interface IRawModelData {\n\turi: UriComponents;\n\tversionId: number;\n\tlines: string[];\n\tEOL: string;\n\tlanguageId: string;\n\tencodedLanguageId: LanguageId;\n\tmaxTokenizationLineLength: number;\n\tcontrollerId: number;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","exports","$U","amdLoadScript","amdInvokeFactory","nodeRequire","nodeEval","mark","map","stat","diff","duration","stats","require","b","nodeRequireTotal","value","to2dArray","res","index","header","rows","lengths","cell","ci","row","_cell","$5c","owner","debugNameSource","referenceFn","target","$6c","countPerName","cachedDebugName","data","cached","dbgName","computeDebugName","count","self","ownerStr","formatOwner","$7c","key","findKey","obj","countPerClassName","ownerId","id","className","getClassName","ctor","fn","fnSrc","match","globalObservableLogger","$wd","logger","$xd","$yd","text","consoleTextToArgs","normalText","repeat","info","styled","formatValue","observable","formatKind","changes","o","derived","existingHandleChange","change","changedObservables","autorun","transaction","transactionName","styles","firstArg","process","t","item","kind","padStr","options","objToCss","styleObj","styleString","propName","propValue","style","availableLen","formatArray","formatObject","first","val","str","length","$bd","$hd","debugName_1","$cd","$dd","$ed","store","lifecycle_1","disposable","reader","changeSummary","$fd","$gd","handler","_lastValue","newValue","lastValue","AutorunState","h","_runFn","j","logging_1","emptySet","isDisposed","d","assert_1","_recomputeInitiallyAndOnChange","$Gd","recomputeInitiallyAndOnChange","_keepObserved","$Hd","keepObserved","_derived","$Id","$Jd","fnOrOwner","fnOrUndefined","name","handleValue","$Kd","observer","$Ld","getDebugName","tx","$Pd","_globalTransaction","$Md","$Nd","$Od","_fn","updatingObservers","$Qd","nameOrOwner","initialValue","$Rd","_tx","oldValue","$Sd","$Td","$zd","a","$Ad","computeFnOrOwner","computeFn","$Fd","$Bd","base_1","$Cd","$Dd","computeFnOrUndefined","r","$Ed","DerivedState","n","_computeFn","p","q","s","hadValue","didChange","_observable","propagateBeginUpdate","observers","shouldReact","wasUpToDate","shouldCallBeginUpdate","shouldCallEndUpdate","$id","ConstObservable","$jd","promise","$kd","event","getValue","$ld","e","_getValue","args","didRunTransaction","batchEventsGlobally","didSet","$md","debugName","FromEventObservableSignal","$nd","debugNameOrOwner","ObservableSignal","$od","debounceMs","disposableStore","debouncedObservable","timeout","autorun_1","$pd","timeoutMs","$qd","$sd","$rd","c","$td","derived_1","$ud","counter","$vd","items","keySelector","m","ArrayMap","entry","newItems","itemsToRemove","$Ud","v","$Vd","$Wd","error","$Xd","$Yd","predicate","isError","resolve","reject","isImmediateRun","shouldDispose","stateObs","state","isFinished","$Zd","cancellationTokenSource","cancellation_1","utils_1","promise_1","$de","candidate","$ee","$fe","$ge","reducer","WriteableStreamImpl","f","listener","errors_1","callback","listeners","fullDataBuffer","pendingWritePromises","pendingWritePromise","$he","readable","chunks","chunk","$ie","maxChunks","lastReadChunk","$je","stream","$ke","token","$le","streamListeners","buffer","dataListener","errorListener","endListener","$me","$ne","$oe","consumed","$pe","transformer","$qe","prefix","prefixHandled","$re","hasBuffer","indexOfTable","lazy_1","textEncoder","textDecoder","$se","byteLength","actual","source","buffers","totalLength","ret","offset","element","start","end","array","$we","$xe","$ye","$ze","$Ae","$Be","subarray","$te","haystack","needle","needleLen","haystackLen","table","$ue","$ve","destination","$Ce","streams","$De","$Ee","$Fe","bufferedStream","$Ge","$He","$Ie","$Je","$Ke","$Le","encoded","building","remainder","bufi","append","code","unpadded","base64Alphabet","base64UrlSafeAlphabet","$Me","padded","urlSafe","dictionary","output","$$f","$_f","osPath","path_1","$ag","$bg","path","sep","firstLetter","pos","$gg","$cg","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","$dg","isWindowsOS","invalidFileChars","$eg","pathA","pathB","ignoreCase","identityEquals","strings_1","$fg","base","parentCandidate","separator","sepOffset","char0","$hg","cwd","$ig","pathNormalized","$jg","$kg","$lg","$mg","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","$ng","parent","randomLength","suffix","pathCharsTouse","randomFileName","Schemas","$og","scheme","uri_1","$pg","schemes","RemoteAuthoritiesImpl","schema","delegate","serverRootPath","authority","host","port","connectionToken","uri","err","errors","query","platform","FileAccessImpl","resourcePath","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","addSearchParam","urlOrSearch","coop","coep","DefineCall","dependencies","AMDModuleImporter","scriptSrc","defineCall","scriptElement","unbind","loadEventListener","errorEventListener","fs","vm","module","filePath","content","scriptSource","cache","_paths","$uD","nodeModuleName","pathInsideNodeModule","isBuilt","amd_1","nodeModulePath","network_1","resolve_1","reject_1","$Fg","$Gg","uri1","uri2","ignoreFragment","extpath","resource","pathFragment","paths","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","isRootSep","_","$1g","resourceAccessor","distinctParents","candidateResource","otherItem","DataUri","parseMetaData","dataUri","metadata","property","mime","$2g","localScheme","$3g","$4g","thenable","subscription","onfinally","$5g","defaultValue","ref","$6g","$7g","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","$8g","onTimeout","promiseResolve","timer","$9g","$0g","rej","$$g","promiseFactory","onComplete","$_g","promiseTask","$ah","newPromise","timeoutDeferred","scheduled","handle","microtaskDeferred","$bh","defaultDelay","task","delay","symbols_1","$ch","$dh","$eh","autoOpenTimeMs","$fh","millis","$gh","$hh","promiseFactories","results","next","thenHandler","$ih","shouldStop","loop","factory","$jh","promiseList","todo","finish","$kh","maxDegreeOfParalellism","event_1","iLimitedTask","$lh","$mh","$zh","$nh","$Bh","queue","extUri","resources_1","drainListenerId","drainListener","drainer","$oh","runner","$ph","interval","context","$qh","$rh","$sh","unit","units","$th","g","_targetWindow","disposed","targetWindow","$wh","executor","$xh","$yh","retries","lastError","taskId","onCancel","queued","run","promiseReject","$Ah","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","$Ch","$Dh","AsyncIterableSourceState","$Eh","writer","emitter","iterables","iterable","mapFn","filterFn","values","$Fh","l","$Gh","innerIterable","$Hh","earlyError","earlyItems","StringEOL","$Gt","eolCount","firstLineLength","lastLineStart","eol","chr","LanguageId","FontStyle","ColorId","StandardTokenType","MetadataConsts","$Et","fontStyle","colorMap","foreground","textDecoration","$tC","oldLength","newLength","before","after","insertArr","arrayFill","deleteIndex","deleteCount","insertIndex","insertCount","arr","arrays_1","$Ht","lineContent","decoder","defaultMetadata","tokens","other","sliceFromTokenIndex","sliceTokenCount","tokenIndex","languageId","encodedTokenAttributes_1","startOffset","endOffset","deltaOffset","SliceLineTokens","lineTextLength","lastTokenIndex","desiredIndex","low","high","mid","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","originalEndOffset","nextOriginalTokenEndOffset","nextInsertToken","tokenEndOffset","$Jt","lineTokens","toChIndex","fromChIndex","$Kt","tokensCount","fromTokenIndex","lineTokens_1","fromTokenStartOffset","fromTokenEndOffset","delta","dest","lastEnd","tmp","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","textLength","$Lt","buff","view32","startLineNumber","buffer_1","byteCount","lineRange_1","lineNumber","range","eolCounter_1","position_1","firstLineIndex","lastLineIndex","deletedLinesCount","contiguousTokensEditing_1","lastLineTokens","deletedBefore","position","lineIndex","arrays","$uC","contiguousMultilineTokens_1","last","size","$rC","languages_1","$sC","Constants","$vC","lineCount","tokenizationSupport","$xC","$wC","_textModel","_languageIdCodec","builder","lineToTokenize","safeTokenize","character","lineStartState","newText","curLineContent","newLineContent","firstInvalidLineNumber","endLineNumber","nonWhitespaceColumn","likelyRelevantLines","initialState","newNonWhitespaceIndex","$yC","$zC","offsetRange_1","newLineCount","startState","fixedArray_1","oldState","idx","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","nullTokenize_1","$AC","async_1","deadline","endTime","execute","contiguousMultilineTokensBuilder_1","sw","stopwatch_1","firstInvalidLine","endLineNumberExclusive","$4Ib","textModel","isRandomSample","shouldMeasure","textMateResult","timeMS","seenLanguages","endState","$5Ib","observable_1","$0Ib","mirrorTextModel_1","lines","versionId","maxTokenizationLineLength","encodedLanguageId","tokenizationSupportWithLineLimit_1","textMateTokenizationSupport_1","timeMs","lineLength","textModelTokens_1","diffStateStacksRefEq","amdX_1","startTime","tokenizedLines","tokenBuilder","stateDeltaBuilder","StateDeltaBuilder","stateDeltas","stackDiff","$7Ib","def","existingRegistration","resources","scopeName","$9Ib","grammarDefinitions","vscodeTextmate","onigLib","TMScopeRegistry_1","grammarDefinition","location","scopeParts","injections","subScopeName","validGrammar","injectScope","injectedEmbeddedLanguages","theme","embeddedLanguages","injected","scope","containsEmbeddedLanguages","grammar","create","ctx","createData","TextMateTokenizationWorker","vscodeOniguruma","resolve_2","reject_2","bytes","sources","TMGrammarFactory_1","msg","that","textMateWorkerTokenizer_1","grammarFactory","sourceExtensionId","controllerId","newLanguageId","newEncodedLanguageId","model"],"file":"textMateTokenizationWorker.worker.js"}