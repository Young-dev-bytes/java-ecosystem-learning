{"version":3,"file":"main.js","mappings":"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","sources":["webpack://gulp/external commonjs \"vscode\"","webpack://gulp/external node-commonjs \"child_process\"","webpack://gulp/external node-commonjs \"fs\"","webpack://gulp/external node-commonjs \"path\"","webpack://gulp/webpack/bootstrap","webpack://gulp/./src/main.ts"],"sourcesContent":["module.exports = require(\"vscode\");","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"path\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as cp from 'child_process';\nimport * as vscode from 'vscode';\n\n\ntype AutoDetect = 'on' | 'off';\n\n/**\n * Check if the given filename is a file.\n *\n * If returns false in case the file does not exist or\n * the file stats cannot be accessed/queried or it\n * is no file at all.\n *\n * @param filename\n *   the filename to the checked\n * @returns\n *   true in case the file exists, in any other case false.\n */\nasync function exists(filename: string): Promise<boolean> {\n\ttry {\n\n\t\tif ((await fs.promises.stat(filename)).isFile()) {\n\t\t\treturn true;\n\t\t}\n\t} catch (ex) {\n\t\t// In case requesting the file statistics fail.\n\t\t// we assume it does not exist.\n\t\treturn false;\n\t}\n\n\treturn false;\n}\n\nfunction exec(command: string, options: cp.ExecOptions): Promise<{ stdout: string; stderr: string }> {\n\treturn new Promise<{ stdout: string; stderr: string }>((resolve, reject) => {\n\t\tcp.exec(command, options, (error, stdout, stderr) => {\n\t\t\tif (error) {\n\t\t\t\treject({ error, stdout, stderr });\n\t\t\t}\n\t\t\tresolve({ stdout, stderr });\n\t\t});\n\t});\n}\n\nconst buildNames: string[] = ['build', 'compile', 'watch'];\nfunction isBuildTask(name: string): boolean {\n\tfor (const buildName of buildNames) {\n\t\tif (name.indexOf(buildName) !== -1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nconst testNames: string[] = ['test'];\nfunction isTestTask(name: string): boolean {\n\tfor (const testName of testNames) {\n\t\tif (name.indexOf(testName) !== -1) {\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nlet _channel: vscode.OutputChannel;\nfunction getOutputChannel(): vscode.OutputChannel {\n\tif (!_channel) {\n\t\t_channel = vscode.window.createOutputChannel('Gulp Auto Detection');\n\t}\n\treturn _channel;\n}\n\nfunction showError() {\n\tvscode.window.showWarningMessage(vscode.l10n.t(\"Problem finding gulp tasks. See the output for more information.\"),\n\t\tvscode.l10n.t(\"Go to output\")).then((choice) => {\n\t\t\tif (choice !== undefined) {\n\t\t\t\t_channel.show(true);\n\t\t\t}\n\t\t});\n}\n\nasync function findGulpCommand(rootPath: string): Promise<string> {\n\tconst platform = process.platform;\n\n\tif (platform === 'win32' && await exists(path.join(rootPath, 'node_modules', '.bin', 'gulp.cmd'))) {\n\t\tconst globalGulp = path.join(process.env.APPDATA ? process.env.APPDATA : '', 'npm', 'gulp.cmd');\n\t\tif (await exists(globalGulp)) {\n\t\t\treturn `\"${globalGulp}\"`;\n\t\t}\n\n\t\treturn path.join('.', 'node_modules', '.bin', 'gulp.cmd');\n\n\t}\n\n\tif ((platform === 'linux' || platform === 'darwin') && await exists(path.join(rootPath, 'node_modules', '.bin', 'gulp'))) {\n\t\treturn path.join('.', 'node_modules', '.bin', 'gulp');\n\t}\n\n\treturn 'gulp';\n}\n\ninterface GulpTaskDefinition extends vscode.TaskDefinition {\n\ttask: string;\n\tfile?: string;\n}\n\nclass FolderDetector {\n\n\tprivate fileWatcher: vscode.FileSystemWatcher | undefined;\n\tprivate promise: Thenable<vscode.Task[]> | undefined;\n\n\tconstructor(\n\t\tprivate _workspaceFolder: vscode.WorkspaceFolder,\n\t\tprivate _gulpCommand: Promise<string>) {\n\t}\n\n\tpublic get workspaceFolder(): vscode.WorkspaceFolder {\n\t\treturn this._workspaceFolder;\n\t}\n\n\tpublic isEnabled(): boolean {\n\t\treturn vscode.workspace.getConfiguration('gulp', this._workspaceFolder.uri).get<AutoDetect>('autoDetect') === 'on';\n\t}\n\n\tpublic start(): void {\n\t\tconst pattern = path.join(this._workspaceFolder.uri.fsPath, '{node_modules,gulpfile{.babel.js,.esm.js,.js,.mjs,.cjs,.ts}}');\n\t\tthis.fileWatcher = vscode.workspace.createFileSystemWatcher(pattern);\n\t\tthis.fileWatcher.onDidChange(() => this.promise = undefined);\n\t\tthis.fileWatcher.onDidCreate(() => this.promise = undefined);\n\t\tthis.fileWatcher.onDidDelete(() => this.promise = undefined);\n\t}\n\n\tpublic async getTasks(): Promise<vscode.Task[]> {\n\t\tif (!this.isEnabled()) {\n\t\t\treturn [];\n\t\t}\n\n\t\tif (!this.promise) {\n\t\t\tthis.promise = this.computeTasks();\n\t\t}\n\n\t\treturn this.promise;\n\t}\n\n\tpublic async getTask(_task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\tconst gulpTask = (<any>_task.definition).task;\n\t\tif (gulpTask) {\n\t\t\tconst kind: GulpTaskDefinition = (<any>_task.definition);\n\t\t\tconst options: vscode.ShellExecutionOptions = { cwd: this.workspaceFolder.uri.fsPath };\n\t\t\tconst task = new vscode.Task(kind, this.workspaceFolder, gulpTask, 'gulp', new vscode.ShellExecution(await this._gulpCommand, [gulpTask], options));\n\t\t\treturn task;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Searches for a gulp entry point inside the given folder.\n\t *\n\t * Typically the entry point is a file named \"gulpfile.js\"\n\t *\n\t * It can also be a transposed gulp entry points, like gulp.babel.js or gulp.esm.js\n\t *\n\t * Additionally recent node version prefer the .mjs or .cjs extension over the .js.\n\t *\n\t * @param root\n\t *   the folder which should be checked.\n\t */\n\tprivate async hasGulpfile(root: string): Promise<boolean | undefined> {\n\n\t\tfor (const filename of await fs.promises.readdir(root)) {\n\n\t\t\tconst ext = path.extname(filename);\n\t\t\tif (ext !== '.js' && ext !== '.mjs' && ext !== '.cjs' && ext !== '.ts') {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!exists(filename)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tconst basename = path.basename(filename, ext).toLowerCase();\n\t\t\tif (basename === 'gulpfile') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (basename === 'gulpfile.esm') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (basename === 'gulpfile.babel') {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tprivate async computeTasks(): Promise<vscode.Task[]> {\n\t\tconst rootPath = this._workspaceFolder.uri.scheme === 'file' ? this._workspaceFolder.uri.fsPath : undefined;\n\t\tconst emptyTasks: vscode.Task[] = [];\n\t\tif (!rootPath) {\n\t\t\treturn emptyTasks;\n\t\t}\n\n\t\tif (!await this.hasGulpfile(rootPath)) {\n\t\t\treturn emptyTasks;\n\t\t}\n\n\t\tconst commandLine = `${await this._gulpCommand} --tasks-simple --no-color`;\n\t\ttry {\n\t\t\tconst { stdout, stderr } = await exec(commandLine, { cwd: rootPath });\n\t\t\tif (stderr && stderr.length > 0) {\n\t\t\t\t// Filter out \"No license field\"\n\t\t\t\tconst errors = stderr.split('\\n');\n\t\t\t\terrors.pop(); // The last line is empty.\n\t\t\t\tif (!errors.every(value => value.indexOf('No license field') >= 0)) {\n\t\t\t\t\tgetOutputChannel().appendLine(stderr);\n\t\t\t\t\tshowError();\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst result: vscode.Task[] = [];\n\t\t\tif (stdout) {\n\t\t\t\tconst lines = stdout.split(/\\r{0,1}\\n/);\n\t\t\t\tfor (const line of lines) {\n\t\t\t\t\tif (line.length === 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst kind: GulpTaskDefinition = {\n\t\t\t\t\t\ttype: 'gulp',\n\t\t\t\t\t\ttask: line\n\t\t\t\t\t};\n\t\t\t\t\tconst options: vscode.ShellExecutionOptions = { cwd: this.workspaceFolder.uri.fsPath };\n\t\t\t\t\tconst task = new vscode.Task(kind, this.workspaceFolder, line, 'gulp', new vscode.ShellExecution(await this._gulpCommand, [line], options));\n\t\t\t\t\tresult.push(task);\n\t\t\t\t\tconst lowerCaseLine = line.toLowerCase();\n\t\t\t\t\tif (isBuildTask(lowerCaseLine)) {\n\t\t\t\t\t\ttask.group = vscode.TaskGroup.Build;\n\t\t\t\t\t} else if (isTestTask(lowerCaseLine)) {\n\t\t\t\t\t\ttask.group = vscode.TaskGroup.Test;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (err) {\n\t\t\tconst channel = getOutputChannel();\n\t\t\tif (err.stderr) {\n\t\t\t\tchannel.appendLine(err.stderr);\n\t\t\t}\n\t\t\tif (err.stdout) {\n\t\t\t\tchannel.appendLine(err.stdout);\n\t\t\t}\n\t\t\tchannel.appendLine(vscode.l10n.t(\"Auto detecting gulp for folder {0} failed with error: {1}', this.workspaceFolder.name, err.error ? err.error.toString() : 'unknown\"));\n\t\t\tshowError();\n\t\t\treturn emptyTasks;\n\t\t}\n\t}\n\n\tpublic dispose() {\n\t\tthis.promise = undefined;\n\t\tif (this.fileWatcher) {\n\t\t\tthis.fileWatcher.dispose();\n\t\t}\n\t}\n}\n\nclass TaskDetector {\n\n\tprivate taskProvider: vscode.Disposable | undefined;\n\tprivate detectors: Map<string, FolderDetector> = new Map();\n\n\tconstructor() {\n\t}\n\n\tpublic start(): void {\n\t\tconst folders = vscode.workspace.workspaceFolders;\n\t\tif (folders) {\n\t\t\tthis.updateWorkspaceFolders(folders, []);\n\t\t}\n\t\tvscode.workspace.onDidChangeWorkspaceFolders((event) => this.updateWorkspaceFolders(event.added, event.removed));\n\t\tvscode.workspace.onDidChangeConfiguration(this.updateConfiguration, this);\n\t}\n\n\tpublic dispose(): void {\n\t\tif (this.taskProvider) {\n\t\t\tthis.taskProvider.dispose();\n\t\t\tthis.taskProvider = undefined;\n\t\t}\n\t\tthis.detectors.clear();\n\t}\n\n\tprivate updateWorkspaceFolders(added: readonly vscode.WorkspaceFolder[], removed: readonly vscode.WorkspaceFolder[]): void {\n\t\tfor (const remove of removed) {\n\t\t\tconst detector = this.detectors.get(remove.uri.toString());\n\t\t\tif (detector) {\n\t\t\t\tdetector.dispose();\n\t\t\t\tthis.detectors.delete(remove.uri.toString());\n\t\t\t}\n\t\t}\n\t\tfor (const add of added) {\n\t\t\tconst detector = new FolderDetector(add, findGulpCommand(add.uri.fsPath));\n\t\t\tthis.detectors.set(add.uri.toString(), detector);\n\t\t\tif (detector.isEnabled()) {\n\t\t\t\tdetector.start();\n\t\t\t}\n\t\t}\n\t\tthis.updateProvider();\n\t}\n\n\tprivate updateConfiguration(): void {\n\t\tfor (const detector of this.detectors.values()) {\n\t\t\tdetector.dispose();\n\t\t\tthis.detectors.delete(detector.workspaceFolder.uri.toString());\n\t\t}\n\t\tconst folders = vscode.workspace.workspaceFolders;\n\t\tif (folders) {\n\t\t\tfor (const folder of folders) {\n\t\t\t\tif (!this.detectors.has(folder.uri.toString())) {\n\t\t\t\t\tconst detector = new FolderDetector(folder, findGulpCommand(folder.uri.fsPath));\n\t\t\t\t\tthis.detectors.set(folder.uri.toString(), detector);\n\t\t\t\t\tif (detector.isEnabled()) {\n\t\t\t\t\t\tdetector.start();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.updateProvider();\n\t}\n\n\tprivate updateProvider(): void {\n\t\tif (!this.taskProvider && this.detectors.size > 0) {\n\t\t\tconst thisCapture = this;\n\t\t\tthis.taskProvider = vscode.tasks.registerTaskProvider('gulp', {\n\t\t\t\tprovideTasks(): Promise<vscode.Task[]> {\n\t\t\t\t\treturn thisCapture.getTasks();\n\t\t\t\t},\n\t\t\t\tresolveTask(_task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\t\t\t\treturn thisCapture.getTask(_task);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\telse if (this.taskProvider && this.detectors.size === 0) {\n\t\t\tthis.taskProvider.dispose();\n\t\t\tthis.taskProvider = undefined;\n\t\t}\n\t}\n\n\tpublic getTasks(): Promise<vscode.Task[]> {\n\t\treturn this.computeTasks();\n\t}\n\n\tprivate computeTasks(): Promise<vscode.Task[]> {\n\t\tif (this.detectors.size === 0) {\n\t\t\treturn Promise.resolve([]);\n\t\t} else if (this.detectors.size === 1) {\n\t\t\treturn this.detectors.values().next().value.getTasks();\n\t\t} else {\n\t\t\tconst promises: Promise<vscode.Task[]>[] = [];\n\t\t\tfor (const detector of this.detectors.values()) {\n\t\t\t\tpromises.push(detector.getTasks().then((value) => value, () => []));\n\t\t\t}\n\t\t\treturn Promise.all(promises).then((values) => {\n\t\t\t\tconst result: vscode.Task[] = [];\n\t\t\t\tfor (const tasks of values) {\n\t\t\t\t\tif (tasks && tasks.length > 0) {\n\t\t\t\t\t\tresult.push(...tasks);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t});\n\t\t}\n\t}\n\n\tpublic async getTask(task: vscode.Task): Promise<vscode.Task | undefined> {\n\t\tif (this.detectors.size === 0) {\n\t\t\treturn undefined;\n\t\t} else if (this.detectors.size === 1) {\n\t\t\treturn this.detectors.values().next().value.getTask(task);\n\t\t} else {\n\t\t\tif ((task.scope === vscode.TaskScope.Workspace) || (task.scope === vscode.TaskScope.Global)) {\n\t\t\t\t// Not supported, we don't have enough info to create the task.\n\t\t\t\treturn undefined;\n\t\t\t} else if (task.scope) {\n\t\t\t\tconst detector = this.detectors.get(task.scope.uri.toString());\n\t\t\t\tif (detector) {\n\t\t\t\t\treturn detector.getTask(task);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn undefined;\n\t\t}\n\t}\n}\n\nlet detector: TaskDetector;\nexport function activate(_context: vscode.ExtensionContext): void {\n\tdetector = new TaskDetector();\n\tdetector.start();\n}\n\nexport function deactivate(): void {\n\tdetector.dispose();\n}\n"],"names":["module","exports","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","_context","detector","TaskDetector","start","dispose","async","exists","filename","fs","promises","stat","isFile","ex","buildNames","isBuildTask","name","buildName","indexOf","testNames","isTestTask","testName","_channel","getOutputChannel","vscode","window","createOutputChannel","showError","showWarningMessage","l10n","t","then","choice","show","findGulpCommand","rootPath","platform","process","path","join","globalGulp","env","APPDATA","FolderDetector","constructor","_workspaceFolder","_gulpCommand","workspaceFolder","this","isEnabled","workspace","getConfiguration","uri","get","pattern","fsPath","fileWatcher","createFileSystemWatcher","onDidChange","promise","onDidCreate","onDidDelete","getTasks","computeTasks","getTask","_task","gulpTask","definition","task","kind","options","cwd","Task","ShellExecution","hasGulpfile","root","readdir","ext","extname","basename","toLowerCase","scheme","emptyTasks","commandLine","stdout","stderr","command","Promise","resolve","reject","cp","exec","error","length","errors","split","pop","every","value","appendLine","result","lines","line","type","push","lowerCaseLine","group","TaskGroup","Build","Test","err","channel","detectors","Map","folders","workspaceFolders","updateWorkspaceFolders","onDidChangeWorkspaceFolders","event","added","removed","onDidChangeConfiguration","updateConfiguration","taskProvider","clear","remove","toString","delete","add","set","updateProvider","values","folder","has","size","thisCapture","tasks","registerTaskProvider","provideTasks","resolveTask","next","all","scope","TaskScope","Workspace","Global"],"sourceRoot":""}