{"version":3,"file":"ms.post.min.js","sources":["../dist-esm/src/DataModels.js","../dist-esm/src/InternalConstants.js","../dist-esm/src/EventBatch.js","../dist-esm/src/ClockSkewManager.js","../dist-esm/src/KillSwitch.js","../dist-esm/src/RetryPolicy.js","../dist-esm/src/Serializer.js","../dist-esm/src/HttpManager.js","../dist-esm/src/TimeoutOverrideWrapper.js","../dist-esm/src/PostChannel.js"],"sourcesContent":["/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n * Real Time profile (default profile). RealTime Latency events are sent every 1 sec and\r\n * Normal Latency events are sent every 2 sec.\r\n */\r\nexport var RT_PROFILE = \"REAL_TIME\";\r\n/**\r\n * Near Real Time profile. RealTime Latency events are sent every 3 sec and\r\n * Normal Latency events are sent every 6 sec.\r\n */\r\nexport var NRT_PROFILE = \"NEAR_REAL_TIME\";\r\n/**\r\n * Best Effort. RealTime Latency events are sent every 9 sec and\r\n * Normal Latency events are sent every 18 sec.\r\n */\r\nexport var BE_PROFILE = \"BEST_EFFORT\";\r\n//# sourceMappingURL=DataModels.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n\r\n// Licensed under the MIT License.\r\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n// Note: DON'T Export these const from the package as we are still targeting ES3 this will export a mutable variables that someone could change!!!\r\n// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n// Generally you should only put values that are used more than 2 times and then only if not already exposed as a constant (such as SdkCoreNames)\r\n// as when using \"short\" named values from here they will be will be minified smaller than the SdkCoreNames[eSdkCoreNames.xxxx] value.\r\nexport var STR_EMPTY = \"\";\r\nexport var STR_POST_METHOD = \"POST\";\r\nexport var STR_DISABLED_PROPERTY_NAME = \"Microsoft_ApplicationInsights_BypassAjaxInstrumentation\";\r\nexport var STR_DROPPED = \"drop\";\r\nexport var STR_SENDING = \"send\";\r\nexport var STR_REQUEUE = \"requeue\";\r\nexport var STR_RESPONSE_FAIL = \"rspFail\";\r\nexport var STR_OTHER = \"oth\";\r\nexport var DEFAULT_CACHE_CONTROL = \"no-cache, no-store\";\r\nexport var DEFAULT_CONTENT_TYPE = \"application/x-json-stream\";\r\nexport var STR_CACHE_CONTROL = \"cache-control\";\r\nexport var STR_CONTENT_TYPE_HEADER = \"content-type\";\r\nexport var STR_KILL_TOKENS_HEADER = \"kill-tokens\";\r\nexport var STR_KILL_DURATION_HEADER = \"kill-duration\";\r\nexport var STR_KILL_DURATION_SECONDS_HEADER = \"kill-duration-seconds\";\r\nexport var STR_TIME_DELTA_HEADER = \"time-delta-millis\";\r\nexport var STR_CLIENT_VERSION = \"client-version\";\r\nexport var STR_CLIENT_ID = \"client-id\";\r\nexport var STR_TIME_DELTA_TO_APPLY = \"time-delta-to-apply-millis\";\r\nexport var STR_UPLOAD_TIME = \"upload-time\";\r\nexport var STR_API_KEY = \"apikey\";\r\nexport var STR_MSA_DEVICE_TICKET = \"AuthMsaDeviceTicket\";\r\nexport var STR_AUTH_XTOKEN = \"AuthXToken\";\r\nexport var STR_SDK_VERSION = \"sdk-version\";\r\nexport var STR_NO_RESPONSE_BODY = \"NoResponseBody\";\r\nexport var STR_MSFPC = \"msfpc\";\r\nexport var STR_TRACE = \"trace\";\r\nexport var STR_USER = \"user\";\r\n//# sourceMappingURL=InternalConstants.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* EventBatch.ts\r\n* @author Nev Wylie (newylie)\r\n* @copyright Microsoft 2020\r\n*/\r\nimport { isNullOrUndefined, isValueAssigned } from \"@microsoft/1ds-core-js\";\r\nimport { STR_EMPTY, STR_MSFPC } from \"./InternalConstants\";\r\nfunction _getEventMsfpc(theEvent) {\r\n    var intWeb = ((theEvent.ext || {})[\"intweb\"]);\r\n    if (intWeb && isValueAssigned(intWeb[STR_MSFPC])) {\r\n        return intWeb[STR_MSFPC];\r\n    }\r\n    return null;\r\n}\r\nfunction _getMsfpc(theEvents) {\r\n    var msfpc = null;\r\n    for (var lp = 0; msfpc === null && lp < theEvents.length; lp++) {\r\n        msfpc = _getEventMsfpc(theEvents[lp]);\r\n    }\r\n    return msfpc;\r\n}\r\n/**\r\n* This class defines a \"batch\" events related to a specific iKey, it is used by the PostChannel and HttpManager\r\n* to collect and transfer ownership of events without duplicating them in-memory. This reduces the previous\r\n* array duplication and shared ownership issues that occurred due to race conditions caused by the async nature\r\n* of sending requests.\r\n*/\r\nvar EventBatch = /** @class */ (function () {\r\n    /**\r\n     * Private constructor so that caller is forced to use the static create method.\r\n     * @param iKey - The iKey to associate with the events (not validated)\r\n     * @param addEvents - The optional collection of events to assign to this batch - defaults to an empty array.\r\n     */\r\n    function EventBatch(iKey, addEvents) {\r\n        var events = addEvents ? [].concat(addEvents) : [];\r\n        var _self = this;\r\n        var _msfpc = _getMsfpc(events);\r\n        _self.iKey = function () {\r\n            return iKey;\r\n        };\r\n        _self.Msfpc = function () {\r\n            // return the cached value unless it's undefined -- used to avoid cpu\r\n            return _msfpc || STR_EMPTY;\r\n        };\r\n        _self.count = function () {\r\n            return events.length;\r\n        };\r\n        _self.events = function () {\r\n            return events;\r\n        };\r\n        _self.addEvent = function (theEvent) {\r\n            if (theEvent) {\r\n                events.push(theEvent);\r\n                if (!_msfpc) {\r\n                    // Not found so try and find one\r\n                    _msfpc = _getEventMsfpc(theEvent);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        _self.split = function (fromEvent, numEvents) {\r\n            // Create a new batch with the same iKey\r\n            var theEvents;\r\n            if (fromEvent < events.length) {\r\n                var cnt = events.length - fromEvent;\r\n                if (!isNullOrUndefined(numEvents)) {\r\n                    cnt = numEvents < cnt ? numEvents : cnt;\r\n                }\r\n                theEvents = events.splice(fromEvent, cnt);\r\n                // reset the fetched msfpc value\r\n                _msfpc = _getMsfpc(events);\r\n            }\r\n            return new EventBatch(iKey, theEvents);\r\n        };\r\n    }\r\n    /**\r\n     * Creates a new Event Batch object\r\n     * @param iKey The iKey associated with this batch of events\r\n     */\r\n    EventBatch.create = function (iKey, theEvents) {\r\n        return new EventBatch(iKey, theEvents);\r\n    };\r\n    return EventBatch;\r\n}());\r\nexport { EventBatch };\r\n//# sourceMappingURL=EventBatch.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* ClockSkewManager.ts\r\n* @author Abhilash Panwar (abpanwar)\r\n* @copyright Microsoft 2018\r\n*/\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\n/**\r\n* Class to manage clock skew correction.\r\n*/\r\nvar ClockSkewManager = /** @class */ (function () {\r\n    function ClockSkewManager() {\r\n        var _allowRequestSending = true;\r\n        var _shouldAddClockSkewHeaders = true;\r\n        var _isFirstRequest = true;\r\n        var _clockSkewHeaderValue = \"use-collector-delta\";\r\n        var _clockSkewSet = false;\r\n        dynamicProto(ClockSkewManager, this, function (_self) {\r\n            /**\r\n             * Determine if requests can be sent.\r\n             * @returns True if requests can be sent, false otherwise.\r\n             */\r\n            _self.allowRequestSending = function () {\r\n                return _allowRequestSending;\r\n            };\r\n            /**\r\n             * Tells the ClockSkewManager that it should assume that the first request has now been sent,\r\n             * If this method had not yet been called AND the clock Skew had not been set this will set\r\n             * allowRequestSending to false until setClockSet() is called.\r\n             */\r\n            _self.firstRequestSent = function () {\r\n                if (_isFirstRequest) {\r\n                    _isFirstRequest = false;\r\n                    if (!_clockSkewSet) {\r\n                        // Block sending until we get the first clock Skew\r\n                        _allowRequestSending = false;\r\n                    }\r\n                }\r\n            };\r\n            /**\r\n             * Determine if clock skew headers should be added to the request.\r\n             * @returns True if clock skew headers should be added, false otherwise.\r\n             */\r\n            _self.shouldAddClockSkewHeaders = function () {\r\n                return _shouldAddClockSkewHeaders;\r\n            };\r\n            /**\r\n             * Gets the clock skew header value.\r\n             * @returns The clock skew header value.\r\n             */\r\n            _self.getClockSkewHeaderValue = function () {\r\n                return _clockSkewHeaderValue;\r\n            };\r\n            /**\r\n             * Sets the clock skew header value. Once clock skew is set this method\r\n             * is no-op.\r\n             * @param timeDeltaInMillis - Time delta to be saved as the clock skew header value.\r\n             */\r\n            _self.setClockSkew = function (timeDeltaInMillis) {\r\n                if (!_clockSkewSet) {\r\n                    if (timeDeltaInMillis) {\r\n                        _clockSkewHeaderValue = timeDeltaInMillis;\r\n                        _shouldAddClockSkewHeaders = true;\r\n                        _clockSkewSet = true;\r\n                    }\r\n                    else {\r\n                        _shouldAddClockSkewHeaders = false;\r\n                    }\r\n                    // Unblock sending\r\n                    _allowRequestSending = true;\r\n                }\r\n            };\r\n        });\r\n    }\r\n// Removed Stub for ClockSkewManager.prototype.allowRequestSending.\r\n// Removed Stub for ClockSkewManager.prototype.firstRequestSent.\r\n// Removed Stub for ClockSkewManager.prototype.shouldAddClockSkewHeaders.\r\n// Removed Stub for ClockSkewManager.prototype.getClockSkewHeaderValue.\r\n// Removed Stub for ClockSkewManager.prototype.setClockSkew.\r\n    // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n    // this will be removed when ES3 support is dropped.\n    ClockSkewManager.__ieDyn=1;\n\n    return ClockSkewManager;\r\n}());\r\nexport default ClockSkewManager;\r\n//# sourceMappingURL=ClockSkewManager.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* KillSwitch.ts\r\n* @author Abhilash Panwar (abpanwar)\r\n* @copyright Microsoft 2018\r\n*/\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { arrForEach, dateNow, strTrim } from \"@microsoft/1ds-core-js\";\r\nvar SecToMsMultiplier = 1000;\r\n/**\r\n* Class to stop certain tenants sending events.\r\n*/\r\nvar KillSwitch = /** @class */ (function () {\r\n    function KillSwitch() {\r\n        var _killedTokenDictionary = {};\r\n        function _normalizeTenants(values) {\r\n            var result = [];\r\n            if (values) {\r\n                arrForEach(values, function (value) {\r\n                    result.push(strTrim(value));\r\n                });\r\n            }\r\n            return result;\r\n        }\r\n        dynamicProto(KillSwitch, this, function (_self) {\r\n            _self.setKillSwitchTenants = function (killTokens, killDuration) {\r\n                if (killTokens && killDuration) {\r\n                    try {\r\n                        var killedTokens = _normalizeTenants(killTokens.split(\",\"));\r\n                        if (killDuration === \"this-request-only\") {\r\n                            return killedTokens;\r\n                        }\r\n                        var durationMs = parseInt(killDuration, 10) * SecToMsMultiplier;\r\n                        for (var i = 0; i < killedTokens.length; ++i) {\r\n                            _killedTokenDictionary[killedTokens[i]] = dateNow() + durationMs;\r\n                        }\r\n                    }\r\n                    catch (ex) {\r\n                        return [];\r\n                    }\r\n                }\r\n                return [];\r\n            };\r\n            _self.isTenantKilled = function (tenantToken) {\r\n                var killDictionary = _killedTokenDictionary;\r\n                var name = strTrim(tenantToken);\r\n                if (killDictionary[name] !== undefined && killDictionary[name] > dateNow()) {\r\n                    return true;\r\n                }\r\n                delete killDictionary[name];\r\n                return false;\r\n            };\r\n        });\r\n    }\r\n// Removed Stub for KillSwitch.prototype.setKillSwitchTenants.\r\n// Removed Stub for KillSwitch.prototype.isTenantKilled.\r\n    // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n    // this will be removed when ES3 support is dropped.\n    KillSwitch.__ieDyn=1;\n\n    return KillSwitch;\r\n}());\r\nexport default KillSwitch;\r\n//# sourceMappingURL=KillSwitch.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* RetryPolicy.ts\r\n* @author Abhilash Panwar (abpanwar)\r\n* @copyright Microsoft 2018\r\n*/\r\nvar RandomizationLowerThreshold = 0.8;\r\nvar RandomizationUpperThreshold = 1.2;\r\nvar BaseBackoff = 3000;\r\nvar MaxBackoff = 600000;\r\n/**\r\n * Determine if the request should be retried for the given status code.\r\n * The below expression reads that we should only retry for:\r\n *      - HttpStatusCodes that are smaller than 300.\r\n *      - HttpStatusCodes greater or equal to 500 (except for 501-NotImplement\r\n *        and 505-HttpVersionNotSupport).\r\n *      - HttpStatusCode 408-RequestTimeout.\r\n *      - HttpStatusCode 429.\r\n * This is based on Microsoft.WindowsAzure.Storage.RetryPolicies.ExponentialRetry class\r\n * @param httpStatusCode - The status code returned for the request.\r\n * @returns True if request should be retried, false otherwise.\r\n */\r\nexport function retryPolicyShouldRetryForStatus(httpStatusCode) {\r\n    /* tslint:disable:triple-equals */\r\n    // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value\r\n    return !((httpStatusCode >= 300 && httpStatusCode < 500 && httpStatusCode != 408 && httpStatusCode != 429)\r\n        || (httpStatusCode == 501)\r\n        || (httpStatusCode == 505));\r\n    /* tslint:enable:triple-equals */\r\n}\r\n/**\r\n * Gets the number of milliseconds to back off before retrying the request. The\r\n * back off duration is exponentially scaled based on the number of retries already\r\n * done for the request.\r\n * @param retriesSoFar - The number of times the request has already been retried.\r\n * @returns The back off duration for the request before it can be retried.\r\n */\r\nexport function retryPolicyGetMillisToBackoffForRetry(retriesSoFar) {\r\n    var waitDuration = 0;\r\n    var minBackoff = BaseBackoff * RandomizationLowerThreshold;\r\n    var maxBackoff = BaseBackoff * RandomizationUpperThreshold;\r\n    var randomBackoff = Math.floor(Math.random() * (maxBackoff - minBackoff)) + minBackoff;\r\n    waitDuration = Math.pow(2, retriesSoFar) * randomBackoff;\r\n    return Math.min(waitDuration, MaxBackoff);\r\n}\r\n//# sourceMappingURL=RetryPolicy.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* Serializer.ts\r\n* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)\r\n* @copyright Microsoft 2018-2020\r\n*/\r\n// @skip-file-minify\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { arrIndexOf, doPerf, getCommonSchemaMetaData, getTenantId, isArray, isValueAssigned, objForEachKey, sanitizeProperty, strStartsWith } from \"@microsoft/1ds-core-js\";\r\nimport { EventBatch } from \"./EventBatch\";\r\nimport { STR_EMPTY } from \"./InternalConstants\";\r\n/**\r\n * Note: This is an optimization for V8-based browsers. When V8 concatenates a string,\r\n * the strings are only joined logically using a \"cons string\" or \"constructed/concatenated\r\n * string\". These containers keep references to one another and can result in very large\r\n * memory usage. For example, if a 2MB string is constructed by concatenating 4 bytes\r\n * together at a time, the memory usage will be ~44MB; so ~22x increase. The strings are\r\n * only joined together when an operation requiring their joining takes place, such as\r\n * substr(). This function is called when adding data to this buffer to ensure these\r\n * types of strings are periodically joined to reduce the memory footprint.\r\n * Setting to every 20 events as the JSON.stringify() may have joined many strings\r\n * and calling this too much causes a minor delay while processing.\r\n */\r\nvar _MAX_STRING_JOINS = 20;\r\nvar RequestSizeLimitBytes = 3984588; // approx 3.8 Mb\r\nvar BeaconRequestSizeLimitBytes = 65000; // approx 64kb (the current Edge, Firefox and Chrome max limit)\r\nvar MaxRecordSize = 2000000; // approx 2 Mb\r\nvar MaxBeaconRecordSize = Math.min(MaxRecordSize, BeaconRequestSizeLimitBytes);\r\nvar metadata = \"metadata\";\r\nvar f = \"f\";\r\nvar rCheckDot = /\\./;\r\n/**\r\n* Class to handle serialization of event and request.\r\n* Currently uses Bond for serialization. Please note that this may be subject to change.\r\n*/\r\nvar Serializer = /** @class */ (function () {\r\n    function Serializer(perfManager, valueSanitizer, stringifyObjects, enableCompoundKey) {\r\n        var strData = \"data\";\r\n        var strBaseData = \"baseData\";\r\n        var strExt = \"ext\";\r\n        var _checkForCompoundkey = !!enableCompoundKey;\r\n        var _processSubMetaData = true;\r\n        var _theSanitizer = valueSanitizer;\r\n        var _isReservedCache = {};\r\n        dynamicProto(Serializer, this, function (_self) {\r\n            _self.createPayload = function (retryCnt, isTeardown, isSync, isReducedPayload, sendReason, sendType) {\r\n                return {\r\n                    apiKeys: [],\r\n                    payloadBlob: STR_EMPTY,\r\n                    overflow: null,\r\n                    sizeExceed: [],\r\n                    failedEvts: [],\r\n                    batches: [],\r\n                    numEvents: 0,\r\n                    retryCnt: retryCnt,\r\n                    isTeardown: isTeardown,\r\n                    isSync: isSync,\r\n                    isBeacon: isReducedPayload,\r\n                    sendType: sendType,\r\n                    sendReason: sendReason\r\n                };\r\n            };\r\n            _self.appendPayload = function (payload, theBatch, maxEventsPerBatch) {\r\n                var canAddEvents = payload && theBatch && !payload.overflow;\r\n                if (canAddEvents) {\r\n                    doPerf(perfManager, function () { return \"Serializer:appendPayload\"; }, function () {\r\n                        var theEvents = theBatch.events();\r\n                        var payloadBlob = payload.payloadBlob;\r\n                        var payloadEvents = payload.numEvents;\r\n                        var eventsAdded = false;\r\n                        var sizeExceeded = [];\r\n                        var failedEvts = [];\r\n                        var isBeaconPayload = payload.isBeacon;\r\n                        var requestMaxSize = isBeaconPayload ? BeaconRequestSizeLimitBytes : RequestSizeLimitBytes;\r\n                        var recordMaxSize = isBeaconPayload ? MaxBeaconRecordSize : MaxRecordSize;\r\n                        var lp = 0;\r\n                        var joinCount = 0;\r\n                        while (lp < theEvents.length) {\r\n                            var theEvent = theEvents[lp];\r\n                            if (theEvent) {\r\n                                if (payloadEvents >= maxEventsPerBatch) {\r\n                                    // Maximum events per payload reached, so don't add any more\r\n                                    payload.overflow = theBatch.split(lp);\r\n                                    break;\r\n                                }\r\n                                var eventBlob = _self.getEventBlob(theEvent);\r\n                                if (eventBlob && eventBlob.length <= recordMaxSize) {\r\n                                    // This event will fit into the payload\r\n                                    var blobLength = eventBlob.length;\r\n                                    var currentSize = payloadBlob.length;\r\n                                    if (currentSize + blobLength > requestMaxSize) {\r\n                                        // Request or batch size exceeded, so don't add any more to the payload\r\n                                        payload.overflow = theBatch.split(lp);\r\n                                        break;\r\n                                    }\r\n                                    if (payloadBlob) {\r\n                                        payloadBlob += \"\\n\";\r\n                                    }\r\n                                    payloadBlob += eventBlob;\r\n                                    joinCount++;\r\n                                    // v8 memory optimization only\r\n                                    if (joinCount > _MAX_STRING_JOINS) {\r\n                                        // this substr() should cause the constructed string to join\r\n                                        payloadBlob.substr(0, 1);\r\n                                        joinCount = 0;\r\n                                    }\r\n                                    eventsAdded = true;\r\n                                    payloadEvents++;\r\n                                }\r\n                                else {\r\n                                    if (eventBlob) {\r\n                                        // Single event size exceeded so remove from the batch\r\n                                        sizeExceeded.push(theEvent);\r\n                                    }\r\n                                    else {\r\n                                        failedEvts.push(theEvent);\r\n                                    }\r\n                                    // We also need to remove this event from the existing array, otherwise a notification will be sent\r\n                                    // indicating that it was successfully sent\r\n                                    theEvents.splice(lp, 1);\r\n                                    lp--;\r\n                                }\r\n                            }\r\n                            lp++;\r\n                        }\r\n                        if (sizeExceeded && sizeExceeded.length > 0) {\r\n                            payload.sizeExceed.push(EventBatch.create(theBatch.iKey(), sizeExceeded));\r\n                            // Remove the exceeded events from the batch\r\n                        }\r\n                        if (failedEvts && failedEvts.length > 0) {\r\n                            payload.failedEvts.push(EventBatch.create(theBatch.iKey(), failedEvts));\r\n                            // Remove the failed events from the batch\r\n                        }\r\n                        if (eventsAdded) {\r\n                            payload.batches.push(theBatch);\r\n                            payload.payloadBlob = payloadBlob;\r\n                            payload.numEvents = payloadEvents;\r\n                            var apiKey = theBatch.iKey();\r\n                            if (arrIndexOf(payload.apiKeys, apiKey) === -1) {\r\n                                payload.apiKeys.push(apiKey);\r\n                            }\r\n                        }\r\n                    }, function () { return ({ payload: payload, theBatch: { iKey: theBatch.iKey(), evts: theBatch.events() }, max: maxEventsPerBatch }); });\r\n                }\r\n                return canAddEvents;\r\n            };\r\n            _self.getEventBlob = function (eventData) {\r\n                try {\r\n                    return doPerf(perfManager, function () { return \"Serializer.getEventBlob\"; }, function () {\r\n                        var serializedEvent = {};\r\n                        // Adding as dynamic keys for v8 performance\r\n                        serializedEvent.name = eventData.name;\r\n                        serializedEvent.time = eventData.time;\r\n                        serializedEvent.ver = eventData.ver;\r\n                        serializedEvent.iKey = \"o:\" + getTenantId(eventData.iKey);\r\n                        // Assigning local var so usage in part b/c don't throw if there is no ext\r\n                        var serializedExt = {};\r\n                        // Part A\r\n                        var eventExt = eventData[strExt];\r\n                        if (eventExt) {\r\n                            // Only assign ext if the event had one (There are tests covering this use case)\r\n                            serializedEvent[strExt] = serializedExt;\r\n                            objForEachKey(eventExt, function (key, value) {\r\n                                var data = serializedExt[key] = {};\r\n                                // Don't include a metadata callback as we don't currently set metadata Part A fields\r\n                                _processPathKeys(value, data, \"ext.\" + key, true, null, null, true);\r\n                            });\r\n                        }\r\n                        var serializedData = serializedEvent[strData] = {};\r\n                        serializedData.baseType = eventData.baseType;\r\n                        var serializedBaseData = serializedData[strBaseData] = {};\r\n                        // Part B\r\n                        _processPathKeys(eventData.baseData, serializedBaseData, strBaseData, false, [strBaseData], function (pathKeys, name, value) {\r\n                            _addJSONPropertyMetaData(serializedExt, pathKeys, name, value);\r\n                        }, _processSubMetaData);\r\n                        // Part C\r\n                        _processPathKeys(eventData.data, serializedData, strData, false, [], function (pathKeys, name, value) {\r\n                            _addJSONPropertyMetaData(serializedExt, pathKeys, name, value);\r\n                        }, _processSubMetaData);\r\n                        return JSON.stringify(serializedEvent);\r\n                    }, function () { return ({ item: eventData }); });\r\n                }\r\n                catch (e) {\r\n                    return null;\r\n                }\r\n            };\r\n            function _isReservedField(path, name) {\r\n                var result = _isReservedCache[path];\r\n                if (result === undefined) {\r\n                    if (path.length >= 7) {\r\n                        // Do not allow the changing of fields located in the ext.metadata or ext.web extension\r\n                        result = strStartsWith(path, \"ext.metadata\") || strStartsWith(path, \"ext.web\");\r\n                    }\r\n                    _isReservedCache[path] = result;\r\n                }\r\n                return result;\r\n            }\r\n            function _processPathKeys(srcObj, target, thePath, checkReserved, metadataPathKeys, metadataCallback, processSubKeys) {\r\n                objForEachKey(srcObj, function (key, srcValue) {\r\n                    var prop = null;\r\n                    if (srcValue || isValueAssigned(srcValue)) {\r\n                        var path = thePath;\r\n                        var name_1 = key;\r\n                        var theMetaPathKeys = metadataPathKeys;\r\n                        var destObj = target;\r\n                        // Handle keys with embedded '.', like \"TestObject.testProperty\"\r\n                        if (_checkForCompoundkey && !checkReserved && rCheckDot.test(key)) {\r\n                            var subKeys = key.split(\".\");\r\n                            var keyLen = subKeys.length;\r\n                            if (keyLen > 1) {\r\n                                if (theMetaPathKeys) {\r\n                                    // Create a copy of the meta path keys so we can add the extra ones\r\n                                    theMetaPathKeys = theMetaPathKeys.slice();\r\n                                }\r\n                                for (var lp = 0; lp < keyLen - 1; lp++) {\r\n                                    var subKey = subKeys[lp];\r\n                                    // Add/reuse the sub key object\r\n                                    destObj = destObj[subKey] = destObj[subKey] || {};\r\n                                    path += \".\" + subKey;\r\n                                    if (theMetaPathKeys) {\r\n                                        theMetaPathKeys.push(subKey);\r\n                                    }\r\n                                }\r\n                                name_1 = subKeys[keyLen - 1];\r\n                            }\r\n                        }\r\n                        var isReserved = checkReserved && _isReservedField(path, name_1);\r\n                        if (!isReserved && _theSanitizer && _theSanitizer.handleField(path, name_1)) {\r\n                            prop = _theSanitizer.value(path, name_1, srcValue, stringifyObjects);\r\n                        }\r\n                        else {\r\n                            prop = sanitizeProperty(name_1, srcValue, stringifyObjects);\r\n                        }\r\n                        if (prop) {\r\n                            // Set the value\r\n                            var newValue = prop.value;\r\n                            destObj[name_1] = newValue;\r\n                            if (metadataCallback) {\r\n                                metadataCallback(theMetaPathKeys, name_1, prop);\r\n                            }\r\n                            if (processSubKeys && typeof newValue === \"object\" && !isArray(newValue)) {\r\n                                var newPath = theMetaPathKeys;\r\n                                if (newPath) {\r\n                                    newPath = newPath.slice();\r\n                                    newPath.push(name_1);\r\n                                }\r\n                                // Make sure we process sub objects as well (for value sanitization and metadata)\r\n                                _processPathKeys(srcValue, newValue, path + \".\" + name_1, checkReserved, newPath, metadataCallback, processSubKeys);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n// Removed Stub for Serializer.prototype.createPayload.\r\n// Removed Stub for Serializer.prototype.appendPayload.\r\n// Removed Stub for Serializer.prototype.getEventBlob.\r\n// Removed Stub for Serializer.prototype.handleField.\r\n// Removed Stub for Serializer.prototype.getSanitizer.\r\n    // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n    // this will be removed when ES3 support is dropped.\n    Serializer.__ieDyn=1;\n\n    return Serializer;\r\n}());\r\nexport { Serializer };\r\n/**\r\n * @ignore\r\n */\r\nfunction _addJSONPropertyMetaData(json, propKeys, name, propertyValue) {\r\n    if (propertyValue && json) {\r\n        var encodedTypeValue = getCommonSchemaMetaData(propertyValue.value, propertyValue.kind, propertyValue.propertyType);\r\n        if (encodedTypeValue > -1) {\r\n            // Add the root metadata\r\n            var metaData = json[metadata];\r\n            if (!metaData) {\r\n                // Sets the root 'f'\r\n                metaData = json[metadata] = { f: {} };\r\n            }\r\n            var metaTarget = metaData[f];\r\n            if (!metaTarget) {\r\n                // This can occur if someone has manually added an ext.metadata object\r\n                // Such as ext.metadata.privLevel and ext.metadata.privTags\r\n                metaTarget = metaData[f] = {};\r\n            }\r\n            // Traverse the metadata path and build each object (contains an 'f' key) -- if required\r\n            if (propKeys) {\r\n                for (var lp = 0; lp < propKeys.length; lp++) {\r\n                    var key = propKeys[lp];\r\n                    if (!metaTarget[key]) {\r\n                        metaTarget[key] = { f: {} };\r\n                    }\r\n                    var newTarget = metaTarget[key][f];\r\n                    if (!newTarget) {\r\n                        // Not expected, but can occur if the metadata context was pre-created as part of the event\r\n                        newTarget = metaTarget[key][f] = {};\r\n                    }\r\n                    metaTarget = newTarget;\r\n                }\r\n            }\r\n            metaTarget = metaTarget[name] = {};\r\n            if (isArray(propertyValue.value)) {\r\n                metaTarget[\"a\"] = {\r\n                    t: encodedTypeValue\r\n                };\r\n            }\r\n            else {\r\n                metaTarget[\"t\"] = encodedTypeValue;\r\n            }\r\n        }\r\n    }\r\n}\r\n//# sourceMappingURL=Serializer.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\nvar _a;\r\n/**\r\n* HttpManager.ts\r\n* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)\r\n* @copyright Microsoft 2018-2020\r\n*/\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport EVTClockSkewManager from \"./ClockSkewManager\";\r\nimport EVTKillSwitch from \"./KillSwitch\";\r\nimport { FullVersionString, _throwInternal, _warnToConsole, arrForEach, dateNow, doPerf, dumpObj, extend, getLocation, getNavigator, getTime, hasOwnProperty, isArray, isBeaconsSupported, isFetchSupported, isNullOrUndefined, isNumber, isReactNative, isString, isUndefined, isValueAssigned, isXhrSupported, objForEachKey, objKeys, openXhr, strTrim, strUndefined, useXDomainRequest } from \"@microsoft/1ds-core-js\";\r\nimport { DEFAULT_CACHE_CONTROL, DEFAULT_CONTENT_TYPE, STR_API_KEY, STR_AUTH_XTOKEN, STR_CACHE_CONTROL, STR_CLIENT_ID, STR_CLIENT_VERSION, STR_CONTENT_TYPE_HEADER, STR_DISABLED_PROPERTY_NAME, STR_DROPPED, STR_EMPTY, STR_KILL_DURATION_HEADER, STR_KILL_DURATION_SECONDS_HEADER, STR_KILL_TOKENS_HEADER, STR_MSA_DEVICE_TICKET, STR_MSFPC, STR_NO_RESPONSE_BODY, STR_OTHER, STR_POST_METHOD, STR_REQUEUE, STR_RESPONSE_FAIL, STR_SENDING, STR_TIME_DELTA_HEADER, STR_TIME_DELTA_TO_APPLY, STR_UPLOAD_TIME } from \"./InternalConstants\";\r\nimport { retryPolicyGetMillisToBackoffForRetry, retryPolicyShouldRetryForStatus } from \"./RetryPolicy\";\r\nimport { Serializer } from \"./Serializer\";\r\nvar strSendAttempt = \"sendAttempt\";\r\nvar _noResponseQs = \"&\" + STR_NO_RESPONSE_BODY + \"=true\";\r\n/**\r\n * Identifies the default notification reason to the action names\r\n */\r\nvar _eventActionMap = (_a = {},\r\n    _a[1 /* EventBatchNotificationReason.Paused */] = STR_REQUEUE,\r\n    _a[100 /* EventBatchNotificationReason.RequeueEvents */] = STR_REQUEUE,\r\n    _a[200 /* EventBatchNotificationReason.Complete */] = \"sent\",\r\n    _a[8004 /* EventBatchNotificationReason.KillSwitch */] = STR_DROPPED,\r\n    _a[8003 /* EventBatchNotificationReason.SizeLimitExceeded */] = STR_DROPPED,\r\n    _a);\r\nvar _collectorQsHeaders = {};\r\nvar _collectorHeaderToQs = {};\r\nfunction _addCollectorHeaderQsMapping(qsName, headerName, allowQs) {\r\n    _collectorQsHeaders[qsName] = headerName;\r\n    if (allowQs !== false) {\r\n        _collectorHeaderToQs[headerName] = qsName;\r\n    }\r\n}\r\n_addCollectorHeaderQsMapping(STR_MSA_DEVICE_TICKET, STR_MSA_DEVICE_TICKET, false);\r\n_addCollectorHeaderQsMapping(STR_CLIENT_VERSION, STR_CLIENT_VERSION);\r\n_addCollectorHeaderQsMapping(STR_CLIENT_ID, \"Client-Id\");\r\n_addCollectorHeaderQsMapping(STR_API_KEY, STR_API_KEY);\r\n_addCollectorHeaderQsMapping(STR_TIME_DELTA_TO_APPLY, STR_TIME_DELTA_TO_APPLY);\r\n_addCollectorHeaderQsMapping(STR_UPLOAD_TIME, STR_UPLOAD_TIME);\r\n_addCollectorHeaderQsMapping(STR_AUTH_XTOKEN, STR_AUTH_XTOKEN);\r\nfunction _getResponseText(xhr) {\r\n    try {\r\n        return xhr.responseText;\r\n    }\r\n    catch (e) {\r\n        // Best effort, as XHR may throw while XDR wont so just ignore\r\n    }\r\n    return STR_EMPTY;\r\n}\r\nfunction _hasHeader(headers, header) {\r\n    var hasHeader = false;\r\n    if (headers && header) {\r\n        var keys = objKeys(headers);\r\n        if (keys && keys.length > 0) {\r\n            var lowerHeader = header.toLowerCase();\r\n            for (var lp = 0; lp < keys.length; lp++) {\r\n                var value = keys[lp];\r\n                if (value && hasOwnProperty(header, value) &&\r\n                    value.toLowerCase() === lowerHeader) {\r\n                    hasHeader = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return hasHeader;\r\n}\r\nfunction _addRequestDetails(details, name, value, useHeaders) {\r\n    if (name && value && value.length > 0) {\r\n        if (useHeaders && _collectorQsHeaders[name]) {\r\n            details.hdrs[_collectorQsHeaders[name]] = value;\r\n            details.useHdrs = true;\r\n        }\r\n        else {\r\n            details.url += \"&\" + name + \"=\" + value;\r\n        }\r\n    }\r\n}\r\nfunction _prependTransports(theTransports, newTransports) {\r\n    if (newTransports) {\r\n        if (isNumber(newTransports)) {\r\n            theTransports = [newTransports].concat(theTransports);\r\n        }\r\n        else if (isArray(newTransports)) {\r\n            theTransports = newTransports.concat(theTransports);\r\n        }\r\n    }\r\n    return theTransports;\r\n}\r\n/**\r\n * Class managing the sending of requests.\r\n */\r\nvar HttpManager = /** @class */ (function () {\r\n    /**\r\n     * @constructor\r\n     * @param requestQueue   - The queue that contains the requests to be sent.\r\n     */\r\n    function HttpManager(maxEventsPerBatch, maxConnections, maxRequestRetriesBeforeBackoff, actions, timeoutOverride) {\r\n        this._responseHandlers = [];\r\n        var _urlString = \"?cors=true&\" + STR_CONTENT_TYPE_HEADER.toLowerCase() + \"=\" + DEFAULT_CONTENT_TYPE;\r\n        var _killSwitch = new EVTKillSwitch();\r\n        var _paused = false;\r\n        var _clockSkewManager = new EVTClockSkewManager();\r\n        var _useBeacons = false;\r\n        var _outstandingRequests = 0; // Holds the number of outstanding async requests that have not returned a response yet\r\n        var _postManager;\r\n        var _logger;\r\n        var _sendInterfaces;\r\n        var _core;\r\n        var _customHttpInterface = true;\r\n        var _queryStringParameters = [];\r\n        var _headers = {};\r\n        var _batchQueue = [];\r\n        var _serializer = null;\r\n        var _enableEventTimings = false;\r\n        var _cookieMgr;\r\n        var _isUnloading = false;\r\n        var _useHeaders = false;\r\n        var _xhrTimeout;\r\n        var _disableXhrSync;\r\n        var _disableFetchKeepAlive;\r\n        var _canHaveReducedPayload;\r\n        var _addNoResponse;\r\n        dynamicProto(HttpManager, this, function (_self) {\r\n            var _sendCredentials = true;\r\n            _self.initialize = function (endpointUrl, core, postChannel, httpInterface, channelConfig) {\r\n                var _a;\r\n                if (!channelConfig) {\r\n                    channelConfig = {};\r\n                }\r\n                _urlString = endpointUrl + _urlString;\r\n                _useHeaders = !isUndefined(channelConfig.avoidOptions) ? !channelConfig.avoidOptions : true;\r\n                _core = core;\r\n                _cookieMgr = core.getCookieMgr();\r\n                _enableEventTimings = !_core.config.disableEventTimings;\r\n                var enableCompoundKey = !!_core.config.enableCompoundKey;\r\n                _postManager = postChannel;\r\n                _logger = _postManager.diagLog();\r\n                var valueSanitizer = channelConfig.valueSanitizer;\r\n                var stringifyObjects = channelConfig.stringifyObjects;\r\n                if (!isUndefined(channelConfig.enableCompoundKey)) {\r\n                    enableCompoundKey = !!channelConfig.enableCompoundKey;\r\n                }\r\n                _xhrTimeout = channelConfig.xhrTimeout;\r\n                _disableXhrSync = !!channelConfig.disableXhrSync;\r\n                _disableFetchKeepAlive = !!channelConfig.disableFetchKeepAlive;\r\n                _addNoResponse = channelConfig.addNoResponse !== false;\r\n                _useBeacons = !isReactNative(); // Only use beacons if not running in React Native\r\n                _serializer = new Serializer(_core, valueSanitizer, stringifyObjects, enableCompoundKey);\r\n                if (!isNullOrUndefined(channelConfig.useSendBeacon)) {\r\n                    _useBeacons = !!channelConfig.useSendBeacon;\r\n                }\r\n                var syncHttpInterface = httpInterface;\r\n                var beaconHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null;\r\n                var fetchSyncHttpInterface = channelConfig.alwaysUseXhrOverride ? httpInterface : null;\r\n                var beaconUnloadTransports = [3 /* TransportType.Beacon */, 2 /* TransportType.Fetch */];\r\n                if (!httpInterface) {\r\n                    _customHttpInterface = false;\r\n                    var location_1 = getLocation();\r\n                    if (location_1 && location_1.protocol && location_1.protocol.toLowerCase() === \"file:\") {\r\n                        // Special case where a local html file fails with a CORS error on Chromium browsers\r\n                        _sendCredentials = false;\r\n                    }\r\n                    var theTransports = [];\r\n                    if (isReactNative()) {\r\n                        // Use Fetch or XDR/XHR\r\n                        theTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */];\r\n                        beaconUnloadTransports = [2 /* TransportType.Fetch */, 1 /* TransportType.Xhr */, 3 /* TransportType.Beacon */];\r\n                    }\r\n                    else {\r\n                        // Use XDR/XHR, Fetch or beacons\r\n                        theTransports = [1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */];\r\n                    }\r\n                    // Prefix any user requested transport(s) values\r\n                    theTransports = _prependTransports(theTransports, channelConfig.transports);\r\n                    httpInterface = _getSenderInterface(theTransports, false);\r\n                    if (!httpInterface) {\r\n                        _warnToConsole(_logger, \"No available transport to send events\");\r\n                    }\r\n                    syncHttpInterface = _getSenderInterface(theTransports, true);\r\n                }\r\n                if (!beaconHttpInterface) {\r\n                    // Allow overriding the usage of sendBeacon\r\n                    beaconUnloadTransports = _prependTransports(beaconUnloadTransports, channelConfig.unloadTransports);\r\n                    beaconHttpInterface = _getSenderInterface(beaconUnloadTransports, true);\r\n                }\r\n                _canHaveReducedPayload = !_customHttpInterface && ((_useBeacons && isBeaconsSupported()) || (!_disableFetchKeepAlive && isFetchSupported(true)));\r\n                _sendInterfaces = (_a = {},\r\n                    _a[0 /* EventSendType.Batched */] = httpInterface,\r\n                    _a[1 /* EventSendType.Synchronous */] = syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */, 2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true),\r\n                    _a[2 /* EventSendType.SendBeacon */] = beaconHttpInterface || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),\r\n                    _a[3 /* EventSendType.SyncFetch */] = fetchSyncHttpInterface || _getSenderInterface([2 /* TransportType.Fetch */, 3 /* TransportType.Beacon */], true) || syncHttpInterface || _getSenderInterface([1 /* TransportType.Xhr */], true),\r\n                    _a);\r\n            };\r\n            // Special internal method to allow the DebugPlugin to hook embedded objects\r\n            function _getSenderInterface(transports, syncSupport) {\r\n                var transportType = 0 /* TransportType.NotSet */;\r\n                var sendPostFunc = null;\r\n                var lp = 0;\r\n                while (sendPostFunc == null && lp < transports.length) {\r\n                    transportType = transports[lp];\r\n                    if (transportType === 1 /* TransportType.Xhr */) {\r\n                        if (useXDomainRequest()) {\r\n                            sendPostFunc = _xdrSendPost;\r\n                        }\r\n                        else if (isXhrSupported()) {\r\n                            sendPostFunc = _xhrSendPost;\r\n                        }\r\n                    }\r\n                    else if (transportType === 2 /* TransportType.Fetch */ && isFetchSupported(syncSupport) && (!syncSupport || (syncSupport && !_disableFetchKeepAlive))) {\r\n                        sendPostFunc = _fetchSendPost;\r\n                    }\r\n                    else if (_useBeacons && transportType === 3 /* TransportType.Beacon */ && isBeaconsSupported()) {\r\n                        sendPostFunc = _beaconSendPost;\r\n                    }\r\n                    lp++;\r\n                }\r\n                if (sendPostFunc) {\r\n                    return {\r\n                        _transport: transportType,\r\n                        _isSync: syncSupport,\r\n                        sendPOST: sendPostFunc\r\n                    };\r\n                }\r\n                return null;\r\n            }\r\n            _self[\"_getDbgPlgTargets\"] = function () {\r\n                return [_sendInterfaces[0 /* EventSendType.Batched */], _killSwitch, _serializer, _sendInterfaces];\r\n            };\r\n            function _xdrSendPost(payload, oncomplete, sync) {\r\n                // It doesn't support custom headers, so no action is taken with current requestHeaders\r\n                var xdr = new XDomainRequest();\r\n                xdr.open(STR_POST_METHOD, payload.urlString);\r\n                if (payload.timeout) {\r\n                    xdr.timeout = payload.timeout;\r\n                }\r\n                // can't get the status code in xdr.\r\n                xdr.onload = function () {\r\n                    // we will assume onload means the request succeeded.\r\n                    var response = _getResponseText(xdr);\r\n                    _doOnComplete(oncomplete, 200, {}, response);\r\n                    _handleCollectorResponse(response);\r\n                };\r\n                // we will assume onerror means we need to drop the events.\r\n                xdr.onerror = function () {\r\n                    _doOnComplete(oncomplete, 400, {});\r\n                };\r\n                // we will assume ontimeout means we need to retry the events.\r\n                xdr.ontimeout = function () {\r\n                    _doOnComplete(oncomplete, 500, {});\r\n                };\r\n                // https://cypressnorth.com/web-programming-and-development/internet-explorer-aborting-ajax-requests-fixed/\r\n                // tslint:disable-next-line:no-empty\r\n                xdr.onprogress = function () { };\r\n                if (sync) {\r\n                    xdr.send(payload.data);\r\n                }\r\n                else {\r\n                    timeoutOverride.set(function () {\r\n                        xdr.send(payload.data);\r\n                    }, 0);\r\n                }\r\n            }\r\n            function _fetchSendPost(payload, oncomplete, sync) {\r\n                var _a;\r\n                var theUrl = payload.urlString;\r\n                var ignoreResponse = false;\r\n                var responseHandled = false;\r\n                var requestInit = (_a = {\r\n                        body: payload.data,\r\n                        method: STR_POST_METHOD\r\n                    },\r\n                    _a[STR_DISABLED_PROPERTY_NAME] = true,\r\n                    _a);\r\n                if (sync) {\r\n                    requestInit.keepalive = true;\r\n                    if (payload._sendReason === 2 /* SendRequestReason.Unload */) {\r\n                        // As a sync request (during unload), it is unlikely that we will get a chance to process the response so\r\n                        // just like beacon send assume that the events have been accepted and processed\r\n                        ignoreResponse = true;\r\n                        if (_addNoResponse) {\r\n                            theUrl += _noResponseQs;\r\n                        }\r\n                    }\r\n                }\r\n                if (_sendCredentials) {\r\n                    // Don't send credentials when URL is file://\r\n                    requestInit.credentials = \"include\";\r\n                }\r\n                // Only add headers if there are headers to add, due to issue with some polyfills\r\n                if (payload.headers && objKeys(payload.headers).length > 0) {\r\n                    requestInit.headers = payload.headers;\r\n                }\r\n                fetch(theUrl, requestInit).then(function (response) {\r\n                    var headerMap = {};\r\n                    var responseText = STR_EMPTY;\r\n                    var headers = response.headers;\r\n                    if (headers) {\r\n                        headers[\"forEach\"](function (value, name) {\r\n                            headerMap[name] = value;\r\n                        });\r\n                    }\r\n                    if (response.body) {\r\n                        response.text().then(function (text) {\r\n                            responseText = text;\r\n                        });\r\n                    }\r\n                    if (!responseHandled) {\r\n                        responseHandled = true;\r\n                        _doOnComplete(oncomplete, response.status, headerMap, responseText);\r\n                        _handleCollectorResponse(responseText);\r\n                    }\r\n                })[\"catch\"](function (error) {\r\n                    // In case there is an error in the request. Set the status to 0\r\n                    // so that the events can be retried later.\r\n                    if (!responseHandled) {\r\n                        responseHandled = true;\r\n                        _doOnComplete(oncomplete, 0, {});\r\n                    }\r\n                });\r\n                if (ignoreResponse && !responseHandled) {\r\n                    // Assume success during unload processing\r\n                    responseHandled = true;\r\n                    _doOnComplete(oncomplete, 200, {});\r\n                }\r\n                if (!responseHandled && payload.timeout > 0) {\r\n                    // Simulate timeout\r\n                    timeoutOverride.set(function () {\r\n                        if (!responseHandled) {\r\n                            // Assume a 500 response (which will cause a retry)\r\n                            responseHandled = true;\r\n                            _doOnComplete(oncomplete, 500, {});\r\n                        }\r\n                    }, payload.timeout);\r\n                }\r\n            }\r\n            function _xhrSendPost(payload, oncomplete, sync) {\r\n                var theUrl = payload.urlString;\r\n                function _appendHeader(theHeaders, xhr, name) {\r\n                    if (!theHeaders[name] && xhr && xhr.getResponseHeader) {\r\n                        var value = xhr.getResponseHeader(name);\r\n                        if (value) {\r\n                            theHeaders[name] = strTrim(value);\r\n                        }\r\n                    }\r\n                    return theHeaders;\r\n                }\r\n                function _getAllResponseHeaders(xhr) {\r\n                    var theHeaders = {};\r\n                    if (!xhr.getAllResponseHeaders) {\r\n                        // Firefox 2-63 doesn't have getAllResponseHeaders function but it does have getResponseHeader\r\n                        // Only call these if getAllResponseHeaders doesn't exist, otherwise we can get invalid response errors\r\n                        // as collector is not currently returning the correct header to allow JS to access these headers\r\n                        theHeaders = _appendHeader(theHeaders, xhr, STR_TIME_DELTA_HEADER);\r\n                        theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_HEADER);\r\n                        theHeaders = _appendHeader(theHeaders, xhr, STR_KILL_DURATION_SECONDS_HEADER);\r\n                    }\r\n                    else {\r\n                        theHeaders = _convertAllHeadersToMap(xhr.getAllResponseHeaders());\r\n                    }\r\n                    return theHeaders;\r\n                }\r\n                function xhrComplete(xhr, responseTxt) {\r\n                    _doOnComplete(oncomplete, xhr.status, _getAllResponseHeaders(xhr), responseTxt);\r\n                }\r\n                if (sync && payload.disableXhrSync) {\r\n                    sync = false;\r\n                }\r\n                var xhrRequest = openXhr(STR_POST_METHOD, theUrl, _sendCredentials, true, sync, payload.timeout);\r\n                // Set custom headers (e.g. gzip) here (after open())\r\n                objForEachKey(payload.headers, function (name, value) {\r\n                    xhrRequest.setRequestHeader(name, value);\r\n                });\r\n                xhrRequest.onload = function () {\r\n                    var response = _getResponseText(xhrRequest);\r\n                    xhrComplete(xhrRequest, response);\r\n                    _handleCollectorResponse(response);\r\n                };\r\n                xhrRequest.onerror = function () {\r\n                    xhrComplete(xhrRequest);\r\n                };\r\n                xhrRequest.ontimeout = function () {\r\n                    xhrComplete(xhrRequest);\r\n                };\r\n                xhrRequest.send(payload.data);\r\n            }\r\n            function _doOnComplete(oncomplete, status, headers, response) {\r\n                try {\r\n                    oncomplete(status, headers, response);\r\n                }\r\n                catch (e) {\r\n                    _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 518 /* _eExtendedInternalMessageId.SendPostOnCompleteFailure */, dumpObj(e));\r\n                }\r\n            }\r\n            function _beaconSendPost(payload, oncomplete, sync) {\r\n                // Custom headers not supported in sendBeacon payload.headers would be ignored\r\n                var internalPayloadData = payload;\r\n                var status = 200;\r\n                var thePayload = internalPayloadData._thePayload;\r\n                var theUrl = payload.urlString + (_addNoResponse ? _noResponseQs : STR_EMPTY);\r\n                try {\r\n                    var nav_1 = getNavigator();\r\n                    if (!nav_1.sendBeacon(theUrl, payload.data)) {\r\n                        if (thePayload) {\r\n                            // Failed to send entire payload so try and split data and try to send as much events as possible\r\n                            var droppedBatches_1 = [];\r\n                            arrForEach(thePayload.batches, function (theBatch) {\r\n                                if (droppedBatches_1 && theBatch && theBatch.count() > 0) {\r\n                                    var theEvents = theBatch.events();\r\n                                    for (var lp = 0; lp < theEvents.length; lp++) {\r\n                                        if (!nav_1.sendBeacon(theUrl, _serializer.getEventBlob(theEvents[lp]))) {\r\n                                            // Can't send anymore, so split the batch and drop the rest\r\n                                            droppedBatches_1.push(theBatch.split(lp));\r\n                                            break;\r\n                                        }\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    // Remove all of the events from the existing batch in the payload as the copy includes the original\r\n                                    droppedBatches_1.push(theBatch.split(0));\r\n                                }\r\n                            });\r\n                            _sendBatchesNotification(droppedBatches_1, 8003 /* EventBatchNotificationReason.SizeLimitExceeded */, thePayload.sendType, true);\r\n                        }\r\n                        else {\r\n                            status = 0;\r\n                        }\r\n                    }\r\n                }\r\n                catch (ex) {\r\n                    _warnToConsole(_logger, \"Failed to send telemetry using sendBeacon API. Ex:\" + dumpObj(ex));\r\n                    status = 0;\r\n                }\r\n                finally {\r\n                    _doOnComplete(oncomplete, status, {}, STR_EMPTY);\r\n                }\r\n            }\r\n            function _isBeaconPayload(sendType) {\r\n                // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit, so treat both as a beacon send\r\n                return sendType === 2 /* EventSendType.SendBeacon */ || sendType === 3 /* EventSendType.SyncFetch */;\r\n            }\r\n            function _adjustSendType(sendType) {\r\n                if (_isUnloading && _isBeaconPayload(sendType)) {\r\n                    sendType = 2 /* EventSendType.SendBeacon */;\r\n                }\r\n                return sendType;\r\n            }\r\n            _self.addQueryStringParameter = function (name, value) {\r\n                for (var i = 0; i < _queryStringParameters.length; i++) {\r\n                    if (_queryStringParameters[i].name === name) {\r\n                        _queryStringParameters[i].value = value;\r\n                        return;\r\n                    }\r\n                }\r\n                _queryStringParameters.push({ name: name, value: value });\r\n            };\r\n            _self.addHeader = function (name, value) {\r\n                _headers[name] = value;\r\n            };\r\n            _self.canSendRequest = function () {\r\n                return _hasIdleConnection() && _clockSkewManager.allowRequestSending();\r\n            };\r\n            _self.sendQueuedRequests = function (sendType, sendReason) {\r\n                if (isUndefined(sendType)) {\r\n                    sendType = 0 /* EventSendType.Batched */;\r\n                }\r\n                if (_isUnloading) {\r\n                    sendType = _adjustSendType(sendType);\r\n                    sendReason = 2 /* SendRequestReason.Unload */;\r\n                }\r\n                if (_canSendPayload(_batchQueue, sendType, 0)) {\r\n                    _sendBatches(_clearQueue(), 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);\r\n                }\r\n            };\r\n            _self.isCompletelyIdle = function () {\r\n                return !_paused && _outstandingRequests === 0 && _batchQueue.length === 0;\r\n            };\r\n            _self.setUnloading = function (value) {\r\n                _isUnloading = value;\r\n            };\r\n            _self.addBatch = function (theBatch) {\r\n                if (theBatch && theBatch.count() > 0) {\r\n                    // Try and kill the event faster\r\n                    if (_killSwitch.isTenantKilled(theBatch.iKey())) {\r\n                        return false;\r\n                    }\r\n                    _batchQueue.push(theBatch);\r\n                }\r\n                return true;\r\n            };\r\n            /**\r\n             * Queue all the remaining requests to be sent. The requests will be\r\n             * sent using HTML5 Beacons if they are available.\r\n             */\r\n            _self.teardown = function () {\r\n                if (_batchQueue.length > 0) {\r\n                    _sendBatches(_clearQueue(), 0, true, 2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);\r\n                }\r\n            };\r\n            /**\r\n             * Pause the sending of requests. No new requests will be sent.\r\n             */\r\n            _self.pause = function () {\r\n                _paused = true;\r\n            };\r\n            /**\r\n             * Resume the sending of requests.\r\n             */\r\n            _self.resume = function () {\r\n                _paused = false;\r\n                _self.sendQueuedRequests(0 /* EventSendType.Batched */, 4 /* SendRequestReason.Resumed */);\r\n            };\r\n            /**\r\n             * Sends a request synchronously to the Aria collector. This api is used to send\r\n             * a request containing a single immediate event.\r\n             *\r\n             * @param batch - The request to be sent.\r\n             * @param sendReason   - The token used to send the request.\r\n             */\r\n            _self.sendSynchronousBatch = function (batch, sendType, sendReason) {\r\n                // This will not take into account the max connections restriction. Since this is sync, we can\r\n                // only send one of this request at a time and thus should not worry about multiple connections\r\n                // being used to send synchronous events.\r\n                // Increment active connection since we are still going to use a connection to send the request.\r\n                if (batch && batch.count() > 0) {\r\n                    if (isNullOrUndefined(sendType)) {\r\n                        sendType = 1 /* EventSendType.Synchronous */;\r\n                    }\r\n                    if (_isUnloading) {\r\n                        sendType = _adjustSendType(sendType);\r\n                        sendReason = 2 /* SendRequestReason.Unload */;\r\n                    }\r\n                    // For sync requests we will not wait for the clock skew.\r\n                    _sendBatches([batch], 0, false, sendType, sendReason || 0 /* SendRequestReason.Undefined */);\r\n                }\r\n            };\r\n            function _hasIdleConnection() {\r\n                return !_paused && _outstandingRequests < maxConnections;\r\n            }\r\n            function _clearQueue() {\r\n                var theQueue = _batchQueue;\r\n                _batchQueue = [];\r\n                return theQueue;\r\n            }\r\n            function _canSendPayload(theBatches, sendType, retryCnt) {\r\n                var result = false;\r\n                if (theBatches && theBatches.length > 0 && !_paused && _sendInterfaces[sendType] && _serializer) {\r\n                    // Always attempt to send synchronous events don't wait for idle or clockSkew\r\n                    // and don't block retry requests if clockSkew is not yet set\r\n                    result = (sendType !== 0 /* EventSendType.Batched */) || (_hasIdleConnection() && (retryCnt > 0 || _clockSkewManager.allowRequestSending()));\r\n                }\r\n                return result;\r\n            }\r\n            function _createDebugBatches(theBatches) {\r\n                var values = {};\r\n                if (theBatches) {\r\n                    arrForEach(theBatches, function (theBatch, idx) {\r\n                        values[idx] = {\r\n                            iKey: theBatch.iKey(),\r\n                            evts: theBatch.events()\r\n                        };\r\n                    });\r\n                }\r\n                return values;\r\n            }\r\n            function _sendBatches(theBatches, retryCount, isTeardown, sendType, sendReason) {\r\n                if (!theBatches || theBatches.length === 0) {\r\n                    // Nothing to do\r\n                    return;\r\n                }\r\n                if (_paused) {\r\n                    _sendBatchesNotification(theBatches, 1 /* EventBatchNotificationReason.Paused */, sendType);\r\n                    return;\r\n                }\r\n                // Make sure that if we are unloading the sendType is a supported version\r\n                sendType = _adjustSendType(sendType);\r\n                try {\r\n                    var orgBatches_1 = theBatches;\r\n                    var isSynchronous_1 = sendType !== 0 /* EventSendType.Batched */;\r\n                    doPerf(_core, function () { return \"HttpManager:_sendBatches\"; }, function (perfEvt) {\r\n                        if (perfEvt) {\r\n                            // Perf Monitoring is enabled, so create a \"Quick\" copy of the original batches so we still report\r\n                            // the original values as part of the perfEvent. This is because theBatches uses .shift() to remove each\r\n                            // batch as they are processed - removing from the original array, so by the time the _createDebugBatches()\r\n                            // function is called the passed in value has changed and therefore the reported value for the perfEvent is incorrect\r\n                            theBatches = theBatches.slice(0);\r\n                        }\r\n                        var droppedBatches = [];\r\n                        var thePayload = null;\r\n                        var serializationStart = getTime();\r\n                        var sendInterface = _sendInterfaces[sendType] || (isSynchronous_1 ? _sendInterfaces[1 /* EventSendType.Synchronous */] : _sendInterfaces[0 /* EventSendType.Batched */]);\r\n                        var sendTransport = sendInterface && sendInterface._transport;\r\n                        // Sync Fetch has the same payload limitation as sendBeacon -- 64kb limit\r\n                        var isReducedPayload = _canHaveReducedPayload && (_isUnloading || _isBeaconPayload(sendType) || (sendTransport === 3 /* TransportType.Beacon */ || (sendInterface._isSync && sendTransport === 2 /* TransportType.Fetch */)));\r\n                        while (_canSendPayload(theBatches, sendType, retryCount)) {\r\n                            var theBatch = theBatches.shift();\r\n                            if (theBatch && theBatch.count() > 0) {\r\n                                if (!_killSwitch.isTenantKilled(theBatch.iKey())) {\r\n                                    // Make sure we have a payload object\r\n                                    thePayload = thePayload || _serializer.createPayload(retryCount, isTeardown, isSynchronous_1, isReducedPayload, sendReason, sendType);\r\n                                    // Add the batch to the current payload\r\n                                    if (!_serializer.appendPayload(thePayload, theBatch, maxEventsPerBatch)) {\r\n                                        // Entire batch was not added so send the payload and retry adding this batch\r\n                                        _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);\r\n                                        serializationStart = getTime();\r\n                                        theBatches = [theBatch].concat(theBatches);\r\n                                        thePayload = null;\r\n                                    }\r\n                                    else if (thePayload.overflow !== null) {\r\n                                        // Total Payload size was exceeded so send the payload and add the unsent as the next batch to send\r\n                                        theBatches = [thePayload.overflow].concat(theBatches);\r\n                                        thePayload.overflow = null;\r\n                                        _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);\r\n                                        serializationStart = getTime();\r\n                                        thePayload = null;\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    droppedBatches.push(theBatch);\r\n                                }\r\n                            }\r\n                        }\r\n                        // Make sure to flush any remaining payload\r\n                        if (thePayload) {\r\n                            _doPayloadSend(thePayload, serializationStart, getTime(), sendReason);\r\n                        }\r\n                        if (theBatches.length > 0) {\r\n                            // Add any unsent batches back to the head of the queue\r\n                            _batchQueue = theBatches.concat(_batchQueue);\r\n                        }\r\n                        // Now send notification about any dropped events\r\n                        _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, sendType);\r\n                    }, function () { return ({ batches: _createDebugBatches(orgBatches_1), retryCount: retryCount, isTeardown: isTeardown, isSynchronous: isSynchronous_1, sendReason: sendReason, useSendBeacon: _isBeaconPayload(sendType), sendType: sendType }); }, !isSynchronous_1);\r\n                }\r\n                catch (ex) {\r\n                    _throwInternal(_logger, 2 /* eLoggingSeverity.WARNING */, 48 /* _eInternalMessageId.CannotSerializeObject */, \"Unexpected Exception sending batch: \" + dumpObj(ex));\r\n                }\r\n            }\r\n            function _buildRequestDetails(thePayload, useHeaders) {\r\n                var requestDetails = {\r\n                    url: _urlString,\r\n                    hdrs: {},\r\n                    useHdrs: false // Assume no headers\r\n                };\r\n                if (!useHeaders) {\r\n                    // Attempt to map headers to a query string if possible\r\n                    objForEachKey(_headers, function (name, value) {\r\n                        if (_collectorHeaderToQs[name]) {\r\n                            _addRequestDetails(requestDetails, _collectorHeaderToQs[name], value, false);\r\n                        }\r\n                        else {\r\n                            // No mapping, so just include in the headers anyway (may not get sent if using sendBeacon())\r\n                            requestDetails.hdrs[name] = value;\r\n                            requestDetails.useHdrs = true;\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // Copy the pre-defined headers into the payload headers\r\n                    requestDetails.hdrs = extend(requestDetails.hdrs, _headers);\r\n                    requestDetails.useHdrs = (objKeys(requestDetails.hdrs).length > 0);\r\n                }\r\n                _addRequestDetails(requestDetails, STR_CLIENT_ID, \"NO_AUTH\", useHeaders);\r\n                _addRequestDetails(requestDetails, STR_CLIENT_VERSION, FullVersionString, useHeaders);\r\n                var apiQsKeys = STR_EMPTY;\r\n                arrForEach(thePayload.apiKeys, function (apiKey) {\r\n                    if (apiQsKeys.length > 0) {\r\n                        apiQsKeys += \",\";\r\n                    }\r\n                    apiQsKeys += apiKey;\r\n                });\r\n                _addRequestDetails(requestDetails, STR_API_KEY, apiQsKeys, useHeaders);\r\n                _addRequestDetails(requestDetails, STR_UPLOAD_TIME, dateNow().toString(), useHeaders);\r\n                var msfpc = _getMsfpc(thePayload);\r\n                if (isValueAssigned(msfpc)) {\r\n                    requestDetails.url += \"&ext.intweb.msfpc=\" + msfpc;\r\n                }\r\n                if (_clockSkewManager.shouldAddClockSkewHeaders()) {\r\n                    _addRequestDetails(requestDetails, STR_TIME_DELTA_TO_APPLY, _clockSkewManager.getClockSkewHeaderValue(), useHeaders);\r\n                }\r\n                if (_core.getWParam) {\r\n                    var wParam = _core.getWParam();\r\n                    if (wParam >= 0) {\r\n                        requestDetails.url += \"&w=\" + wParam;\r\n                    }\r\n                }\r\n                for (var i = 0; i < _queryStringParameters.length; i++) {\r\n                    requestDetails.url += \"&\" + _queryStringParameters[i].name + \"=\" + _queryStringParameters[i].value;\r\n                }\r\n                return requestDetails;\r\n            }\r\n            function _setTimingValue(timings, name, value) {\r\n                timings[name] = timings[name] || {};\r\n                timings[name][_postManager.identifier] = value;\r\n            }\r\n            function _doPayloadSend(thePayload, serializationStart, serializationCompleted, sendReason) {\r\n                if (thePayload && thePayload.payloadBlob && thePayload.payloadBlob.length > 0) {\r\n                    var useSendHook_1 = !!_self.sendHook;\r\n                    var sendInterface_1 = _sendInterfaces[thePayload.sendType];\r\n                    // Send all data using a beacon style transport if closing mode is on or channel was teared down\r\n                    if (!_isBeaconPayload(thePayload.sendType) && thePayload.isBeacon && thePayload.sendReason === 2 /* SendRequestReason.Unload */) {\r\n                        sendInterface_1 = _sendInterfaces[2 /* EventSendType.SendBeacon */] || _sendInterfaces[3 /* EventSendType.SyncFetch */] || sendInterface_1;\r\n                    }\r\n                    var useHeaders_1 = _useHeaders;\r\n                    // Disable header usage if we know we are using sendBeacon as additional headers are not supported\r\n                    if (thePayload.isBeacon || sendInterface_1._transport === 3 /* TransportType.Beacon */) {\r\n                        useHeaders_1 = false;\r\n                    }\r\n                    var requestDetails_1 = _buildRequestDetails(thePayload, useHeaders_1);\r\n                    useHeaders_1 = useHeaders_1 || requestDetails_1.useHdrs;\r\n                    var sendEventStart_1 = getTime();\r\n                    doPerf(_core, function () { return \"HttpManager:_doPayloadSend\"; }, function () {\r\n                        // Increment the send attempt count and add timings after packaging (So it's not serialized in the 1st attempt)\r\n                        for (var batchLp = 0; batchLp < thePayload.batches.length; batchLp++) {\r\n                            var theBatch = thePayload.batches[batchLp];\r\n                            var theEvents = theBatch.events();\r\n                            for (var evtLp = 0; evtLp < theEvents.length; evtLp++) {\r\n                                var telemetryItem = theEvents[evtLp];\r\n                                if (_enableEventTimings) {\r\n                                    var timings = telemetryItem.timings = telemetryItem.timings || {};\r\n                                    _setTimingValue(timings, \"sendEventStart\", sendEventStart_1);\r\n                                    _setTimingValue(timings, \"serializationStart\", serializationStart);\r\n                                    _setTimingValue(timings, \"serializationCompleted\", serializationCompleted);\r\n                                }\r\n                                telemetryItem[strSendAttempt] > 0 ? telemetryItem[strSendAttempt]++ : telemetryItem[strSendAttempt] = 1;\r\n                            }\r\n                        }\r\n                        // Note: always sending this notification in a synchronous manner.\r\n                        _sendBatchesNotification(thePayload.batches, (1000 /* EventBatchNotificationReason.SendingUndefined */ + (sendReason || 0 /* SendRequestReason.Undefined */)), thePayload.sendType, true);\r\n                        // Disabling the use of const because of Issue: \r\n                        // - Task 9227844: [1DS] Some environments and packagers automatically \"freeze\" objects which are defined as const which causes any mutations to throw\r\n                        // eslint-disable-next-line prefer-const\r\n                        var orgPayloadData = {\r\n                            data: thePayload.payloadBlob,\r\n                            urlString: requestDetails_1.url,\r\n                            headers: requestDetails_1.hdrs,\r\n                            _thePayload: thePayload,\r\n                            _sendReason: sendReason,\r\n                            timeout: _xhrTimeout,\r\n                            disableXhrSync: _disableXhrSync,\r\n                            disableFetchKeepAlive: _disableFetchKeepAlive\r\n                        };\r\n                        // Only automatically add the following headers if already sending headers and we are not attempting to avoid an options call\r\n                        if (useHeaders_1) {\r\n                            if (!_hasHeader(orgPayloadData.headers, STR_CACHE_CONTROL)) {\r\n                                orgPayloadData.headers[STR_CACHE_CONTROL] = DEFAULT_CACHE_CONTROL;\r\n                            }\r\n                            if (!_hasHeader(orgPayloadData.headers, STR_CONTENT_TYPE_HEADER)) {\r\n                                orgPayloadData.headers[STR_CONTENT_TYPE_HEADER] = DEFAULT_CONTENT_TYPE;\r\n                            }\r\n                        }\r\n                        var sender = null;\r\n                        if (sendInterface_1) {\r\n                            // Send sync requests if the request is immediate or we are tearing down telemetry.\r\n                            sender = function (payload) {\r\n                                // Notify the clock skew manager that we are sending the first request (Potentially blocking all further requests)\r\n                                _clockSkewManager.firstRequestSent();\r\n                                var onComplete = function (status, headers) {\r\n                                    _retryRequestIfNeeded(status, headers, thePayload, sendReason);\r\n                                };\r\n                                var isSync = thePayload.isTeardown || thePayload.isSync;\r\n                                try {\r\n                                    sendInterface_1.sendPOST(payload, onComplete, isSync);\r\n                                    if (_self.sendListener) {\r\n                                        // Send the original payload to the listener\r\n                                        _self.sendListener(orgPayloadData, payload, isSync, thePayload.isBeacon);\r\n                                    }\r\n                                }\r\n                                catch (ex) {\r\n                                    _warnToConsole(_logger, \"Unexpected exception sending payload. Ex:\" + dumpObj(ex));\r\n                                    _doOnComplete(onComplete, 0, {});\r\n                                }\r\n                            };\r\n                        }\r\n                        doPerf(_core, function () { return \"HttpManager:_doPayloadSend.sender\"; }, function () {\r\n                            if (sender) {\r\n                                if (thePayload.sendType === 0 /* EventSendType.Batched */) {\r\n                                    _outstandingRequests++;\r\n                                }\r\n                                // Only call the hook if it's defined and we are not using sendBeacon as additional headers are not supported\r\n                                if (useSendHook_1 && !thePayload.isBeacon && sendInterface_1._transport !== 3 /* TransportType.Beacon */) {\r\n                                    // Create a new IPayloadData that is sent into the hook method, so that the hook method\r\n                                    // can't change the object references to the orgPayloadData (it can still change the content -- mainly the headers)\r\n                                    // Disabling the use of const because of Issue: \r\n                                    // - Task 9227844: [1DS] Some environments and packagers automatically \"freeze\" objects which are defined as const which causes any mutations to throw\r\n                                    // eslint-disable-next-line prefer-const\r\n                                    var hookData_1 = {\r\n                                        data: orgPayloadData.data,\r\n                                        urlString: orgPayloadData.urlString,\r\n                                        headers: extend({}, orgPayloadData.headers),\r\n                                        timeout: orgPayloadData.timeout,\r\n                                        disableXhrSync: orgPayloadData.disableXhrSync,\r\n                                        disableFetchKeepAlive: orgPayloadData.disableFetchKeepAlive\r\n                                    };\r\n                                    var senderCalled_1 = false;\r\n                                    doPerf(_core, function () { return \"HttpManager:_doPayloadSend.sendHook\"; }, function () {\r\n                                        try {\r\n                                            _self.sendHook(hookData_1, function (payload) {\r\n                                                senderCalled_1 = true;\r\n                                                // Add back the internal properties\r\n                                                if (!_customHttpInterface && !payload._thePayload) {\r\n                                                    payload._thePayload = payload._thePayload || orgPayloadData._thePayload;\r\n                                                    payload._sendReason = payload._sendReason || orgPayloadData._sendReason;\r\n                                                }\r\n                                                sender(payload);\r\n                                            }, thePayload.isSync || thePayload.isTeardown);\r\n                                        }\r\n                                        catch (ex) {\r\n                                            if (!senderCalled_1) {\r\n                                                // The hook never called the sender -- assume that it never will\r\n                                                sender(orgPayloadData);\r\n                                            }\r\n                                        }\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    sender(orgPayloadData);\r\n                                }\r\n                            }\r\n                        });\r\n                    }, function () { return ({ thePayload: thePayload, serializationStart: serializationStart, serializationCompleted: serializationCompleted, sendReason: sendReason }); }, thePayload.isSync);\r\n                }\r\n                if (thePayload.sizeExceed && thePayload.sizeExceed.length > 0) {\r\n                    // Ensure that we send any discard events for oversize events even when there was no payload to send\r\n                    _sendBatchesNotification(thePayload.sizeExceed, 8003 /* EventBatchNotificationReason.SizeLimitExceeded */, thePayload.sendType);\r\n                }\r\n                if (thePayload.failedEvts && thePayload.failedEvts.length > 0) {\r\n                    // Ensure that we send any discard events for events that could not be serialized even when there was no payload to send\r\n                    _sendBatchesNotification(thePayload.failedEvts, 8002 /* EventBatchNotificationReason.InvalidEvent */, thePayload.sendType);\r\n                }\r\n            }\r\n            function _addEventCompletedTimings(theEvents, sendEventCompleted) {\r\n                if (_enableEventTimings) {\r\n                    arrForEach(theEvents, function (theEvent) {\r\n                        var timings = theEvent.timings = theEvent.timings || {};\r\n                        _setTimingValue(timings, \"sendEventCompleted\", sendEventCompleted);\r\n                    });\r\n                }\r\n            }\r\n            function _retryRequestIfNeeded(status, headers, thePayload, sendReason) {\r\n                var reason = 9000 /* EventBatchNotificationReason.ResponseFailure */;\r\n                var droppedBatches = null;\r\n                var isRetrying = false;\r\n                var backOffTrans = false;\r\n                try {\r\n                    var shouldRetry = true;\r\n                    if (typeof status !== strUndefined) {\r\n                        if (headers) {\r\n                            _clockSkewManager.setClockSkew(headers[STR_TIME_DELTA_HEADER]);\r\n                            var killDuration = headers[STR_KILL_DURATION_HEADER] || headers[\"kill-duration-seconds\"];\r\n                            arrForEach(_killSwitch.setKillSwitchTenants(headers[STR_KILL_TOKENS_HEADER], killDuration), function (killToken) {\r\n                                arrForEach(thePayload.batches, function (theBatch) {\r\n                                    if (theBatch.iKey() === killToken) {\r\n                                        // Make sure we have initialized the array\r\n                                        droppedBatches = droppedBatches || [];\r\n                                        // Create a copy of the batch with all of the events (and more importantly the action functions)\r\n                                        var removedEvents = theBatch.split(0);\r\n                                        // And then remove the events for the payload batch and reduce the actual number of processed\r\n                                        thePayload.numEvents -= removedEvents.count();\r\n                                        droppedBatches.push(removedEvents);\r\n                                    }\r\n                                });\r\n                            });\r\n                        }\r\n                        // Disabling triple-equals rule to avoid httpOverrides from failing because they are returning a string value\r\n                        // tslint:disable-next-line:triple-equals\r\n                        if (status == 200 || status == 204) {\r\n                            // Response was successfully sent\r\n                            reason = 200 /* EventBatchNotificationReason.Complete */;\r\n                            return;\r\n                        }\r\n                        if (!retryPolicyShouldRetryForStatus(status) || thePayload.numEvents <= 0) {\r\n                            // Only retry for specific response codes and if there is still events after kill switch processing\r\n                            shouldRetry = false;\r\n                        }\r\n                        // Derive the notification response from the HttpStatus Code\r\n                        reason = 9000 /* EventBatchNotificationReason.ResponseFailure */ + (status % 1000);\r\n                    }\r\n                    if (shouldRetry) {\r\n                        // The events should be retried -- so change notification to requeue them\r\n                        reason = 100 /* EventBatchNotificationReason.RequeueEvents */;\r\n                        var retryCount_1 = thePayload.retryCnt;\r\n                        if (thePayload.sendType === 0 /* EventSendType.Batched */) {\r\n                            // attempt to resend the entire batch\r\n                            if (retryCount_1 < maxRequestRetriesBeforeBackoff) {\r\n                                isRetrying = true;\r\n                                _doAction(function () {\r\n                                    // try to resend the same batches\r\n                                    if (thePayload.sendType === 0 /* EventSendType.Batched */) {\r\n                                        // Reduce the outstanding request count (if this was an async request) as we didn't reduce the count\r\n                                        // previously and we are about to reschedule our retry attempt and we want an attempt to send\r\n                                        // to occur, it's also required to ensure that a follow up handleRequestFinished() call occurs\r\n                                        _outstandingRequests--;\r\n                                    }\r\n                                    _sendBatches(thePayload.batches, retryCount_1 + 1, thePayload.isTeardown, _isUnloading ? 2 /* EventSendType.SendBeacon */ : thePayload.sendType, 5 /* SendRequestReason.Retry */);\r\n                                }, _isUnloading, retryPolicyGetMillisToBackoffForRetry(retryCount_1));\r\n                            }\r\n                            else {\r\n                                backOffTrans = true;\r\n                                if (_isUnloading) {\r\n                                    // we are unloading so don't try and requeue the events otherwise let the events get requeued and resent during the backoff sending\r\n                                    // This will also cause the events to be purged based on the priority (if necessary)\r\n                                    reason = 8001 /* EventBatchNotificationReason.NonRetryableStatus */;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                finally {\r\n                    if (!isRetrying) {\r\n                        // Make sure the clockSkewManager doesn't blocking further sending of requests once we have a proper response\r\n                        // This won't override any previously sent clock Skew value\r\n                        _clockSkewManager.setClockSkew();\r\n                        _handleRequestFinished(thePayload, reason, sendReason, backOffTrans);\r\n                    }\r\n                    _sendBatchesNotification(droppedBatches, 8004 /* EventBatchNotificationReason.KillSwitch */, thePayload.sendType);\r\n                }\r\n            }\r\n            function _handleRequestFinished(thePayload, batchReason, sendReason, backOffTrans) {\r\n                try {\r\n                    if (backOffTrans) {\r\n                        // Slow down the transmission requests\r\n                        _postManager._backOffTransmission();\r\n                    }\r\n                    if (batchReason === 200 /* EventBatchNotificationReason.Complete */) {\r\n                        if (!backOffTrans && !thePayload.isSync) {\r\n                            // We have a successful async response, so the lets open the floodgates\r\n                            // The reason for checking isSync is to avoid unblocking if beacon send occurred as it\r\n                            // doesn't wait for a response.\r\n                            _postManager._clearBackOff();\r\n                        }\r\n                        _addCompleteTimings(thePayload.batches);\r\n                    }\r\n                    // Send the notifications synchronously\r\n                    _sendBatchesNotification(thePayload.batches, batchReason, thePayload.sendType, true);\r\n                }\r\n                finally {\r\n                    if (thePayload.sendType === 0 /* EventSendType.Batched */) {\r\n                        // we always need to decrement this value otherwise the httpmanager locks up and won't send any more events\r\n                        _outstandingRequests--;\r\n                        // Don't try to send additional queued events if this is a retry operation as the retried\r\n                        // response will eventually call _handleRequestFinished for the retried event\r\n                        if (sendReason !== 5 /* SendRequestReason.Retry */) {\r\n                            // Try and send any other queued batched events\r\n                            _self.sendQueuedRequests(thePayload.sendType, sendReason);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            function _addCompleteTimings(theBatches) {\r\n                if (_enableEventTimings) {\r\n                    var sendEventCompleted_1 = getTime();\r\n                    arrForEach(theBatches, function (theBatch) {\r\n                        if (theBatch && theBatch.count() > 0) {\r\n                            _addEventCompletedTimings(theBatch.events(), sendEventCompleted_1);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            function _doAction(cb, isSync, interval) {\r\n                if (isSync) {\r\n                    cb();\r\n                }\r\n                else {\r\n                    timeoutOverride.set(cb, interval);\r\n                }\r\n            }\r\n            /**\r\n            * Converts the XHR getAllResponseHeaders to a map containing the header key and value.\r\n            */\r\n            // tslint:disable-next-line: align\r\n            function _convertAllHeadersToMap(headersString) {\r\n                var headers = {};\r\n                if (isString(headersString)) {\r\n                    var headersArray = strTrim(headersString).split(/[\\r\\n]+/);\r\n                    arrForEach(headersArray, function (headerEntry) {\r\n                        if (headerEntry) {\r\n                            var idx = headerEntry.indexOf(\": \");\r\n                            if (idx !== -1) {\r\n                                // The new spec has the headers returning all as lowercase -- but not all browsers do this yet\r\n                                var header = strTrim(headerEntry.substring(0, idx)).toLowerCase();\r\n                                var value = strTrim(headerEntry.substring(idx + 1));\r\n                                headers[header] = value;\r\n                            }\r\n                            else {\r\n                                headers[strTrim(headerEntry)] = 1;\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                return headers;\r\n            }\r\n            function _getMsfpc(thePayload) {\r\n                for (var lp = 0; lp < thePayload.batches.length; lp++) {\r\n                    var msfpc = thePayload.batches[lp].Msfpc();\r\n                    if (msfpc) {\r\n                        return encodeURIComponent(msfpc);\r\n                    }\r\n                }\r\n                return STR_EMPTY;\r\n            }\r\n            function _handleCollectorResponse(responseText) {\r\n                var responseHandlers = _self._responseHandlers;\r\n                try {\r\n                    for (var i = 0; i < responseHandlers.length; i++) {\r\n                        try {\r\n                            responseHandlers[i](responseText);\r\n                        }\r\n                        catch (e) {\r\n                            _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 519 /* _eExtendedInternalMessageId.PostResponseHandler */, \"Response handler failed: \" + e);\r\n                        }\r\n                    }\r\n                    if (responseText) {\r\n                        var response = JSON.parse(responseText);\r\n                        if (isValueAssigned(response.webResult) && isValueAssigned(response.webResult[STR_MSFPC])) {\r\n                            // Set cookie\r\n                            _cookieMgr.set(\"MSFPC\", response.webResult[STR_MSFPC], 365 * 86400);\r\n                        }\r\n                    }\r\n                }\r\n                catch (ex) {\r\n                    // Doing nothing\r\n                }\r\n            }\r\n            function _sendBatchesNotification(theBatches, batchReason, sendType, sendSync) {\r\n                if (theBatches && theBatches.length > 0 && actions) {\r\n                    var theAction_1 = actions[_getNotificationAction(batchReason)];\r\n                    if (theAction_1) {\r\n                        var isSyncRequest_1 = sendType !== 0 /* EventSendType.Batched */;\r\n                        doPerf(_core, function () { return \"HttpManager:_sendBatchesNotification\"; }, function () {\r\n                            _doAction(function () {\r\n                                try {\r\n                                    theAction_1.call(actions, theBatches, batchReason, isSyncRequest_1, sendType);\r\n                                }\r\n                                catch (e) {\r\n                                    _throwInternal(_logger, 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, \"send request notification failed: \" + e);\r\n                                }\r\n                            }, sendSync || isSyncRequest_1, 0);\r\n                        }, function () { return ({ batches: _createDebugBatches(theBatches), reason: batchReason, isSync: isSyncRequest_1, sendSync: sendSync, sendType: sendType }); }, !isSyncRequest_1);\r\n                    }\r\n                }\r\n            }\r\n            function _getNotificationAction(reason) {\r\n                var action = _eventActionMap[reason];\r\n                if (!isValueAssigned(action)) {\r\n                    action = STR_OTHER;\r\n                    if (reason >= 9000 /* EventBatchNotificationReason.ResponseFailure */ && reason <= 9999 /* EventBatchNotificationReason.ResponseFailureMax */) {\r\n                        action = STR_RESPONSE_FAIL;\r\n                    }\r\n                    else if (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */) {\r\n                        action = STR_DROPPED;\r\n                    }\r\n                    else if (reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */) {\r\n                        action = STR_SENDING;\r\n                    }\r\n                }\r\n                return action;\r\n            }\r\n        });\r\n    }\r\n// Removed Stub for HttpManager.prototype.initialize.\r\n// Removed Stub for HttpManager.prototype.addQueryStringParameter.\r\n// Removed Stub for HttpManager.prototype.addHeader.\r\n// Removed Stub for HttpManager.prototype.addBatch.\r\n// Removed Stub for HttpManager.prototype.canSendRequest.\r\n// Removed Stub for HttpManager.prototype.sendQueuedRequests.\r\n// Removed Stub for HttpManager.prototype.isCompletelyIdle.\r\n// Removed Stub for HttpManager.prototype.setUnloading.\r\n// Removed Stub for HttpManager.prototype.teardown.\r\n// Removed Stub for HttpManager.prototype.pause.\r\n// Removed Stub for HttpManager.prototype.resume.\r\n// Removed Stub for HttpManager.prototype.sendSynchronousBatch.\r\n    // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n    // this will be removed when ES3 support is dropped.\n    HttpManager.__ieDyn=1;\n\n    return HttpManager;\r\n}());\r\nexport { HttpManager };\r\n//# sourceMappingURL=HttpManager.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\n/**\r\n* TimeoutOverrideWrapper.ts\r\n* @author  Nev Wylie (newylie)\r\n* @copyright Microsoft 2022\r\n* Simple internal timeout wrapper\r\n*/\r\nexport function defaultSetTimeout(callback, ms) {\r\n    var args = [];\r\n    for (var _i = 2; _i < arguments.length; _i++) {\r\n        args[_i - 2] = arguments[_i];\r\n    }\r\n    return setTimeout(callback, ms, args);\r\n}\r\nexport function defaultClearTimeout(timeoutId) {\r\n    clearTimeout(timeoutId);\r\n}\r\nexport function createTimeoutWrapper(argSetTimeout, argClearTimeout) {\r\n    return {\r\n        set: argSetTimeout || defaultSetTimeout,\r\n        clear: argClearTimeout || defaultClearTimeout\r\n    };\r\n}\r\n//# sourceMappingURL=TimeoutOverrideWrapper.js.map","/*\n * 1DS JS SDK POST plugin, 3.2.13\n * Copyright (c) Microsoft and contributors. All rights reserved.\n * (Microsoft Internal Only)\n */\nimport { __extendsFn as __extends } from \"@microsoft/applicationinsights-shims\";\r\n/**\r\n* PostManager.ts\r\n* @author Abhilash Panwar (abpanwar); Hector Hernandez (hectorh); Nev Wylie (newylie)\r\n* @copyright Microsoft 2018-2020\r\n*/\r\nimport dynamicProto from \"@microsoft/dynamicproto-js\";\r\nimport { BaseTelemetryPlugin, EventsDiscardedReason, _throwInternal, addPageHideEventListener, addPageShowEventListener, addPageUnloadEventListener, arrForEach, createUniqueNamespace, doPerf, getWindow, isChromium, isNumber, isValueAssigned, mergeEvtNamespace, objDefineAccessors, objForEachKey, optimizeObject, removePageHideEventListener, removePageShowEventListener, removePageUnloadEventListener, setProcessTelemetryTimings } from \"@microsoft/1ds-core-js\";\r\nimport { BE_PROFILE, NRT_PROFILE, RT_PROFILE } from \"./DataModels\";\r\nimport { EventBatch } from \"./EventBatch\";\r\nimport { HttpManager } from \"./HttpManager\";\r\nimport { STR_MSA_DEVICE_TICKET, STR_TRACE, STR_USER } from \"./InternalConstants\";\r\nimport { retryPolicyGetMillisToBackoffForRetry } from \"./RetryPolicy\";\r\nimport { createTimeoutWrapper } from \"./TimeoutOverrideWrapper\";\r\nvar FlushCheckTimer = 0.250; // This needs to be in seconds, so this is 250ms\r\nvar MaxNumberEventPerBatch = 500;\r\nvar EventsDroppedAtOneTime = 20;\r\nvar MaxSendAttempts = 6;\r\nvar MaxSyncUnloadSendAttempts = 2; // Assuming 2 based on beforeunload and unload\r\nvar MaxBackoffCount = 4;\r\nvar MaxConnections = 2;\r\nvar MaxRequestRetriesBeforeBackoff = 1;\r\nvar strEventsDiscarded = \"eventsDiscarded\";\r\nvar strOverrideInstrumentationKey = \"overrideInstrumentationKey\";\r\nvar strMaxEventRetryAttempts = \"maxEventRetryAttempts\";\r\nvar strMaxUnloadEventRetryAttempts = \"maxUnloadEventRetryAttempts\";\r\nvar strAddUnloadCb = \"addUnloadCb\";\r\n/**\r\n * Class that manages adding events to inbound queues and batching of events\r\n * into requests.\r\n */\r\nvar PostChannel = /** @class */ (function (_super) {\r\n    __extends(PostChannel, _super);\r\n    function PostChannel() {\r\n        var _this = _super.call(this) || this;\r\n        _this.identifier = \"PostChannel\";\r\n        _this.priority = 1011;\r\n        _this.version = '3.2.13';\r\n        var _config;\r\n        var _isTeardownCalled = false;\r\n        var _flushCallbackQueue = [];\r\n        var _flushCallbackTimerId = null;\r\n        var _paused = false;\r\n        var _immediateQueueSize = 0;\r\n        var _immediateQueueSizeLimit = 500;\r\n        var _queueSize = 0;\r\n        var _queueSizeLimit = 10000;\r\n        var _profiles = {};\r\n        var _currentProfile = RT_PROFILE;\r\n        var _scheduledTimerId = null;\r\n        var _immediateTimerId = null;\r\n        var _currentBackoffCount = 0;\r\n        var _timerCount = 0;\r\n        var _xhrOverride;\r\n        var _httpManager;\r\n        var _batchQueues = {};\r\n        var _autoFlushEventsLimit;\r\n        // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])\r\n        var _autoFlushBatchLimit;\r\n        var _delayedBatchSendLatency = -1;\r\n        var _delayedBatchReason;\r\n        var _optimizeObject = true;\r\n        var _isPageUnloadTriggered = false;\r\n        var _maxEventSendAttempts = MaxSendAttempts;\r\n        var _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;\r\n        var _evtNamespace;\r\n        var _timeoutWrapper;\r\n        dynamicProto(PostChannel, _this, function (_self, _base) {\r\n            _initDefaults();\r\n            // Special internal method to allow the DebugPlugin to hook embedded objects\r\n            _self[\"_getDbgPlgTargets\"] = function () {\r\n                return [_httpManager];\r\n            };\r\n            _self.initialize = function (coreConfig, core, extensions) {\r\n                doPerf(core, function () { return \"PostChannel:initialize\"; }, function () {\r\n                    var extendedCore = core;\r\n                    _base.initialize(coreConfig, core, extensions);\r\n                    try {\r\n                        var hasAddUnloadCb = !!core[strAddUnloadCb];\r\n                        _evtNamespace = mergeEvtNamespace(createUniqueNamespace(_self.identifier), core.evtNamespace && core.evtNamespace());\r\n                        var ctx = _self._getTelCtx();\r\n                        coreConfig.extensionConfig[_self.identifier] = coreConfig.extensionConfig[_self.identifier] || {};\r\n                        _config = ctx.getExtCfg(_self.identifier);\r\n                        _timeoutWrapper = createTimeoutWrapper(_config.setTimeoutOverride, _config.clearTimeoutOverride);\r\n                        // Only try and use the optimizeObject() if this appears to be a chromium based browser and it has not been explicitly disabled\r\n                        _optimizeObject = !_config.disableOptimizeObj && isChromium();\r\n                        _hookWParam(extendedCore);\r\n                        if (_config.eventsLimitInMem > 0) {\r\n                            _queueSizeLimit = _config.eventsLimitInMem;\r\n                        }\r\n                        if (_config.immediateEventLimit > 0) {\r\n                            _immediateQueueSizeLimit = _config.immediateEventLimit;\r\n                        }\r\n                        if (_config.autoFlushEventsLimit > 0) {\r\n                            _autoFlushEventsLimit = _config.autoFlushEventsLimit;\r\n                        }\r\n                        if (isNumber(_config[strMaxEventRetryAttempts])) {\r\n                            _maxEventSendAttempts = _config[strMaxEventRetryAttempts];\r\n                        }\r\n                        if (isNumber(_config[strMaxUnloadEventRetryAttempts])) {\r\n                            _maxUnloadEventSendAttempts = _config[strMaxUnloadEventRetryAttempts];\r\n                        }\r\n                        _setAutoLimits();\r\n                        if (_config.httpXHROverride && _config.httpXHROverride.sendPOST) {\r\n                            _xhrOverride = _config.httpXHROverride;\r\n                        }\r\n                        if (isValueAssigned(coreConfig.anonCookieName)) {\r\n                            _httpManager.addQueryStringParameter(\"anoncknm\", coreConfig.anonCookieName);\r\n                        }\r\n                        _httpManager.sendHook = _config.payloadPreprocessor;\r\n                        _httpManager.sendListener = _config.payloadListener;\r\n                        // Override endpointUrl if provided in Post config\r\n                        var endpointUrl = _config.overrideEndpointUrl ? _config.overrideEndpointUrl : coreConfig.endpointUrl;\r\n                        _self._notificationManager = core.getNotifyMgr();\r\n                        _httpManager.initialize(endpointUrl, _self.core, _self, _xhrOverride, _config);\r\n                        var excludePageUnloadEvents = coreConfig.disablePageUnloadEvents || [];\r\n                        // When running in Web browsers try to send all telemetry if page is unloaded\r\n                        addPageUnloadEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);\r\n                        addPageHideEventListener(_handleUnloadEvents, excludePageUnloadEvents, _evtNamespace);\r\n                        addPageShowEventListener(_handleShowEvents, coreConfig.disablePageShowEvents, _evtNamespace);\r\n                    }\r\n                    catch (e) {\r\n                        // resetting the initialized state because of failure\r\n                        _self.setInitialized(false);\r\n                        throw e;\r\n                    }\r\n                }, function () { return ({ coreConfig: coreConfig, core: core, extensions: extensions }); });\r\n            };\r\n            _self.processTelemetry = function (ev, itemCtx) {\r\n                setProcessTelemetryTimings(ev, _self.identifier);\r\n                itemCtx = _self._getTelCtx(itemCtx);\r\n                // Get the channel instance from the current request/instance\r\n                var channelConfig = itemCtx.getExtCfg(_self.identifier);\r\n                // DisableTelemetry was defined in the config provided during initialization\r\n                var disableTelemetry = !!_config.disableTelemetry;\r\n                if (channelConfig) {\r\n                    // DisableTelemetry is defined in the config for this request/instance\r\n                    disableTelemetry = disableTelemetry || !!channelConfig.disableTelemetry;\r\n                }\r\n                var event = ev;\r\n                if (!disableTelemetry && !_isTeardownCalled) {\r\n                    // Override iKey if provided in Post config if provided for during initialization\r\n                    if (_config[strOverrideInstrumentationKey]) {\r\n                        event.iKey = _config[strOverrideInstrumentationKey];\r\n                    }\r\n                    // Override iKey if provided in Post config if provided for this instance\r\n                    if (channelConfig && channelConfig[strOverrideInstrumentationKey]) {\r\n                        event.iKey = channelConfig[strOverrideInstrumentationKey];\r\n                    }\r\n                    _addEventToQueues(event, true);\r\n                    if (_isPageUnloadTriggered) {\r\n                        // Unload event has been received so we need to try and flush new events\r\n                        _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);\r\n                    }\r\n                    else {\r\n                        _scheduleTimer();\r\n                    }\r\n                }\r\n                _self.processNext(event, itemCtx);\r\n            };\r\n            _self._doTeardown = function (unloadCtx, unloadState) {\r\n                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);\r\n                _isTeardownCalled = true;\r\n                _httpManager.teardown();\r\n                removePageUnloadEventListener(null, _evtNamespace);\r\n                removePageHideEventListener(null, _evtNamespace);\r\n                removePageShowEventListener(null, _evtNamespace);\r\n                // Just register to remove all events associated with this namespace\r\n                _initDefaults();\r\n            };\r\n            function _hookWParam(extendedCore) {\r\n                var existingGetWParamMethod = extendedCore.getWParam;\r\n                extendedCore.getWParam = function () {\r\n                    var wparam = 0;\r\n                    if (_config.ignoreMc1Ms0CookieProcessing) {\r\n                        wparam = wparam | 2;\r\n                    }\r\n                    return wparam | existingGetWParamMethod();\r\n                };\r\n            }\r\n            // Moving event handlers out from the initialize closure so that any local variables can be garbage collected\r\n            function _handleUnloadEvents(evt) {\r\n                var theEvt = evt || getWindow().event; // IE 8 does not pass the event\r\n                if (theEvt.type !== \"beforeunload\") {\r\n                    // Only set the unload trigger if not beforeunload event as beforeunload can be cancelled while the other events can't\r\n                    _isPageUnloadTriggered = true;\r\n                    _httpManager.setUnloading(_isPageUnloadTriggered);\r\n                }\r\n                _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);\r\n            }\r\n            function _handleShowEvents(evt) {\r\n                // Handle the page becoming visible again\r\n                _isPageUnloadTriggered = false;\r\n                _httpManager.setUnloading(_isPageUnloadTriggered);\r\n            }\r\n            function _addEventToQueues(event, append) {\r\n                // If send attempt field is undefined we should set it to 0.\r\n                if (!event.sendAttempt) {\r\n                    event.sendAttempt = 0;\r\n                }\r\n                // Add default latency\r\n                if (!event.latency) {\r\n                    event.latency = 1 /* EventLatencyValue.Normal */;\r\n                }\r\n                // Remove extra AI properties if present\r\n                if (event.ext && event.ext[STR_TRACE]) {\r\n                    delete (event.ext[STR_TRACE]);\r\n                }\r\n                if (event.ext && event.ext[STR_USER] && event.ext[STR_USER][\"id\"]) {\r\n                    delete (event.ext[STR_USER][\"id\"]);\r\n                }\r\n                // v8 performance optimization for iterating over the keys\r\n                if (_optimizeObject) {\r\n                    setProcessTelemetryTimings;\r\n                    event.ext = optimizeObject(event.ext);\r\n                    if (event.baseData) {\r\n                        event.baseData = optimizeObject(event.baseData);\r\n                    }\r\n                    if (event.data) {\r\n                        event.data = optimizeObject(event.data);\r\n                    }\r\n                }\r\n                if (event.sync) {\r\n                    // If the transmission is backed off then do not send synchronous events.\r\n                    // We will convert these events to Real time latency instead.\r\n                    if (_currentBackoffCount || _paused) {\r\n                        event.latency = 3 /* EventLatencyValue.RealTime */;\r\n                        event.sync = false;\r\n                    }\r\n                    else {\r\n                        // Log the event synchronously\r\n                        if (_httpManager) {\r\n                            // v8 performance optimization for iterating over the keys\r\n                            if (_optimizeObject) {\r\n                                event = optimizeObject(event);\r\n                            }\r\n                            _httpManager.sendSynchronousBatch(EventBatch.create(event.iKey, [event]), event.sync === true ? 1 /* EventSendType.Synchronous */ : event.sync, 3 /* SendRequestReason.SyncEvent */);\r\n                            return;\r\n                        }\r\n                    }\r\n                }\r\n                var evtLatency = event.latency;\r\n                var queueSize = _queueSize;\r\n                var queueLimit = _queueSizeLimit;\r\n                if (evtLatency === 4 /* EventLatencyValue.Immediate */) {\r\n                    queueSize = _immediateQueueSize;\r\n                    queueLimit = _immediateQueueSizeLimit;\r\n                }\r\n                var eventDropped = false;\r\n                // Only add the event if the queue isn't full or it's a direct event (which don't add to the queue sizes)\r\n                if (queueSize < queueLimit) {\r\n                    eventDropped = !_addEventToProperQueue(event, append);\r\n                }\r\n                else {\r\n                    var dropLatency = 1 /* EventLatencyValue.Normal */;\r\n                    var dropNumber = EventsDroppedAtOneTime;\r\n                    if (evtLatency === 4 /* EventLatencyValue.Immediate */) {\r\n                        // Only drop other immediate events as they are not technically sharing the general queue\r\n                        dropLatency = 4 /* EventLatencyValue.Immediate */;\r\n                        dropNumber = 1;\r\n                    }\r\n                    // Drop old event from lower or equal latency\r\n                    eventDropped = true;\r\n                    if (_dropEventWithLatencyOrLess(event.iKey, event.latency, dropLatency, dropNumber)) {\r\n                        eventDropped = !_addEventToProperQueue(event, append);\r\n                    }\r\n                }\r\n                if (eventDropped) {\r\n                    // Can't drop events from current queues because the all the slots are taken by queues that are being flushed.\r\n                    _notifyEvents(strEventsDiscarded, [event], EventsDiscardedReason.QueueFull);\r\n                }\r\n            }\r\n            _self.setEventQueueLimits = function (eventLimit, autoFlushLimit) {\r\n                _queueSizeLimit = eventLimit > 0 ? eventLimit : 10000;\r\n                _autoFlushEventsLimit = autoFlushLimit > 0 ? autoFlushLimit : 0;\r\n                _setAutoLimits();\r\n                // We only do this check here as during normal event addition if the queue is > then events start getting dropped\r\n                var doFlush = _queueSize > eventLimit;\r\n                if (!doFlush && _autoFlushBatchLimit > 0) {\r\n                    // Check the auto flush max batch size\r\n                    for (var latency = 1 /* EventLatencyValue.Normal */; !doFlush && latency <= 3 /* EventLatencyValue.RealTime */; latency++) {\r\n                        var batchQueue = _batchQueues[latency];\r\n                        if (batchQueue && batchQueue.batches) {\r\n                            arrForEach(batchQueue.batches, function (theBatch) {\r\n                                if (theBatch && theBatch.count() >= _autoFlushBatchLimit) {\r\n                                    // If any 1 batch is > than the limit then trigger an auto flush\r\n                                    doFlush = true;\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n                _performAutoFlush(true, doFlush);\r\n            };\r\n            _self.pause = function () {\r\n                _clearScheduledTimer();\r\n                _paused = true;\r\n                _httpManager.pause();\r\n            };\r\n            _self.resume = function () {\r\n                _paused = false;\r\n                _httpManager.resume();\r\n                _scheduleTimer();\r\n            };\r\n            _self.addResponseHandler = function (responseHandler) {\r\n                _httpManager._responseHandlers.push(responseHandler);\r\n            };\r\n            _self._loadTransmitProfiles = function (profiles) {\r\n                _resetTransmitProfiles();\r\n                objForEachKey(profiles, function (profileName, profileValue) {\r\n                    var profLen = profileValue.length;\r\n                    if (profLen >= 2) {\r\n                        var directValue = (profLen > 2 ? profileValue[2] : 0);\r\n                        profileValue.splice(0, profLen - 2);\r\n                        // Make sure if a higher latency is set to not send then don't send lower latency\r\n                        if (profileValue[1] < 0) {\r\n                            profileValue[0] = -1;\r\n                        }\r\n                        // Make sure each latency is multiple of the latency higher then it. If not a multiple\r\n                        // we round up so that it becomes a multiple.\r\n                        if (profileValue[1] > 0 && profileValue[0] > 0) {\r\n                            var timerMultiplier = profileValue[0] / profileValue[1];\r\n                            profileValue[0] = Math.ceil(timerMultiplier) * profileValue[1];\r\n                        }\r\n                        // Add back the direct profile timeout\r\n                        if (directValue >= 0 && profileValue[1] >= 0 && directValue > profileValue[1]) {\r\n                            // Make sure if it's not disabled (< 0) then make sure it's not larger than RealTime\r\n                            directValue = profileValue[1];\r\n                        }\r\n                        profileValue.push(directValue);\r\n                        _profiles[profileName] = profileValue;\r\n                    }\r\n                });\r\n            };\r\n            _self.flush = function (async, callback, sendReason) {\r\n                if (async === void 0) { async = true; }\r\n                if (!_paused) {\r\n                    sendReason = sendReason || 1 /* SendRequestReason.ManualFlush */;\r\n                    if (async) {\r\n                        if (_flushCallbackTimerId == null) {\r\n                            // Clear the normal schedule timer as we are going to try and flush ASAP\r\n                            _clearScheduledTimer();\r\n                            // Move all queued events to the HttpManager so that we don't discard new events (Auto flush scenario)\r\n                            _queueBatches(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);\r\n                            _flushCallbackTimerId = _createTimer(function () {\r\n                                _flushCallbackTimerId = null;\r\n                                _flushImpl(callback, sendReason);\r\n                            }, 0);\r\n                        }\r\n                        else {\r\n                            // Even if null (no callback) this will ensure after the flushImpl finishes waiting\r\n                            // for a completely idle connection it will attempt to re-flush any queued events on the next cycle\r\n                            _flushCallbackQueue.push(callback);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Clear the normal schedule timer as we are going to try and flush ASAP\r\n                        var cleared = _clearScheduledTimer();\r\n                        // Now cause all queued events to be sent synchronously\r\n                        _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 1 /* EventSendType.Synchronous */, sendReason);\r\n                        if (callback !== null && callback !== undefined) {\r\n                            callback();\r\n                        }\r\n                        if (cleared) {\r\n                            // restart the normal event timer if it was cleared\r\n                            _scheduleTimer();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            _self.setMsaAuthTicket = function (ticket) {\r\n                _httpManager.addHeader(STR_MSA_DEVICE_TICKET, ticket);\r\n            };\r\n            _self.hasEvents = _hasEvents;\r\n            _self._setTransmitProfile = function (profileName) {\r\n                if (_currentProfile !== profileName && _profiles[profileName] !== undefined) {\r\n                    _clearScheduledTimer();\r\n                    _currentProfile = profileName;\r\n                    _scheduleTimer();\r\n                }\r\n            };\r\n            /**\r\n             * Batch and send events currently in the queue for the given latency.\r\n             * @param latency - Latency for which to send events.\r\n             */\r\n            function _sendEventsForLatencyAndAbove(latency, sendType, sendReason) {\r\n                var queued = _queueBatches(latency, sendType, sendReason);\r\n                // Always trigger the request as while the post channel may not have queued additional events, the httpManager may already have waiting events\r\n                _httpManager.sendQueuedRequests(sendType, sendReason);\r\n                return queued;\r\n            }\r\n            function _hasEvents() {\r\n                return _queueSize > 0;\r\n            }\r\n            /**\r\n             * Try to schedule the timer after which events will be sent. If there are\r\n             * no events to be sent, or there is already a timer scheduled, or the\r\n             * http manager doesn't have any idle connections this method is no-op.\r\n             */\r\n            function _scheduleTimer() {\r\n                // If we had previously attempted to send requests, but the http manager didn't have any idle connections then the requests where delayed\r\n                // so try and requeue then again now\r\n                if (_delayedBatchSendLatency >= 0 && _queueBatches(_delayedBatchSendLatency, 0 /* EventSendType.Batched */, _delayedBatchReason)) {\r\n                    _httpManager.sendQueuedRequests(0 /* EventSendType.Batched */, _delayedBatchReason);\r\n                }\r\n                if (_immediateQueueSize > 0 && !_immediateTimerId && !_paused) {\r\n                    // During initialization _profiles enforce that the direct [2] is less than real time [1] timer value\r\n                    // If the immediateTimeout is disabled the immediate events will be sent with Real Time events\r\n                    var immediateTimeOut = _profiles[_currentProfile][2];\r\n                    if (immediateTimeOut >= 0) {\r\n                        _immediateTimerId = _createTimer(function () {\r\n                            _immediateTimerId = null;\r\n                            // Only try to send direct events\r\n                            _sendEventsForLatencyAndAbove(4 /* EventLatencyValue.Immediate */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);\r\n                            _scheduleTimer();\r\n                        }, immediateTimeOut);\r\n                    }\r\n                }\r\n                // During initialization the _profiles enforce that the normal [0] is a multiple of the real time [1] timer value\r\n                var timeOut = _profiles[_currentProfile][1];\r\n                if (!_scheduledTimerId && !_flushCallbackTimerId && timeOut >= 0 && !_paused) {\r\n                    if (_hasEvents()) {\r\n                        _scheduledTimerId = _createTimer(function () {\r\n                            _scheduledTimerId = null;\r\n                            _sendEventsForLatencyAndAbove(_timerCount === 0 ? 3 /* EventLatencyValue.RealTime */ : 1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, 1 /* SendRequestReason.NormalSchedule */);\r\n                            // Increment the count for next cycle\r\n                            _timerCount++;\r\n                            _timerCount %= 2;\r\n                            _scheduleTimer();\r\n                        }, timeOut);\r\n                    }\r\n                    else {\r\n                        _timerCount = 0;\r\n                    }\r\n                }\r\n            }\r\n            _self._backOffTransmission = function () {\r\n                if (_currentBackoffCount < MaxBackoffCount) {\r\n                    _currentBackoffCount++;\r\n                    _clearScheduledTimer();\r\n                    _scheduleTimer();\r\n                }\r\n            };\r\n            _self._clearBackOff = function () {\r\n                if (_currentBackoffCount) {\r\n                    _currentBackoffCount = 0;\r\n                    _clearScheduledTimer();\r\n                    _scheduleTimer();\r\n                }\r\n            };\r\n            function _initDefaults() {\r\n                _config = null;\r\n                _isTeardownCalled = false;\r\n                _flushCallbackQueue = [];\r\n                _flushCallbackTimerId = null;\r\n                _paused = false;\r\n                _immediateQueueSize = 0;\r\n                _immediateQueueSizeLimit = 500;\r\n                _queueSize = 0;\r\n                _queueSizeLimit = 10000;\r\n                _profiles = {};\r\n                _currentProfile = RT_PROFILE;\r\n                _scheduledTimerId = null;\r\n                _immediateTimerId = null;\r\n                _currentBackoffCount = 0;\r\n                _timerCount = 0;\r\n                _xhrOverride = null;\r\n                _batchQueues = {};\r\n                _autoFlushEventsLimit = undefined;\r\n                // either MaxBatchSize * (1+ Max Connections) or _queueLimit / 6 (where 3 latency Queues [normal, realtime, cost deferred] * 2 [allow half full -- allow for retry])\r\n                _autoFlushBatchLimit = 0;\r\n                _delayedBatchSendLatency = -1;\r\n                _delayedBatchReason = null;\r\n                _optimizeObject = true;\r\n                _isPageUnloadTriggered = false;\r\n                _maxEventSendAttempts = MaxSendAttempts;\r\n                _maxUnloadEventSendAttempts = MaxSyncUnloadSendAttempts;\r\n                _evtNamespace = null;\r\n                _timeoutWrapper = createTimeoutWrapper();\r\n                _httpManager = new HttpManager(MaxNumberEventPerBatch, MaxConnections, MaxRequestRetriesBeforeBackoff, {\r\n                    requeue: _requeueEvents,\r\n                    send: _sendingEvent,\r\n                    sent: _eventsSentEvent,\r\n                    drop: _eventsDropped,\r\n                    rspFail: _eventsResponseFail,\r\n                    oth: _otherEvent\r\n                }, _timeoutWrapper);\r\n                _initializeProfiles();\r\n                _clearQueues();\r\n                _setAutoLimits();\r\n            }\r\n            function _createTimer(theTimerFunc, timeOut) {\r\n                // If the transmission is backed off make the timer at least 1 sec to allow for back off.\r\n                if (timeOut === 0 && _currentBackoffCount) {\r\n                    timeOut = 1;\r\n                }\r\n                var timerMultiplier = 1000;\r\n                if (_currentBackoffCount) {\r\n                    timerMultiplier = retryPolicyGetMillisToBackoffForRetry(_currentBackoffCount - 1);\r\n                }\r\n                return _timeoutWrapper.set(theTimerFunc, timeOut * timerMultiplier);\r\n            }\r\n            function _clearScheduledTimer() {\r\n                if (_scheduledTimerId !== null) {\r\n                    _timeoutWrapper.clear(_scheduledTimerId);\r\n                    _scheduledTimerId = null;\r\n                    _timerCount = 0;\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            // Try to send all queued events using beacons if available\r\n            function _releaseAllQueues(sendType, sendReason) {\r\n                _clearScheduledTimer();\r\n                // Cancel all flush callbacks\r\n                if (_flushCallbackTimerId) {\r\n                    _timeoutWrapper.clear(_flushCallbackTimerId);\r\n                    _flushCallbackTimerId = null;\r\n                }\r\n                if (!_paused) {\r\n                    // Queue all the remaining requests to be sent. The requests will be sent using HTML5 Beacons if they are available.\r\n                    _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, sendType, sendReason);\r\n                }\r\n            }\r\n            /**\r\n             * Add empty queues for all latencies in the inbound queues map. This is called\r\n             * when Transmission Manager is being flushed. This ensures that new events added\r\n             * after flush are stored separately till we flush the current events.\r\n             */\r\n            function _clearQueues() {\r\n                _batchQueues[4 /* EventLatencyValue.Immediate */] = {\r\n                    batches: [],\r\n                    iKeyMap: {}\r\n                };\r\n                _batchQueues[3 /* EventLatencyValue.RealTime */] = {\r\n                    batches: [],\r\n                    iKeyMap: {}\r\n                };\r\n                _batchQueues[2 /* EventLatencyValue.CostDeferred */] = {\r\n                    batches: [],\r\n                    iKeyMap: {}\r\n                };\r\n                _batchQueues[1 /* EventLatencyValue.Normal */] = {\r\n                    batches: [],\r\n                    iKeyMap: {}\r\n                };\r\n            }\r\n            function _getEventBatch(iKey, latency, create) {\r\n                var batchQueue = _batchQueues[latency];\r\n                if (!batchQueue) {\r\n                    latency = 1 /* EventLatencyValue.Normal */;\r\n                    batchQueue = _batchQueues[latency];\r\n                }\r\n                var eventBatch = batchQueue.iKeyMap[iKey];\r\n                if (!eventBatch && create) {\r\n                    eventBatch = EventBatch.create(iKey);\r\n                    batchQueue.batches.push(eventBatch);\r\n                    batchQueue.iKeyMap[iKey] = eventBatch;\r\n                }\r\n                return eventBatch;\r\n            }\r\n            function _performAutoFlush(isAsync, doFlush) {\r\n                // Only perform the auto flush check if the httpManager has an idle connection and we are not in a backoff situation\r\n                if (_httpManager.canSendRequest() && !_currentBackoffCount) {\r\n                    if (_autoFlushEventsLimit > 0 && _queueSize > _autoFlushEventsLimit) {\r\n                        // Force flushing\r\n                        doFlush = true;\r\n                    }\r\n                    if (doFlush && _flushCallbackTimerId == null) {\r\n                        // Auto flush the queue\r\n                        _self.flush(isAsync, null, 20 /* SendRequestReason.MaxQueuedEvents */);\r\n                    }\r\n                }\r\n            }\r\n            function _addEventToProperQueue(event, append) {\r\n                // v8 performance optimization for iterating over the keys\r\n                if (_optimizeObject) {\r\n                    event = optimizeObject(event);\r\n                }\r\n                var latency = event.latency;\r\n                var eventBatch = _getEventBatch(event.iKey, latency, true);\r\n                if (eventBatch.addEvent(event)) {\r\n                    if (latency !== 4 /* EventLatencyValue.Immediate */) {\r\n                        _queueSize++;\r\n                        // Check for auto flushing based on total events in the queue, but not for requeued or retry events\r\n                        if (append && event.sendAttempt === 0) {\r\n                            // Force the flushing of the batch if the batch (specific iKey / latency combination) reaches it's auto flush limit\r\n                            _performAutoFlush(!event.sync, _autoFlushBatchLimit > 0 && eventBatch.count() >= _autoFlushBatchLimit);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // Direct events don't need auto flushing as they are scheduled (by default) for immediate delivery\r\n                        _immediateQueueSize++;\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            function _dropEventWithLatencyOrLess(iKey, latency, currentLatency, dropNumber) {\r\n                while (currentLatency <= latency) {\r\n                    var eventBatch = _getEventBatch(iKey, latency, true);\r\n                    if (eventBatch && eventBatch.count() > 0) {\r\n                        // Dropped oldest events from lowest possible latency\r\n                        var droppedEvents = eventBatch.split(0, dropNumber);\r\n                        var droppedCount = droppedEvents.count();\r\n                        if (droppedCount > 0) {\r\n                            if (currentLatency === 4 /* EventLatencyValue.Immediate */) {\r\n                                _immediateQueueSize -= droppedCount;\r\n                            }\r\n                            else {\r\n                                _queueSize -= droppedCount;\r\n                            }\r\n                            _notifyBatchEvents(strEventsDiscarded, [droppedEvents], EventsDiscardedReason.QueueFull);\r\n                            return true;\r\n                        }\r\n                    }\r\n                    currentLatency++;\r\n                }\r\n                // Unable to drop any events -- lets just make sure the queue counts are correct to avoid exhaustion\r\n                _resetQueueCounts();\r\n                return false;\r\n            }\r\n            /**\r\n             * Internal helper to reset the queue counts, used as a backstop to avoid future queue exhaustion errors\r\n             * that might occur because of counting issues.\r\n             */\r\n            function _resetQueueCounts() {\r\n                var immediateQueue = 0;\r\n                var normalQueue = 0;\r\n                var _loop_1 = function (latency) {\r\n                    var batchQueue = _batchQueues[latency];\r\n                    if (batchQueue && batchQueue.batches) {\r\n                        arrForEach(batchQueue.batches, function (theBatch) {\r\n                            if (latency === 4 /* EventLatencyValue.Immediate */) {\r\n                                immediateQueue += theBatch.count();\r\n                            }\r\n                            else {\r\n                                normalQueue += theBatch.count();\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n                for (var latency = 1 /* EventLatencyValue.Normal */; latency <= 4 /* EventLatencyValue.Immediate */; latency++) {\r\n                    _loop_1(latency);\r\n                }\r\n                _queueSize = normalQueue;\r\n                _immediateQueueSize = immediateQueue;\r\n            }\r\n            function _queueBatches(latency, sendType, sendReason) {\r\n                var eventsQueued = false;\r\n                var isAsync = sendType === 0 /* EventSendType.Batched */;\r\n                // Only queue batches (to the HttpManager) if this is a sync request or the httpManager has an idle connection\r\n                // Thus keeping the events within the PostChannel until the HttpManager has a connection available\r\n                // This is so we can drop \"old\" events if the queue is getting full because we can't successfully send events\r\n                if (!isAsync || _httpManager.canSendRequest()) {\r\n                    doPerf(_self.core, function () { return \"PostChannel._queueBatches\"; }, function () {\r\n                        var droppedEvents = [];\r\n                        var latencyToProcess = 4 /* EventLatencyValue.Immediate */;\r\n                        while (latencyToProcess >= latency) {\r\n                            var batchQueue = _batchQueues[latencyToProcess];\r\n                            if (batchQueue && batchQueue.batches && batchQueue.batches.length > 0) {\r\n                                arrForEach(batchQueue.batches, function (theBatch) {\r\n                                    // Add the batch to the http manager to send the requests\r\n                                    if (!_httpManager.addBatch(theBatch)) {\r\n                                        // The events from this iKey are being dropped (killed)\r\n                                        droppedEvents = droppedEvents.concat(theBatch.events());\r\n                                    }\r\n                                    else {\r\n                                        eventsQueued = eventsQueued || (theBatch && theBatch.count() > 0);\r\n                                    }\r\n                                    if (latencyToProcess === 4 /* EventLatencyValue.Immediate */) {\r\n                                        _immediateQueueSize -= theBatch.count();\r\n                                    }\r\n                                    else {\r\n                                        _queueSize -= theBatch.count();\r\n                                    }\r\n                                });\r\n                                // Remove all batches from this Queue\r\n                                batchQueue.batches = [];\r\n                                batchQueue.iKeyMap = {};\r\n                            }\r\n                            latencyToProcess--;\r\n                        }\r\n                        if (droppedEvents.length > 0) {\r\n                            _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.KillSwitch);\r\n                        }\r\n                        if (eventsQueued && _delayedBatchSendLatency >= latency) {\r\n                            // We have queued events at the same level as the delayed values so clear the setting\r\n                            _delayedBatchSendLatency = -1;\r\n                            _delayedBatchReason = 0 /* SendRequestReason.Undefined */;\r\n                        }\r\n                    }, function () { return ({ latency: latency, sendType: sendType, sendReason: sendReason }); }, !isAsync);\r\n                }\r\n                else {\r\n                    // remember the min latency so that we can re-trigger later\r\n                    _delayedBatchSendLatency = _delayedBatchSendLatency >= 0 ? Math.min(_delayedBatchSendLatency, latency) : latency;\r\n                    _delayedBatchReason = Math.max(_delayedBatchReason, sendReason);\r\n                }\r\n                return eventsQueued;\r\n            }\r\n            /**\r\n             * This is the callback method is called as part of the manual flushing process.\r\n             * @param callback\r\n             * @param sendReason\r\n             */\r\n            function _flushImpl(callback, sendReason) {\r\n                // Add any additional queued events and cause all queued events to be sent asynchronously\r\n                _sendEventsForLatencyAndAbove(1 /* EventLatencyValue.Normal */, 0 /* EventSendType.Batched */, sendReason);\r\n                // All events (should) have been queue -- lets just make sure the queue counts are correct to avoid queue exhaustion (previous bug #9685112)\r\n                _resetQueueCounts();\r\n                _waitForIdleManager(function () {\r\n                    // Only called AFTER the httpManager does not have any outstanding requests\r\n                    if (callback) {\r\n                        callback();\r\n                    }\r\n                    if (_flushCallbackQueue.length > 0) {\r\n                        _flushCallbackTimerId = _createTimer(function () {\r\n                            _flushCallbackTimerId = null;\r\n                            _flushImpl(_flushCallbackQueue.shift(), sendReason);\r\n                        }, 0);\r\n                    }\r\n                    else {\r\n                        // No more flush requests\r\n                        _flushCallbackTimerId = null;\r\n                        // Restart the normal timer schedule\r\n                        _scheduleTimer();\r\n                    }\r\n                });\r\n            }\r\n            function _waitForIdleManager(callback) {\r\n                if (_httpManager.isCompletelyIdle()) {\r\n                    callback();\r\n                }\r\n                else {\r\n                    _flushCallbackTimerId = _createTimer(function () {\r\n                        _flushCallbackTimerId = null;\r\n                        _waitForIdleManager(callback);\r\n                    }, FlushCheckTimer);\r\n                }\r\n            }\r\n            /**\r\n             * Resets the transmit profiles to the default profiles of Real Time, Near Real Time\r\n             * and Best Effort. This removes all the custom profiles that were loaded.\r\n             */\r\n            function _resetTransmitProfiles() {\r\n                _clearScheduledTimer();\r\n                _initializeProfiles();\r\n                _currentProfile = RT_PROFILE;\r\n                _scheduleTimer();\r\n            }\r\n            function _initializeProfiles() {\r\n                _profiles = {};\r\n                _profiles[RT_PROFILE] = [2, 1, 0];\r\n                _profiles[NRT_PROFILE] = [6, 3, 0];\r\n                _profiles[BE_PROFILE] = [18, 9, 0];\r\n            }\r\n            /**\r\n             * The notification handler for requeue events\r\n             * @ignore\r\n             */\r\n            function _requeueEvents(batches, reason) {\r\n                var droppedEvents = [];\r\n                var maxSendAttempts = _maxEventSendAttempts;\r\n                if (_isPageUnloadTriggered) {\r\n                    // If a page unlaod has been triggered reduce the number of times we try to \"retry\"\r\n                    maxSendAttempts = _maxUnloadEventSendAttempts;\r\n                }\r\n                arrForEach(batches, function (theBatch) {\r\n                    if (theBatch && theBatch.count() > 0) {\r\n                        arrForEach(theBatch.events(), function (theEvent) {\r\n                            if (theEvent) {\r\n                                // Check if the request being added back is for a sync event in which case mark it no longer a sync event\r\n                                if (theEvent.sync) {\r\n                                    theEvent.latency = 4 /* EventLatencyValue.Immediate */;\r\n                                    theEvent.sync = false;\r\n                                }\r\n                                if (theEvent.sendAttempt < maxSendAttempts) {\r\n                                    // Reset the event timings\r\n                                    setProcessTelemetryTimings(theEvent, _self.identifier);\r\n                                    _addEventToQueues(theEvent, false);\r\n                                }\r\n                                else {\r\n                                    droppedEvents.push(theEvent);\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n                if (droppedEvents.length > 0) {\r\n                    _notifyEvents(strEventsDiscarded, droppedEvents, EventsDiscardedReason.NonRetryableStatus);\r\n                }\r\n                if (_isPageUnloadTriggered) {\r\n                    // Unload event has been received so we need to try and flush new events\r\n                    _releaseAllQueues(2 /* EventSendType.SendBeacon */, 2 /* SendRequestReason.Unload */);\r\n                }\r\n            }\r\n            function _callNotification(evtName, theArgs) {\r\n                var manager = (_self._notificationManager || {});\r\n                var notifyFunc = manager[evtName];\r\n                if (notifyFunc) {\r\n                    try {\r\n                        notifyFunc.apply(manager, theArgs);\r\n                    }\r\n                    catch (e) {\r\n                        _throwInternal(_self.diagLog(), 1 /* eLoggingSeverity.CRITICAL */, 74 /* _eInternalMessageId.NotificationException */, evtName + \" notification failed: \" + e);\r\n                    }\r\n                }\r\n            }\r\n            function _notifyEvents(evtName, theEvents) {\r\n                var extraArgs = [];\r\n                for (var _i = 2; _i < arguments.length; _i++) {\r\n                    extraArgs[_i - 2] = arguments[_i];\r\n                }\r\n                if (theEvents && theEvents.length > 0) {\r\n                    _callNotification(evtName, [theEvents].concat(extraArgs));\r\n                }\r\n            }\r\n            function _notifyBatchEvents(evtName, batches) {\r\n                var extraArgs = [];\r\n                for (var _i = 2; _i < arguments.length; _i++) {\r\n                    extraArgs[_i - 2] = arguments[_i];\r\n                }\r\n                if (batches && batches.length > 0) {\r\n                    arrForEach(batches, function (theBatch) {\r\n                        if (theBatch && theBatch.count() > 0) {\r\n                            _callNotification(evtName, [theBatch.events()].concat(extraArgs));\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n            /**\r\n             * The notification handler for when batches are about to be sent\r\n             * @ignore\r\n             */\r\n            function _sendingEvent(batches, reason, isSyncRequest) {\r\n                if (batches && batches.length > 0) {\r\n                    _callNotification(\"eventsSendRequest\", [(reason >= 1000 /* EventBatchNotificationReason.SendingUndefined */ && reason <= 1999 /* EventBatchNotificationReason.SendingEventMax */ ?\r\n                            reason - 1000 /* EventBatchNotificationReason.SendingUndefined */ :\r\n                            0 /* SendRequestReason.Undefined */), isSyncRequest !== true]);\r\n                }\r\n            }\r\n            /**\r\n             * This event represents that a batch of events have been successfully sent and a response received\r\n             * @param batches The notification handler for when the batches have been successfully sent\r\n             * @param reason For this event the reason will always be EventBatchNotificationReason.Complete\r\n             */\r\n            function _eventsSentEvent(batches, reason) {\r\n                _notifyBatchEvents(\"eventsSent\", batches, reason);\r\n                // Try and schedule the processing timer if we have events\r\n                _scheduleTimer();\r\n            }\r\n            function _eventsDropped(batches, reason) {\r\n                _notifyBatchEvents(strEventsDiscarded, batches, (reason >= 8000 /* EventBatchNotificationReason.EventsDropped */ && reason <= 8999 /* EventBatchNotificationReason.EventsDroppedMax */ ?\r\n                    reason - 8000 /* EventBatchNotificationReason.EventsDropped */ :\r\n                    EventsDiscardedReason.Unknown));\r\n            }\r\n            function _eventsResponseFail(batches) {\r\n                _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.NonRetryableStatus);\r\n                // Try and schedule the processing timer if we have events\r\n                _scheduleTimer();\r\n            }\r\n            function _otherEvent(batches, reason) {\r\n                _notifyBatchEvents(strEventsDiscarded, batches, EventsDiscardedReason.Unknown);\r\n                // Try and schedule the processing timer if we have events\r\n                _scheduleTimer();\r\n            }\r\n            function _setAutoLimits() {\r\n                if (!_config || !_config.disableAutoBatchFlushLimit) {\r\n                    _autoFlushBatchLimit = Math.max(MaxNumberEventPerBatch * (MaxConnections + 1), _queueSizeLimit / 6);\r\n                }\r\n                else {\r\n                    _autoFlushBatchLimit = 0;\r\n                }\r\n            }\r\n            // Provided for backward compatibility they are not \"expected\" to be in current use but they are public\r\n            objDefineAccessors(_self, \"_setTimeoutOverride\", function () { return _timeoutWrapper.set; }, function (value) {\r\n                // Recreate the timeout wrapper\r\n                _timeoutWrapper = createTimeoutWrapper(value, _timeoutWrapper.clear);\r\n            });\r\n            objDefineAccessors(_self, \"_clearTimeoutOverride\", function () { return _timeoutWrapper.clear; }, function (value) {\r\n                // Recreate the timeout wrapper\r\n                _timeoutWrapper = createTimeoutWrapper(_timeoutWrapper.set, value);\r\n            });\r\n        });\r\n        return _this;\r\n    }\r\n// Removed Stub for PostChannel.prototype.initialize.\r\n// Removed Stub for PostChannel.prototype.processTelemetry.\r\n// Removed Stub for PostChannel.prototype.setEventQueueLimits.\r\n// Removed Stub for PostChannel.prototype.pause.\r\n// Removed Stub for PostChannel.prototype.resume.\r\n// Removed Stub for PostChannel.prototype.addResponseHandler.\r\n// Removed Stub for PostChannel.prototype.flush.\r\n// Removed Stub for PostChannel.prototype.setMsaAuthTicket.\r\n// Removed Stub for PostChannel.prototype.hasEvents.\r\n// Removed Stub for PostChannel.prototype._loadTransmitProfiles.\r\n// Removed Stub for PostChannel.prototype._setTransmitProfile.\r\n// Removed Stub for PostChannel.prototype._backOffTransmission.\r\n// Removed Stub for PostChannel.prototype._clearBackOff.\r\n    // This is a workaround for an IE8 bug when using dynamicProto() with classes that don't have any\n    // non-dynamic functions or static properties/functions when using uglify-js to minify the resulting code.\n    // this will be removed when ES3 support is dropped.\n    PostChannel.__ieDyn=1;\n\n    return PostChannel;\r\n}(BaseTelemetryPlugin));\r\nexport default PostChannel;\r\n//# sourceMappingURL=PostChannel.js.map"],"names":["RT_PROFILE","STR_EMPTY","STR_POST_METHOD","STR_DROPPED","STR_REQUEUE","DEFAULT_CONTENT_TYPE","STR_CACHE_CONTROL","STR_CONTENT_TYPE_HEADER","STR_KILL_DURATION_HEADER","STR_TIME_DELTA_HEADER","STR_CLIENT_VERSION","STR_CLIENT_ID","STR_TIME_DELTA_TO_APPLY","STR_UPLOAD_TIME","STR_API_KEY","STR_MSA_DEVICE_TICKET","STR_AUTH_XTOKEN","STR_MSFPC","STR_TRACE","STR_USER","_getEventMsfpc","theEvent","intWeb","ext","isValueAssigned","_getMsfpc","theEvents","msfpc","lp","length","EventBatch","create","iKey","addEvents","events","concat","_self","this","_msfpc","Msfpc","count","addEvent","push","split","fromEvent","numEvents","cnt","isNullOrUndefined","splice","ClockSkewManager","__ieDyn","_allowRequestSending","_shouldAddClockSkewHeaders","_isFirstRequest","_clockSkewHeaderValue","_clockSkewSet","dynamicProto","allowRequestSending","firstRequestSent","shouldAddClockSkewHeaders","getClockSkewHeaderValue","setClockSkew","timeDeltaInMillis","KillSwitch","_killedTokenDictionary","setKillSwitchTenants","killTokens","killDuration","values","result","arrForEach","value","strTrim","killedTokens","durationMs","parseInt","i","dateNow","ex","isTenantKilled","tenantToken","killDictionary","name","undefined","RandomizationLowerThreshold","RandomizationUpperThreshold","BaseBackoff","MaxBackoff","retryPolicyGetMillisToBackoffForRetry","retriesSoFar","minBackoff","Math","min","pow","floor","random","metadata","f","rCheckDot","Serializer","perfManager","valueSanitizer","stringifyObjects","enableCompoundKey","strBaseData","_checkForCompoundkey","_theSanitizer","_isReservedCache","_processPathKeys","srcObj","target","thePath","checkReserved","metadataPathKeys","metadataCallback","processSubKeys","objForEachKey","key","srcValue","newValue","path","name_1","theMetaPathKeys","destObj","test","subKeys","keyLen","slice","subKey","prop","strStartsWith","handleField","sanitizeProperty","isArray","newPath","createPayload","retryCnt","isTeardown","isSync","isReducedPayload","sendReason","sendType","apiKeys","payloadBlob","overflow","sizeExceed","failedEvts","batches","isBeacon","appendPayload","payload","theBatch","maxEventsPerBatch","canAddEvents","doPerf","payloadEvents","eventsAdded","sizeExceeded","isBeaconPayload","requestMaxSize","recordMaxSize","joinCount","eventBlob","getEventBlob","blobLength","substr","apiKey","arrIndexOf","evts","max","eventData","serializedEvent","serializedExt","time","ver","getTenantId","eventExt","serializedData","serializedBaseData","baseType","baseData","pathKeys","_addJSONPropertyMetaData","data","JSON","stringify","item","e","json","propKeys","propertyValue","encodedTypeValue","getCommonSchemaMetaData","kind","propertyType","metaData","metaTarget","t","strSendAttempt","_noResponseQs","_eventActionMap","_a","_collectorQsHeaders","_collectorHeaderToQs","_addCollectorHeaderQsMapping","qsName","headerName","allowQs","_getResponseText","xhr","responseText","_hasHeader","headers","header","hasHeader","keys","objKeys","lowerHeader","toLowerCase","hasOwnProperty","_addRequestDetails","details","useHeaders","hdrs","useHdrs","url","_prependTransports","theTransports","newTransports","isNumber","HttpManager","maxConnections","maxRequestRetriesBeforeBackoff","actions","timeoutOverride","_responseHandlers","_postManager","_logger","_sendInterfaces","_core","_cookieMgr","_xhrTimeout","_disableXhrSync","_disableFetchKeepAlive","_canHaveReducedPayload","_addNoResponse","_urlString","_killSwitch","EVTKillSwitch","_paused","_clockSkewManager","EVTClockSkewManager","_useBeacons","_outstandingRequests","_customHttpInterface","_queryStringParameters","_headers","_batchQueue","_serializer","_enableEventTimings","_isUnloading","_useHeaders","_sendCredentials","_getSenderInterface","transports","syncSupport","transportType","sendPostFunc","useXDomainRequest","_xdrSendPost","isXhrSupported","_xhrSendPost","isFetchSupported","isBeaconsSupported","_beaconSendPost","_fetchSendPost","_transport","_isSync","sendPOST","oncomplete","sync","xdr","XDomainRequest","open","urlString","timeout","onload","response","_doOnComplete","_handleCollectorResponse","onerror","ontimeout","onprogress","send","set","requestInit","theUrl","ignoreResponse","responseHandled","body","method","keepalive","_sendReason","credentials","fetch","then","headerMap","text","status","error","_appendHeader","theHeaders","getResponseHeader","xhrComplete","responseTxt","headersArray","getAllResponseHeaders","headersString","isString","headerEntry","idx","indexOf","substring","disableXhrSync","xhrRequest","openXhr","setRequestHeader","_throwInternal","dumpObj","thePayload","_thePayload","droppedBatches_1","nav_1","getNavigator","sendBeacon","_sendBatchesNotification","_warnToConsole","_isBeaconPayload","_adjustSendType","_hasIdleConnection","_clearQueue","theQueue","_canSendPayload","theBatches","_createDebugBatches","_sendBatches","retryCount","orgBatches_1","isSynchronous_1","perfEvt","droppedBatches","serializationStart","getTime","sendInterface","sendTransport","shift","_doPayloadSend","isSynchronous","useSendBeacon","_setTimingValue","timings","identifier","serializationCompleted","useSendHook_1","sendInterface_1","requestDetails_1","useHeaders_1","sendEventStart_1","sendHook","requestDetails","apiQsKeys","extend","FullVersionString","toString","encodeURIComponent","getWParam","wParam","batchLp","evtLp","telemetryItem","orgPayloadData","disableFetchKeepAlive","sender","onComplete","_retryRequestIfNeeded","sendEventCompleted_1","reason","isRetrying","backOffTrans","retryCount_1","shouldRetry","strUndefined","killToken","removedEvents","_doAction","_handleRequestFinished","batchReason","_backOffTransmission","_clearBackOff","sendEventCompleted","sendQueuedRequests","sendListener","hookData_1","senderCalled_1","cb","interval","responseHandlers","parse","webResult","sendSync","theAction_1","isSyncRequest_1","action","call","initialize","endpointUrl","core","postChannel","httpInterface","channelConfig","isUndefined","avoidOptions","getCookieMgr","config","disableEventTimings","diagLog","syncHttpInterface","xhrTimeout","addNoResponse","isReactNative","beaconHttpInterface","alwaysUseXhrOverride","fetchSyncHttpInterface","beaconUnloadTransports","location_1","getLocation","protocol","unloadTransports","addQueryStringParameter","addHeader","canSendRequest","isCompletelyIdle","setUnloading","addBatch","teardown","pause","resume","sendSynchronousBatch","batch","defaultSetTimeout","callback","ms","args","_i","arguments","setTimeout","defaultClearTimeout","timeoutId","clearTimeout","createTimeoutWrapper","argSetTimeout","argClearTimeout","clear","_super","strEventsDiscarded","strOverrideInstrumentationKey","strMaxEventRetryAttempts","strMaxUnloadEventRetryAttempts","PostChannel","BaseTelemetryPlugin","__extends","_config","_xhrOverride","_httpManager","_autoFlushEventsLimit","_autoFlushBatchLimit","_delayedBatchReason","_evtNamespace","_timeoutWrapper","_this","_isTeardownCalled","priority","version","_flushCallbackQueue","_flushCallbackTimerId","_immediateQueueSize","_immediateQueueSizeLimit","_queueSize","_queueSizeLimit","_profiles","_currentProfile","_scheduledTimerId","_immediateTimerId","_currentBackoffCount","_timerCount","_batchQueues","_delayedBatchSendLatency","_optimizeObject","_isPageUnloadTriggered","_maxEventSendAttempts","_maxUnloadEventSendAttempts","_base","_handleUnloadEvents","evt","getWindow","event","type","_releaseAllQueues","_handleShowEvents","_addEventToQueues","append","sendAttempt","latency","optimizeObject","evtLatency","queueSize","queueLimit","eventDropped","dropLatency","dropNumber","currentLatency","eventBatch","_getEventBatch","droppedEvents","droppedCount","_notifyBatchEvents","EventsDiscardedReason","QueueFull","_resetQueueCounts","_performAutoFlush","_notifyEvents","_sendEventsForLatencyAndAbove","_queueBatches","_scheduleTimer","immediateTimeOut","_createTimer","timeOut","_initDefaults","requeue","_requeueEvents","_sendingEvent","sent","_eventsSentEvent","drop","_eventsDropped","rspFail","_eventsResponseFail","oth","_otherEvent","_initializeProfiles","iKeyMap","_setAutoLimits","theTimerFunc","timerMultiplier","_clearScheduledTimer","batchQueue","isAsync","doFlush","flush","immediateQueue","normalQueue","_loop_1","eventsQueued","latencyToProcess","REAL_TIME","NEAR_REAL_TIME","BEST_EFFORT","maxSendAttempts","setProcessTelemetryTimings","NonRetryableStatus","_callNotification","evtName","theArgs","manager","_notificationManager","notifyFunc","apply","extraArgs","isSyncRequest","Unknown","disableAutoBatchFlushLimit","MaxNumberEventPerBatch","coreConfig","extensions","existingGetWParamMethod","extendedCore","mergeEvtNamespace","createUniqueNamespace","evtNamespace","ctx","_getTelCtx","extensionConfig","getExtCfg","setTimeoutOverride","clearTimeoutOverride","disableOptimizeObj","isChromium","wparam","ignoreMc1Ms0CookieProcessing","eventsLimitInMem","immediateEventLimit","autoFlushEventsLimit","httpXHROverride","anonCookieName","payloadPreprocessor","payloadListener","overrideEndpointUrl","excludePageUnloadEvents","getNotifyMgr","disablePageUnloadEvents","addPageUnloadEventListener","addPageHideEventListener","addPageShowEventListener","disablePageShowEvents","setInitialized","processTelemetry","ev","itemCtx","disableTelemetry","processNext","_doTeardown","unloadCtx","unloadState","removePageUnloadEventListener","removePageHideEventListener","removePageShowEventListener","setEventQueueLimits","eventLimit","autoFlushLimit","addResponseHandler","responseHandler","_loadTransmitProfiles","profiles","profileName","profileValue","directValue","profLen","ceil","async","_flushImpl","_waitForIdleManager","cleared","setMsaAuthTicket","ticket","hasEvents","_setTransmitProfile","objDefineAccessors"],"mappings":"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"}