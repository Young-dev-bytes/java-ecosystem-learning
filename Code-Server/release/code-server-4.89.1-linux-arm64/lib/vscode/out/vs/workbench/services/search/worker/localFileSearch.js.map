{"version":3,"sources":["out-vscode-reh-web/vs/workbench/services/search/worker/fake","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/symbols.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/extpath.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/network.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/resources.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/async.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/base/common/glob.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/getFileResults.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/common/ignoreFile.ts","out-vscode-reh-web/vs/workbench/services/search/worker/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/workbench/services/search/worker/localFileSearch.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n/**\n * Can be passed into the Delayed to defer using a microtask\n * */\nexport const MicrotaskDelay = Symbol('MicrotaskDelay');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isAbsolute, join, normalize, posix, sep } from 'vs/base/common/path';\nimport { isWindows } from 'vs/base/common/platform';\nimport { equalsIgnoreCase, rtrim, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { isNumber } from 'vs/base/common/types';\n\nexport function isPathSeparator(code: number) {\n\treturn code === CharCode.Slash || code === CharCode.Backslash;\n}\n\n/**\n * Takes a Windows OS path and changes backward slashes to forward slashes.\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toSlashes(osPath: string) {\n\treturn osPath.replace(/[\\\\/]/g, posix.sep);\n}\n\n/**\n * Takes a Windows OS path (using backward or forward slashes) and turns it into a posix path:\n * - turns backward slashes into forward slashes\n * - makes it absolute if it starts with a drive letter\n * This should only be done for OS paths from Windows (or user provided paths potentially from Windows).\n * Using it on a Linux or MaxOS path might change it.\n */\nexport function toPosixPath(osPath: string) {\n\tif (osPath.indexOf('/') === -1) {\n\t\tosPath = toSlashes(osPath);\n\t}\n\tif (/^[a-zA-Z]:(\\/|$)/.test(osPath)) { // starts with a drive letter\n\t\tosPath = '/' + osPath;\n\t}\n\treturn osPath;\n}\n\n/**\n * Computes the _root_ this path, like `getRoot('c:\\files') === c:\\`,\n * `getRoot('files:///files/path') === files:///`,\n * or `getRoot('\\\\server\\shares\\path') === \\\\server\\shares\\`\n */\nexport function getRoot(path: string, sep: string = posix.sep): string {\n\tif (!path) {\n\t\treturn '';\n\t}\n\n\tconst len = path.length;\n\tconst firstLetter = path.charCodeAt(0);\n\tif (isPathSeparator(firstLetter)) {\n\t\tif (isPathSeparator(path.charCodeAt(1))) {\n\t\t\t// UNC candidate \\\\localhost\\shares\\ddd\n\t\t\t//               ^^^^^^^^^^^^^^^^^^^\n\t\t\tif (!isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\tlet pos = 3;\n\t\t\t\tconst start = pos;\n\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (start !== pos && !isPathSeparator(path.charCodeAt(pos + 1))) {\n\t\t\t\t\tpos += 1;\n\t\t\t\t\tfor (; pos < len; pos++) {\n\t\t\t\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\t\t\t\treturn path.slice(0, pos + 1) // consume this separator\n\t\t\t\t\t\t\t\t.replace(/[\\\\/]/g, sep);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// /user/far\n\t\t// ^\n\t\treturn sep;\n\n\t} else if (isWindowsDriveLetter(firstLetter)) {\n\t\t// check for windows drive letter c:\\ or c:\n\n\t\tif (path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tif (isPathSeparator(path.charCodeAt(2))) {\n\t\t\t\t// C:\\fff\n\t\t\t\t// ^^^\n\t\t\t\treturn path.slice(0, 2) + sep;\n\t\t\t} else {\n\t\t\t\t// C:\n\t\t\t\t// ^^\n\t\t\t\treturn path.slice(0, 2);\n\t\t\t}\n\t\t}\n\t}\n\n\t// check for URI\n\t// scheme://authority/path\n\t// ^^^^^^^^^^^^^^^^^^^\n\tlet pos = path.indexOf('://');\n\tif (pos !== -1) {\n\t\tpos += 3; // 3 -> \"://\".length\n\t\tfor (; pos < len; pos++) {\n\t\t\tif (isPathSeparator(path.charCodeAt(pos))) {\n\t\t\t\treturn path.slice(0, pos + 1); // consume this separator\n\t\t\t}\n\t\t}\n\t}\n\n\treturn '';\n}\n\n/**\n * Check if the path follows this pattern: `\\\\hostname\\sharename`.\n *\n * @see https://msdn.microsoft.com/en-us/library/gg465305.aspx\n * @return A boolean indication if the path is a UNC path, on none-windows\n * always false.\n */\nexport function isUNC(path: string): boolean {\n\tif (!isWindows) {\n\t\t// UNC is a windows concept\n\t\treturn false;\n\t}\n\n\tif (!path || path.length < 5) {\n\t\t// at least \\\\a\\b\n\t\treturn false;\n\t}\n\n\tlet code = path.charCodeAt(0);\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(1);\n\n\tif (code !== CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\tlet pos = 2;\n\tconst start = pos;\n\tfor (; pos < path.length; pos++) {\n\t\tcode = path.charCodeAt(pos);\n\t\tif (code === CharCode.Backslash) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (start === pos) {\n\t\treturn false;\n\t}\n\n\tcode = path.charCodeAt(pos + 1);\n\n\tif (isNaN(code) || code === CharCode.Backslash) {\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n// Reference: https://en.wikipedia.org/wiki/Filename\nconst WINDOWS_INVALID_FILE_CHARS = /[\\\\/:\\*\\?\"<>\\|]/g;\nconst UNIX_INVALID_FILE_CHARS = /[\\\\/]/g;\nconst WINDOWS_FORBIDDEN_NAMES = /^(con|prn|aux|clock\\$|nul|lpt[0-9]|com[0-9])(\\.(.*?))?$/i;\nexport function isValidBasename(name: string | null | undefined, isWindowsOS: boolean = isWindows): boolean {\n\tconst invalidFileChars = isWindowsOS ? WINDOWS_INVALID_FILE_CHARS : UNIX_INVALID_FILE_CHARS;\n\n\tif (!name || name.length === 0 || /^\\s+$/.test(name)) {\n\t\treturn false; // require a name that is not just whitespace\n\t}\n\n\tinvalidFileChars.lastIndex = 0; // the holy grail of software development\n\tif (invalidFileChars.test(name)) {\n\t\treturn false; // check for certain invalid file characters\n\t}\n\n\tif (isWindowsOS && WINDOWS_FORBIDDEN_NAMES.test(name)) {\n\t\treturn false; // check for certain invalid file names\n\t}\n\n\tif (name === '.' || name === '..') {\n\t\treturn false; // check for reserved values\n\t}\n\n\tif (isWindowsOS && name[name.length - 1] === '.') {\n\t\treturn false; // Windows: file cannot end with a \".\"\n\t}\n\n\tif (isWindowsOS && name.length !== name.trim().length) {\n\t\treturn false; // Windows: file cannot end with a whitespace\n\t}\n\n\tif (name.length > 255) {\n\t\treturn false; // most file systems do not allow files > 255 length\n\t}\n\n\treturn true;\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqual` instead. If you are\n * in a context without services, consider to pass down the `extUri` from the outside\n * or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqual(pathA: string, pathB: string, ignoreCase?: boolean): boolean {\n\tconst identityEquals = (pathA === pathB);\n\tif (!ignoreCase || identityEquals) {\n\t\treturn identityEquals;\n\t}\n\n\tif (!pathA || !pathB) {\n\t\treturn false;\n\t}\n\n\treturn equalsIgnoreCase(pathA, pathB);\n}\n\n/**\n * @deprecated please use `IUriIdentityService.extUri.isEqualOrParent` instead. If\n * you are in a context without services, consider to pass down the `extUri` from the\n * outside, or use `extUriBiasedIgnorePathCase` if you know what you are doing.\n */\nexport function isEqualOrParent(base: string, parentCandidate: string, ignoreCase?: boolean, separator = sep): boolean {\n\tif (base === parentCandidate) {\n\t\treturn true;\n\t}\n\n\tif (!base || !parentCandidate) {\n\t\treturn false;\n\t}\n\n\tif (parentCandidate.length > base.length) {\n\t\treturn false;\n\t}\n\n\tif (ignoreCase) {\n\t\tconst beginsWith = startsWithIgnoreCase(base, parentCandidate);\n\t\tif (!beginsWith) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentCandidate.length === base.length) {\n\t\t\treturn true; // same path, different casing\n\t\t}\n\n\t\tlet sepOffset = parentCandidate.length;\n\t\tif (parentCandidate.charAt(parentCandidate.length - 1) === separator) {\n\t\t\tsepOffset--; // adjust the expected sep offset in case our candidate already ends in separator character\n\t\t}\n\n\t\treturn base.charAt(sepOffset) === separator;\n\t}\n\n\tif (parentCandidate.charAt(parentCandidate.length - 1) !== separator) {\n\t\tparentCandidate += separator;\n\t}\n\n\treturn base.indexOf(parentCandidate) === 0;\n}\n\nexport function isWindowsDriveLetter(char0: number): boolean {\n\treturn char0 >= CharCode.A && char0 <= CharCode.Z || char0 >= CharCode.a && char0 <= CharCode.z;\n}\n\nexport function sanitizeFilePath(candidate: string, cwd: string): string {\n\n\t// Special case: allow to open a drive letter without trailing backslash\n\tif (isWindows && candidate.endsWith(':')) {\n\t\tcandidate += sep;\n\t}\n\n\t// Ensure absolute\n\tif (!isAbsolute(candidate)) {\n\t\tcandidate = join(cwd, candidate);\n\t}\n\n\t// Ensure normalized\n\tcandidate = normalize(candidate);\n\n\t// Ensure no trailing slash/backslash\n\treturn removeTrailingPathSeparator(candidate);\n}\n\nexport function removeTrailingPathSeparator(candidate: string): string {\n\tif (isWindows) {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open drive root ('C:\\')\n\t\tif (candidate.endsWith(':')) {\n\t\t\tcandidate += sep;\n\t\t}\n\n\t} else {\n\t\tcandidate = rtrim(candidate, sep);\n\n\t\t// Special case: allow to open root ('/')\n\t\tif (!candidate) {\n\t\t\tcandidate = sep;\n\t\t}\n\t}\n\n\treturn candidate;\n}\n\nexport function isRootOrDriveLetter(path: string): boolean {\n\tconst pathNormalized = normalize(path);\n\n\tif (isWindows) {\n\t\tif (path.length > 3) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn hasDriveLetter(pathNormalized) &&\n\t\t\t(path.length === 2 || pathNormalized.charCodeAt(2) === CharCode.Backslash);\n\t}\n\n\treturn pathNormalized === posix.sep;\n}\n\nexport function hasDriveLetter(path: string, isWindowsOS: boolean = isWindows): boolean {\n\tif (isWindowsOS) {\n\t\treturn isWindowsDriveLetter(path.charCodeAt(0)) && path.charCodeAt(1) === CharCode.Colon;\n\t}\n\n\treturn false;\n}\n\nexport function getDriveLetter(path: string, isWindowsOS: boolean = isWindows): string | undefined {\n\treturn hasDriveLetter(path, isWindowsOS) ? path[0] : undefined;\n}\n\nexport function indexOfPath(path: string, candidate: string, ignoreCase?: boolean): number {\n\tif (candidate.length > path.length) {\n\t\treturn -1;\n\t}\n\n\tif (path === candidate) {\n\t\treturn 0;\n\t}\n\n\tif (ignoreCase) {\n\t\tpath = path.toLowerCase();\n\t\tcandidate = candidate.toLowerCase();\n\t}\n\n\treturn path.indexOf(candidate);\n}\n\nexport interface IPathWithLineAndColumn {\n\tpath: string;\n\tline?: number;\n\tcolumn?: number;\n}\n\nexport function parseLineAndColumnAware(rawPath: string): IPathWithLineAndColumn {\n\tconst segments = rawPath.split(':'); // C:\\file.txt:<line>:<column>\n\n\tlet path: string | undefined = undefined;\n\tlet line: number | undefined = undefined;\n\tlet column: number | undefined = undefined;\n\n\tfor (const segment of segments) {\n\t\tconst segmentAsNumber = Number(segment);\n\t\tif (!isNumber(segmentAsNumber)) {\n\t\t\tpath = !!path ? [path, segment].join(':') : segment; // a colon can well be part of a path (e.g. C:\\...)\n\t\t} else if (line === undefined) {\n\t\t\tline = segmentAsNumber;\n\t\t} else if (column === undefined) {\n\t\t\tcolumn = segmentAsNumber;\n\t\t}\n\t}\n\n\tif (!path) {\n\t\tthrow new Error('Format for `--goto` should be: `FILE:LINE(:COLUMN)`');\n\t}\n\n\treturn {\n\t\tpath,\n\t\tline: line !== undefined ? line : undefined,\n\t\tcolumn: column !== undefined ? column : line !== undefined ? 1 : undefined // if we have a line, make sure column is also set\n\t};\n}\n\nconst pathChars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\nconst windowsSafePathFirstChars = 'BDEFGHIJKMOQRSTUVWXYZbdefghijkmoqrstuvwxyz0123456789';\n\nexport function randomPath(parent?: string, prefix?: string, randomLength = 8): string {\n\tlet suffix = '';\n\tfor (let i = 0; i < randomLength; i++) {\n\t\tlet pathCharsTouse: string;\n\t\tif (i === 0 && isWindows && !prefix && (randomLength === 3 || randomLength === 4)) {\n\n\t\t\t// Windows has certain reserved file names that cannot be used, such\n\t\t\t// as AUX, CON, PRN, etc. We want to avoid generating a random name\n\t\t\t// that matches that pattern, so we use a different set of characters\n\t\t\t// for the first character of the name that does not include any of\n\t\t\t// the reserved names first characters.\n\n\t\t\tpathCharsTouse = windowsSafePathFirstChars;\n\t\t} else {\n\t\t\tpathCharsTouse = pathChars;\n\t\t}\n\n\t\tsuffix += pathCharsTouse.charAt(Math.floor(Math.random() * pathCharsTouse.length));\n\t}\n\n\tlet randomFileName: string;\n\tif (prefix) {\n\t\trandomFileName = `${prefix}-${suffix}`;\n\t} else {\n\t\trandomFileName = suffix;\n\t}\n\n\tif (parent) {\n\t\treturn join(parent, randomFileName);\n\t}\n\n\treturn randomFileName;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as errors from 'vs/base/common/errors';\nimport * as platform from 'vs/base/common/platform';\nimport { equalsIgnoreCase, startsWithIgnoreCase } from 'vs/base/common/strings';\nimport { URI } from 'vs/base/common/uri';\nimport * as paths from 'vs/base/common/path';\n\nexport namespace Schemas {\n\n\t/**\n\t * A schema that is used for models that exist in memory\n\t * only and that have no correspondence on a server or such.\n\t */\n\texport const inMemory = 'inmemory';\n\n\t/**\n\t * A schema that is used for setting files\n\t */\n\texport const vscode = 'vscode';\n\n\t/**\n\t * A schema that is used for internal private files\n\t */\n\texport const internal = 'private';\n\n\t/**\n\t * A walk-through document.\n\t */\n\texport const walkThrough = 'walkThrough';\n\n\t/**\n\t * An embedded code snippet.\n\t */\n\texport const walkThroughSnippet = 'walkThroughSnippet';\n\n\texport const http = 'http';\n\n\texport const https = 'https';\n\n\texport const file = 'file';\n\n\texport const mailto = 'mailto';\n\n\texport const untitled = 'untitled';\n\n\texport const data = 'data';\n\n\texport const command = 'command';\n\n\texport const vscodeRemote = 'vscode-remote';\n\n\texport const vscodeRemoteResource = 'vscode-remote-resource';\n\n\texport const vscodeManagedRemoteResource = 'vscode-managed-remote-resource';\n\n\texport const vscodeUserData = 'vscode-userdata';\n\n\texport const vscodeCustomEditor = 'vscode-custom-editor';\n\n\texport const vscodeNotebookCell = 'vscode-notebook-cell';\n\texport const vscodeNotebookCellMetadata = 'vscode-notebook-cell-metadata';\n\texport const vscodeNotebookCellOutput = 'vscode-notebook-cell-output';\n\texport const vscodeInteractiveInput = 'vscode-interactive-input';\n\n\texport const vscodeSettings = 'vscode-settings';\n\n\texport const vscodeWorkspaceTrust = 'vscode-workspace-trust';\n\n\texport const vscodeTerminal = 'vscode-terminal';\n\n\t/** Scheme used for code blocks in chat. */\n\texport const vscodeChatCodeBlock = 'vscode-chat-code-block';\n\t/** Scheme used for LHS of code compare (aka diff) blocks in chat. */\n\texport const vscodeChatCodeCompreBlock = 'vscode-chat-code-compare-block';\n\t/** Scheme used for the chat input editor. */\n\texport const vscodeChatSesssion = 'vscode-chat-editor';\n\n\t/**\n\t * Scheme used internally for webviews that aren't linked to a resource (i.e. not custom editors)\n\t */\n\texport const webviewPanel = 'webview-panel';\n\n\t/**\n\t * Scheme used for loading the wrapper html and script in webviews.\n\t */\n\texport const vscodeWebview = 'vscode-webview';\n\n\t/**\n\t * Scheme used for extension pages\n\t */\n\texport const extension = 'extension';\n\n\t/**\n\t * Scheme used as a replacement of `file` scheme to load\n\t * files with our custom protocol handler (desktop only).\n\t */\n\texport const vscodeFileResource = 'vscode-file';\n\n\t/**\n\t * Scheme used for temporary resources\n\t */\n\texport const tmp = 'tmp';\n\n\t/**\n\t * Scheme used vs live share\n\t */\n\texport const vsls = 'vsls';\n\n\t/**\n\t * Scheme used for the Source Control commit input's text document\n\t */\n\texport const vscodeSourceControl = 'vscode-scm';\n\n\t/**\n\t * Scheme used for input box for creating comments.\n\t */\n\texport const commentsInput = 'comment';\n\n\t/**\n\t * Scheme used for special rendering of settings in the release notes\n\t */\n\texport const codeSetting = 'code-setting';\n}\n\nexport function matchesScheme(target: URI | string, scheme: string): boolean {\n\tif (URI.isUri(target)) {\n\t\treturn equalsIgnoreCase(target.scheme, scheme);\n\t} else {\n\t\treturn startsWithIgnoreCase(target, scheme + ':');\n\t}\n}\n\nexport function matchesSomeScheme(target: URI | string, ...schemes: string[]): boolean {\n\treturn schemes.some(scheme => matchesScheme(target, scheme));\n}\n\nexport const connectionTokenCookieName = 'vscode-tkn';\nexport const connectionTokenQueryName = 'tkn';\n\nclass RemoteAuthoritiesImpl {\n\tprivate readonly _hosts: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate readonly _ports: { [authority: string]: number | undefined } = Object.create(null);\n\tprivate readonly _connectionTokens: { [authority: string]: string | undefined } = Object.create(null);\n\tprivate _preferredWebSchema: 'http' | 'https' = 'http';\n\tprivate _delegate: ((uri: URI) => URI) | null = null;\n\tprivate _serverRootPath: string = '/';\n\n\tsetPreferredWebSchema(schema: 'http' | 'https') {\n\t\tthis._preferredWebSchema = schema;\n\t}\n\n\tsetDelegate(delegate: (uri: URI) => URI): void {\n\t\tthis._delegate = delegate;\n\t}\n\n\tsetServerRootPath(product: { quality?: string; commit?: string }, serverBasePath: string | undefined): void {\n\t\tthis._serverRootPath = getServerRootPath(product, serverBasePath);\n\t}\n\n\tgetServerRootPath(): string {\n\t\treturn this._serverRootPath;\n\t}\n\n\tprivate get _remoteResourcesPath(): string {\n\t\treturn paths.posix.join(this._serverRootPath, Schemas.vscodeRemoteResource);\n\t}\n\n\tset(authority: string, host: string, port: number): void {\n\t\tthis._hosts[authority] = host;\n\t\tthis._ports[authority] = port;\n\t}\n\n\tsetConnectionToken(authority: string, connectionToken: string): void {\n\t\tthis._connectionTokens[authority] = connectionToken;\n\t}\n\n\tgetPreferredWebSchema(): 'http' | 'https' {\n\t\treturn this._preferredWebSchema;\n\t}\n\n\trewrite(uri: URI): URI {\n\t\tif (this._delegate) {\n\t\t\ttry {\n\t\t\t\treturn this._delegate(uri);\n\t\t\t} catch (err) {\n\t\t\t\terrors.onUnexpectedError(err);\n\t\t\t\treturn uri;\n\t\t\t}\n\t\t}\n\t\tconst authority = uri.authority;\n\t\tlet host = this._hosts[authority];\n\t\tif (host && host.indexOf(':') !== -1 && host.indexOf('[') === -1) {\n\t\t\thost = `[${host}]`;\n\t\t}\n\t\tconst port = this._ports[authority];\n\t\tconst connectionToken = this._connectionTokens[authority];\n\t\tlet query = `path=${encodeURIComponent(uri.path)}`;\n\t\tif (typeof connectionToken === 'string') {\n\t\t\tquery += `&${connectionTokenQueryName}=${encodeURIComponent(connectionToken)}`;\n\t\t}\n\t\treturn URI.from({\n\t\t\tscheme: platform.isWeb ? this._preferredWebSchema : Schemas.vscodeRemoteResource,\n\t\t\tauthority: `${host}:${port}`,\n\t\t\tpath: platform.isWeb\n\t\t\t\t? (window.location.pathname + \"/\" + this._remoteResourcesPath).replace(/\\/\\/+/g, \"/\")\n\t\t\t\t: this._remoteResourcesPath,\n\t\t\tquery\n\t\t});\n\t}\n}\n\nexport const RemoteAuthorities = new RemoteAuthoritiesImpl();\n\nexport function getServerRootPath(product: { quality?: string; commit?: string }, basePath: string | undefined): string {\n\treturn paths.posix.join(basePath ?? '/', `${product.quality ?? 'oss'}-${product.commit ?? 'dev'}`);\n}\n\n/**\n * A string pointing to a path inside the app. It should not begin with ./ or ../\n */\nexport type AppResourcePath = (\n\t`a${string}` | `b${string}` | `c${string}` | `d${string}` | `e${string}` | `f${string}`\n\t| `g${string}` | `h${string}` | `i${string}` | `j${string}` | `k${string}` | `l${string}`\n\t| `m${string}` | `n${string}` | `o${string}` | `p${string}` | `q${string}` | `r${string}`\n\t| `s${string}` | `t${string}` | `u${string}` | `v${string}` | `w${string}` | `x${string}`\n\t| `y${string}` | `z${string}`\n);\n\nexport const builtinExtensionsPath: AppResourcePath = 'vs/../../extensions';\nexport const nodeModulesPath: AppResourcePath = 'vs/../../node_modules';\nexport const nodeModulesAsarPath: AppResourcePath = 'vs/../../node_modules.asar';\nexport const nodeModulesAsarUnpackedPath: AppResourcePath = 'vs/../../node_modules.asar.unpacked';\n\nexport const VSCODE_AUTHORITY = 'vscode-app';\n\nclass FileAccessImpl {\n\n\tprivate static readonly FALLBACK_AUTHORITY = VSCODE_AUTHORITY;\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\tasBrowserUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToBrowserUri(uri);\n\t}\n\n\t/**\n\t * Returns a URI to use in contexts where the browser is responsible\n\t * for loading (e.g. fetch()) or when used within the DOM.\n\t *\n\t * **Note:** use `dom.ts#asCSSUrl` whenever the URL is to be used in CSS context.\n\t */\n\turiToBrowserUri(uri: URI): URI {\n\t\t// Handle remote URIs via `RemoteAuthorities`\n\t\tif (uri.scheme === Schemas.vscodeRemote) {\n\t\t\treturn RemoteAuthorities.rewrite(uri);\n\t\t}\n\n\t\t// Convert to `vscode-file` resource..\n\t\tif (\n\t\t\t// ...only ever for `file` resources\n\t\t\turi.scheme === Schemas.file &&\n\t\t\t(\n\t\t\t\t// ...and we run in native environments\n\t\t\t\tplatform.isNative ||\n\t\t\t\t// ...or web worker extensions on desktop\n\t\t\t\t(platform.webWorkerOrigin === `${Schemas.vscodeFileResource}://${FileAccessImpl.FALLBACK_AUTHORITY}`)\n\t\t\t)\n\t\t) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.vscodeFileResource,\n\t\t\t\t// We need to provide an authority here so that it can serve\n\t\t\t\t// as origin for network and loading matters in chromium.\n\t\t\t\t// If the URI is not coming with an authority already, we\n\t\t\t\t// add our own\n\t\t\t\tauthority: uri.authority || FileAccessImpl.FALLBACK_AUTHORITY,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\tasFileUri(resourcePath: AppResourcePath | ''): URI {\n\t\tconst uri = this.toUri(resourcePath, require);\n\t\treturn this.uriToFileUri(uri);\n\t}\n\n\t/**\n\t * Returns the `file` URI to use in contexts where node.js\n\t * is responsible for loading.\n\t */\n\turiToFileUri(uri: URI): URI {\n\t\t// Only convert the URI if it is `vscode-file:` scheme\n\t\tif (uri.scheme === Schemas.vscodeFileResource) {\n\t\t\treturn uri.with({\n\t\t\t\tscheme: Schemas.file,\n\t\t\t\t// Only preserve the `authority` if it is different from\n\t\t\t\t// our fallback authority. This ensures we properly preserve\n\t\t\t\t// Windows UNC paths that come with their own authority.\n\t\t\t\tauthority: uri.authority !== FileAccessImpl.FALLBACK_AUTHORITY ? uri.authority : null,\n\t\t\t\tquery: null,\n\t\t\t\tfragment: null\n\t\t\t});\n\t\t}\n\n\t\treturn uri;\n\t}\n\n\tprivate toUri(uriOrModule: URI | string, moduleIdToUrl: { toUrl(moduleId: string): string }): URI {\n\t\tif (URI.isUri(uriOrModule)) {\n\t\t\treturn uriOrModule;\n\t\t}\n\n\t\treturn URI.parse(moduleIdToUrl.toUrl(uriOrModule));\n\t}\n}\n\nexport const FileAccess = new FileAccessImpl();\n\n\nexport namespace COI {\n\n\tconst coiHeaders = new Map<'3' | '2' | '1' | string, Record<string, string>>([\n\t\t['1', { 'Cross-Origin-Opener-Policy': 'same-origin' }],\n\t\t['2', { 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t\t['3', { 'Cross-Origin-Opener-Policy': 'same-origin', 'Cross-Origin-Embedder-Policy': 'require-corp' }],\n\t]);\n\n\texport const CoopAndCoep = Object.freeze(coiHeaders.get('3'));\n\n\tconst coiSearchParamName = 'vscode-coi';\n\n\t/**\n\t * Extract desired headers from `vscode-coi` invocation\n\t */\n\texport function getHeadersFromQuery(url: string | URI | URL): Record<string, string> | undefined {\n\t\tlet params: URLSearchParams | undefined;\n\t\tif (typeof url === 'string') {\n\t\t\tparams = new URL(url).searchParams;\n\t\t} else if (url instanceof URL) {\n\t\t\tparams = url.searchParams;\n\t\t} else if (URI.isUri(url)) {\n\t\t\tparams = new URL(url.toString(true)).searchParams;\n\t\t}\n\t\tconst value = params?.get(coiSearchParamName);\n\t\tif (!value) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn coiHeaders.get(value);\n\t}\n\n\t/**\n\t * Add the `vscode-coi` query attribute based on wanting `COOP` and `COEP`. Will be a noop when `crossOriginIsolated`\n\t * isn't enabled the current context\n\t */\n\texport function addSearchParam(urlOrSearch: URLSearchParams | Record<string, string>, coop: boolean, coep: boolean): void {\n\t\tif (!(<any>globalThis).crossOriginIsolated) {\n\t\t\t// depends on the current context being COI\n\t\t\treturn;\n\t\t}\n\t\tconst value = coop && coep ? '3' : coep ? '2' : '1';\n\t\tif (urlOrSearch instanceof URLSearchParams) {\n\t\t\turlOrSearch.set(coiSearchParamName, value);\n\t\t} else {\n\t\t\t(<Record<string, string>>urlOrSearch)[coiSearchParamName] = value;\n\t\t}\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CharCode } from 'vs/base/common/charCode';\nimport * as extpath from 'vs/base/common/extpath';\nimport { Schemas } from 'vs/base/common/network';\nimport * as paths from 'vs/base/common/path';\nimport { isLinux, isWindows } from 'vs/base/common/platform';\nimport { compare as strCompare, equalsIgnoreCase } from 'vs/base/common/strings';\nimport { URI, uriToFsPath } from 'vs/base/common/uri';\n\nexport function originalFSPath(uri: URI): string {\n\treturn uriToFsPath(uri, true);\n}\n\n//#region IExtUri\n\nexport interface IExtUri {\n\n\t// --- identity\n\n\t/**\n\t * Compares two uris.\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tcompare(uri1: URI, uri2: URI, ignoreFragment?: boolean): number;\n\n\t/**\n\t * Tests whether two uris are equal\n\t *\n\t * @param uri1 Uri\n\t * @param uri2 Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Tests whether a `candidate` URI is a parent or equal of a given `base` URI.\n\t *\n\t * @param base A uri which is \"longer\" or at least same length as `parentCandidate`\n\t * @param parentCandidate A uri which is \"shorter\" or up to same length as `base`\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment?: boolean): boolean;\n\n\t/**\n\t * Creates a key from a resource URI to be used to resource comparison and for resource maps.\n\t * @see {@link ResourceMap}\n\t * @param uri Uri\n\t * @param ignoreFragment Ignore the fragment (defaults to `false`)\n\t */\n\tgetComparisonKey(uri: URI, ignoreFragment?: boolean): string;\n\n\t/**\n\t * Whether the casing of the path-component of the uri should be ignored.\n\t */\n\tignorePathCasing(uri: URI): boolean;\n\n\t// --- path math\n\n\tbasenameOrAuthority(resource: URI): string;\n\n\t/**\n\t * Returns the basename of the path component of an uri.\n\t * @param resource\n\t */\n\tbasename(resource: URI): string;\n\n\t/**\n\t * Returns the extension of the path component of an uri.\n\t * @param resource\n\t */\n\textname(resource: URI): string;\n\t/**\n\t * Return a URI representing the directory of a URI path.\n\t *\n\t * @param resource The input URI.\n\t * @returns The URI representing the directory of the input URI.\n\t */\n\tdirname(resource: URI): URI;\n\t/**\n\t * Join a URI path with path fragments and normalizes the resulting path.\n\t *\n\t * @param resource The input URI.\n\t * @param pathFragment The path fragment to add to the URI path.\n\t * @returns The resulting URI.\n\t */\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI;\n\t/**\n\t * Normalizes the path part of a URI: Resolves `.` and `..` elements with directory names.\n\t *\n\t * @param resource The URI to normalize the path.\n\t * @returns The URI with the normalized path.\n\t */\n\tnormalizePath(resource: URI): URI;\n\t/**\n\t *\n\t * @param from\n\t * @param to\n\t */\n\trelativePath(from: URI, to: URI): string | undefined;\n\t/**\n\t * Resolves an absolute or relative path against a base URI.\n\t * The path can be relative or absolute posix or a Windows path\n\t */\n\tresolvePath(base: URI, path: string): URI;\n\n\t// --- misc\n\n\t/**\n\t * Returns true if the URI path is absolute.\n\t */\n\tisAbsolutePath(resource: URI): boolean;\n\t/**\n\t * Tests whether the two authorities are the same\n\t */\n\tisEqualAuthority(a1: string, a2: string): boolean;\n\t/**\n\t * Returns true if the URI path has a trailing path separator\n\t */\n\thasTrailingPathSeparator(resource: URI, sep?: string): boolean;\n\t/**\n\t * Removes a trailing path separator, if there's one.\n\t * Important: Doesn't remove the first slash, it would make the URI invalid\n\t */\n\tremoveTrailingPathSeparator(resource: URI, sep?: string): URI;\n\t/**\n\t * Adds a trailing path separator to the URI if there isn't one already.\n\t * For example, c:\\ would be unchanged, but c:\\users would become c:\\users\\\n\t */\n\taddTrailingPathSeparator(resource: URI, sep?: string): URI;\n}\n\nexport class ExtUri implements IExtUri {\n\n\tconstructor(private _ignorePathCasing: (uri: URI) => boolean) { }\n\n\tcompare(uri1: URI, uri2: URI, ignoreFragment: boolean = false): number {\n\t\tif (uri1 === uri2) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn strCompare(this.getComparisonKey(uri1, ignoreFragment), this.getComparisonKey(uri2, ignoreFragment));\n\t}\n\n\tisEqual(uri1: URI | undefined, uri2: URI | undefined, ignoreFragment: boolean = false): boolean {\n\t\tif (uri1 === uri2) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!uri1 || !uri2) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this.getComparisonKey(uri1, ignoreFragment) === this.getComparisonKey(uri2, ignoreFragment);\n\t}\n\n\tgetComparisonKey(uri: URI, ignoreFragment: boolean = false): string {\n\t\treturn uri.with({\n\t\t\tpath: this._ignorePathCasing(uri) ? uri.path.toLowerCase() : undefined,\n\t\t\tfragment: ignoreFragment ? null : undefined\n\t\t}).toString();\n\t}\n\n\tignorePathCasing(uri: URI): boolean {\n\t\treturn this._ignorePathCasing(uri);\n\t}\n\n\tisEqualOrParent(base: URI, parentCandidate: URI, ignoreFragment: boolean = false): boolean {\n\t\tif (base.scheme === parentCandidate.scheme) {\n\t\t\tif (base.scheme === Schemas.file) {\n\t\t\t\treturn extpath.isEqualOrParent(originalFSPath(base), originalFSPath(parentCandidate), this._ignorePathCasing(base)) && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t\tif (isEqualAuthority(base.authority, parentCandidate.authority)) {\n\t\t\t\treturn extpath.isEqualOrParent(base.path, parentCandidate.path, this._ignorePathCasing(base), '/') && base.query === parentCandidate.query && (ignoreFragment || base.fragment === parentCandidate.fragment);\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t// --- path math\n\n\tjoinPath(resource: URI, ...pathFragment: string[]): URI {\n\t\treturn URI.joinPath(resource, ...pathFragment);\n\t}\n\n\tbasenameOrAuthority(resource: URI): string {\n\t\treturn basename(resource) || resource.authority;\n\t}\n\n\tbasename(resource: URI): string {\n\t\treturn paths.posix.basename(resource.path);\n\t}\n\n\textname(resource: URI): string {\n\t\treturn paths.posix.extname(resource.path);\n\t}\n\n\tdirname(resource: URI): URI {\n\t\tif (resource.path.length === 0) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet dirname;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tdirname = URI.file(paths.dirname(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tdirname = paths.posix.dirname(resource.path);\n\t\t\tif (resource.authority && dirname.length && dirname.charCodeAt(0) !== CharCode.Slash) {\n\t\t\t\tconsole.error(`dirname(\"${resource.toString})) resulted in a relative path`);\n\t\t\t\tdirname = '/'; // If a URI contains an authority component, then the path component must either be empty or begin with a CharCode.Slash (\"/\") character\n\t\t\t}\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: dirname\n\t\t});\n\t}\n\n\tnormalizePath(resource: URI): URI {\n\t\tif (!resource.path.length) {\n\t\t\treturn resource;\n\t\t}\n\t\tlet normalizedPath: string;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tnormalizedPath = URI.file(paths.normalize(originalFSPath(resource))).path;\n\t\t} else {\n\t\t\tnormalizedPath = paths.posix.normalize(resource.path);\n\t\t}\n\t\treturn resource.with({\n\t\t\tpath: normalizedPath\n\t\t});\n\t}\n\n\trelativePath(from: URI, to: URI): string | undefined {\n\t\tif (from.scheme !== to.scheme || !isEqualAuthority(from.authority, to.authority)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tif (from.scheme === Schemas.file) {\n\t\t\tconst relativePath = paths.relative(originalFSPath(from), originalFSPath(to));\n\t\t\treturn isWindows ? extpath.toSlashes(relativePath) : relativePath;\n\t\t}\n\t\tlet fromPath = from.path || '/';\n\t\tconst toPath = to.path || '/';\n\t\tif (this._ignorePathCasing(from)) {\n\t\t\t// make casing of fromPath match toPath\n\t\t\tlet i = 0;\n\t\t\tfor (const len = Math.min(fromPath.length, toPath.length); i < len; i++) {\n\t\t\t\tif (fromPath.charCodeAt(i) !== toPath.charCodeAt(i)) {\n\t\t\t\t\tif (fromPath.charAt(i).toLowerCase() !== toPath.charAt(i).toLowerCase()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfromPath = toPath.substr(0, i) + fromPath.substr(i);\n\t\t}\n\t\treturn paths.posix.relative(fromPath, toPath);\n\t}\n\n\tresolvePath(base: URI, path: string): URI {\n\t\tif (base.scheme === Schemas.file) {\n\t\t\tconst newURI = URI.file(paths.resolve(originalFSPath(base), path));\n\t\t\treturn base.with({\n\t\t\t\tauthority: newURI.authority,\n\t\t\t\tpath: newURI.path\n\t\t\t});\n\t\t}\n\t\tpath = extpath.toPosixPath(path); // we allow path to be a windows path\n\t\treturn base.with({\n\t\t\tpath: paths.posix.resolve(base.path, path)\n\t\t});\n\t}\n\n\t// --- misc\n\n\tisAbsolutePath(resource: URI): boolean {\n\t\treturn !!resource.path && resource.path[0] === '/';\n\t}\n\n\tisEqualAuthority(a1: string | undefined, a2: string | undefined) {\n\t\treturn a1 === a2 || (a1 !== undefined && a2 !== undefined && equalsIgnoreCase(a1, a2));\n\t}\n\n\thasTrailingPathSeparator(resource: URI, sep: string = paths.sep): boolean {\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\treturn fsp.length > extpath.getRoot(fsp).length && fsp[fsp.length - 1] === sep;\n\t\t} else {\n\t\t\tconst p = resource.path;\n\t\t\treturn (p.length > 1 && p.charCodeAt(p.length - 1) === CharCode.Slash) && !(/^[a-zA-Z]:(\\/$|\\\\$)/.test(resource.fsPath)); // ignore the slash at offset 0\n\t\t}\n\t}\n\n\tremoveTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\t// Make sure that the path isn't a drive letter. A trailing separator there is not removable.\n\t\tif (hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path.substr(0, resource.path.length - 1) });\n\t\t}\n\t\treturn resource;\n\t}\n\n\taddTrailingPathSeparator(resource: URI, sep: string = paths.sep): URI {\n\t\tlet isRootSep: boolean = false;\n\t\tif (resource.scheme === Schemas.file) {\n\t\t\tconst fsp = originalFSPath(resource);\n\t\t\tisRootSep = ((fsp !== undefined) && (fsp.length === extpath.getRoot(fsp).length) && (fsp[fsp.length - 1] === sep));\n\t\t} else {\n\t\t\tsep = '/';\n\t\t\tconst p = resource.path;\n\t\t\tisRootSep = p.length === 1 && p.charCodeAt(p.length - 1) === CharCode.Slash;\n\t\t}\n\t\tif (!isRootSep && !hasTrailingPathSeparator(resource, sep)) {\n\t\t\treturn resource.with({ path: resource.path + '/' });\n\t\t}\n\t\treturn resource;\n\t}\n}\n\n\n/**\n * Unbiased utility that takes uris \"as they are\". This means it can be interchanged with\n * uri#toString() usages. The following is true\n * ```\n * assertEqual(aUri.toString() === bUri.toString(), exturi.isEqual(aUri, bUri))\n * ```\n */\nexport const extUri = new ExtUri(() => false);\n\n/**\n * BIASED utility that _mostly_ ignored the case of urs paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriBiasedIgnorePathCase = new ExtUri(uri => {\n\t// A file scheme resource is in the same platform as code, so ignore case for non linux platforms\n\t// Resource can be from another platform. Lowering the case as an hack. Should come from File system provider\n\treturn uri.scheme === Schemas.file ? !isLinux : true;\n});\n\n\n/**\n * BIASED utility that always ignores the casing of uris paths. ONLY use this util if you\n * understand what you are doing.\n *\n * This utility is INCOMPATIBLE with `uri.toString()`-usages and both CANNOT be used interchanged.\n *\n * When dealing with uris from files or documents, `extUri` (the unbiased friend)is sufficient\n * because those uris come from a \"trustworthy source\". When creating unknown uris it's always\n * better to use `IUriIdentityService` which exposes an `IExtUri`-instance which knows when path\n * casing matters.\n */\nexport const extUriIgnorePathCase = new ExtUri(_ => true);\n\nexport const isEqual = extUri.isEqual.bind(extUri);\nexport const isEqualOrParent = extUri.isEqualOrParent.bind(extUri);\nexport const getComparisonKey = extUri.getComparisonKey.bind(extUri);\nexport const basenameOrAuthority = extUri.basenameOrAuthority.bind(extUri);\nexport const basename = extUri.basename.bind(extUri);\nexport const extname = extUri.extname.bind(extUri);\nexport const dirname = extUri.dirname.bind(extUri);\nexport const joinPath = extUri.joinPath.bind(extUri);\nexport const normalizePath = extUri.normalizePath.bind(extUri);\nexport const relativePath = extUri.relativePath.bind(extUri);\nexport const resolvePath = extUri.resolvePath.bind(extUri);\nexport const isAbsolutePath = extUri.isAbsolutePath.bind(extUri);\nexport const isEqualAuthority = extUri.isEqualAuthority.bind(extUri);\nexport const hasTrailingPathSeparator = extUri.hasTrailingPathSeparator.bind(extUri);\nexport const removeTrailingPathSeparator = extUri.removeTrailingPathSeparator.bind(extUri);\nexport const addTrailingPathSeparator = extUri.addTrailingPathSeparator.bind(extUri);\n\n//#endregion\n\nexport function distinctParents<T>(items: T[], resourceAccessor: (item: T) => URI): T[] {\n\tconst distinctParents: T[] = [];\n\tfor (let i = 0; i < items.length; i++) {\n\t\tconst candidateResource = resourceAccessor(items[i]);\n\t\tif (items.some((otherItem, index) => {\n\t\t\tif (index === i) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn isEqualOrParent(candidateResource, resourceAccessor(otherItem));\n\t\t})) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tdistinctParents.push(items[i]);\n\t}\n\n\treturn distinctParents;\n}\n\n/**\n * Data URI related helpers.\n */\nexport namespace DataUri {\n\n\texport const META_DATA_LABEL = 'label';\n\texport const META_DATA_DESCRIPTION = 'description';\n\texport const META_DATA_SIZE = 'size';\n\texport const META_DATA_MIME = 'mime';\n\n\texport function parseMetaData(dataUri: URI): Map<string, string> {\n\t\tconst metadata = new Map<string, string>();\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the metadata is: size:2313;label:SomeLabel;description:SomeDescription\n\t\tconst meta = dataUri.path.substring(dataUri.path.indexOf(';') + 1, dataUri.path.lastIndexOf(';'));\n\t\tmeta.split(';').forEach(property => {\n\t\t\tconst [key, value] = property.split(':');\n\t\t\tif (key && value) {\n\t\t\t\tmetadata.set(key, value);\n\t\t\t}\n\t\t});\n\n\t\t// Given a URI of:  data:image/png;size:2313;label:SomeLabel;description:SomeDescription;base64,77+9UE5...\n\t\t// the mime is: image/png\n\t\tconst mime = dataUri.path.substring(0, dataUri.path.indexOf(';'));\n\t\tif (mime) {\n\t\t\tmetadata.set(META_DATA_MIME, mime);\n\t\t}\n\n\t\treturn metadata;\n\t}\n}\n\nexport function toLocalResource(resource: URI, authority: string | undefined, localScheme: string): URI {\n\tif (authority) {\n\t\tlet path = resource.path;\n\t\tif (path && path[0] !== paths.posix.sep) {\n\t\t\tpath = paths.posix.sep + path;\n\t\t}\n\n\t\treturn resource.with({ scheme: localScheme, authority, path });\n\t}\n\n\treturn resource.with({ scheme: localScheme });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { BugIndicatingError, CancellationError } from 'vs/base/common/errors';\nimport { Emitter, Event } from 'vs/base/common/event';\nimport { Disposable, DisposableMap, DisposableStore, IDisposable, MutableDisposable, toDisposable } from 'vs/base/common/lifecycle';\nimport { extUri as defaultExtUri, IExtUri } from 'vs/base/common/resources';\nimport { URI } from 'vs/base/common/uri';\nimport { setTimeout0 } from 'vs/base/common/platform';\nimport { MicrotaskDelay } from './symbols';\nimport { Lazy } from 'vs/base/common/lazy';\n\nexport function isThenable<T>(obj: unknown): obj is Promise<T> {\n\treturn !!obj && typeof (obj as unknown as Promise<T>).then === 'function';\n}\n\nexport interface CancelablePromise<T> extends Promise<T> {\n\tcancel(): void;\n}\n\nexport function createCancelablePromise<T>(callback: (token: CancellationToken) => Promise<T>): CancelablePromise<T> {\n\tconst source = new CancellationTokenSource();\n\n\tconst thenable = callback(source.token);\n\tconst promise = new Promise<T>((resolve, reject) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tPromise.resolve(thenable).then(value => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\tresolve(value);\n\t\t}, err => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\treject(err);\n\t\t});\n\t});\n\n\treturn <CancelablePromise<T>>new class {\n\t\tcancel() {\n\t\t\tsource.cancel();\n\t\t\tsource.dispose();\n\t\t}\n\t\tthen<TResult1 = T, TResult2 = never>(resolve?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, reject?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2> {\n\t\t\treturn promise.then(resolve, reject);\n\t\t}\n\t\tcatch<TResult = never>(reject?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult> {\n\t\t\treturn this.then(undefined, reject);\n\t\t}\n\t\tfinally(onfinally?: (() => void) | undefined | null): Promise<T> {\n\t\t\treturn promise.finally(onfinally);\n\t\t}\n\t};\n}\n\n/**\n * Returns a promise that resolves with `undefined` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken): Promise<T | undefined>;\n\n/**\n * Returns a promise that resolves with `defaultValue` as soon as the passed token is cancelled.\n * @see {@link raceCancellationError}\n */\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue: T): Promise<T>;\n\nexport function raceCancellation<T>(promise: Promise<T>, token: CancellationToken, defaultValue?: T): Promise<T | undefined> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\tresolve(defaultValue);\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns a promise that rejects with an {@CancellationError} as soon as the passed token is cancelled.\n * @see {@link raceCancellation}\n */\nexport function raceCancellationError<T>(promise: Promise<T>, token: CancellationToken): Promise<T> {\n\treturn new Promise((resolve, reject) => {\n\t\tconst ref = token.onCancellationRequested(() => {\n\t\t\tref.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t\tpromise.then(resolve, reject).finally(() => ref.dispose());\n\t});\n}\n\n/**\n * Returns as soon as one of the promises resolves or rejects and cancels remaining promises\n */\nexport async function raceCancellablePromises<T>(cancellablePromises: CancelablePromise<T>[]): Promise<T> {\n\tlet resolvedPromiseIndex = -1;\n\tconst promises = cancellablePromises.map((promise, index) => promise.then(result => { resolvedPromiseIndex = index; return result; }));\n\ttry {\n\t\tconst result = await Promise.race(promises);\n\t\treturn result;\n\t} finally {\n\t\tcancellablePromises.forEach((cancellablePromise, index) => {\n\t\t\tif (index !== resolvedPromiseIndex) {\n\t\t\t\tcancellablePromise.cancel();\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function raceTimeout<T>(promise: Promise<T>, timeout: number, onTimeout?: () => void): Promise<T | undefined> {\n\tlet promiseResolve: ((value: T | undefined) => void) | undefined = undefined;\n\n\tconst timer = setTimeout(() => {\n\t\tpromiseResolve?.(undefined);\n\t\tonTimeout?.();\n\t}, timeout);\n\n\treturn Promise.race([\n\t\tpromise.finally(() => clearTimeout(timer)),\n\t\tnew Promise<T | undefined>(resolve => promiseResolve = resolve)\n\t]);\n}\n\nexport function asPromise<T>(callback: () => T | Thenable<T>): Promise<T> {\n\treturn new Promise<T>((resolve, reject) => {\n\t\tconst item = callback();\n\t\tif (isThenable<T>(item)) {\n\t\t\titem.then(resolve, reject);\n\t\t} else {\n\t\t\tresolve(item);\n\t\t}\n\t});\n}\n\n/**\n * Creates and returns a new promise, plus its `resolve` and `reject` callbacks.\n *\n * Replace with standardized [`Promise.withResolvers`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers) once it is supported\n */\nexport function promiseWithResolvers<T>(): { promise: Promise<T>; resolve: (value: T | PromiseLike<T>) => void; reject: (err?: any) => void } {\n\tlet resolve: (value: T | PromiseLike<T>) => void;\n\tlet reject: (reason?: any) => void;\n\tconst promise = new Promise<T>((res, rej) => {\n\t\tresolve = res;\n\t\treject = rej;\n\t});\n\treturn { promise, resolve: resolve!, reject: reject! };\n}\n\nexport interface ITask<T> {\n\t(): T;\n}\n\n/**\n * A helper to prevent accumulation of sequential async tasks.\n *\n * Imagine a mail man with the sole task of delivering letters. As soon as\n * a letter submitted for delivery, he drives to the destination, delivers it\n * and returns to his base. Imagine that during the trip, N more letters were submitted.\n * When the mail man returns, he picks those N letters and delivers them all in a\n * single trip. Even though N+1 submissions occurred, only 2 deliveries were made.\n *\n * The throttler implements this via the queue() method, by providing it a task\n * factory. Following the example:\n *\n * \t\tconst throttler = new Throttler();\n * \t\tconst letters = [];\n *\n * \t\tfunction deliver() {\n * \t\t\tconst lettersToDeliver = letters;\n * \t\t\tletters = [];\n * \t\t\treturn makeTheTrip(lettersToDeliver);\n * \t\t}\n *\n * \t\tfunction onLetterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tthrottler.queue(deliver);\n * \t\t}\n */\nexport class Throttler implements IDisposable {\n\n\tprivate activePromise: Promise<any> | null;\n\tprivate queuedPromise: Promise<any> | null;\n\tprivate queuedPromiseFactory: ITask<Promise<any>> | null;\n\n\tprivate isDisposed = false;\n\n\tconstructor() {\n\t\tthis.activePromise = null;\n\t\tthis.queuedPromise = null;\n\t\tthis.queuedPromiseFactory = null;\n\t}\n\n\tqueue<T>(promiseFactory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this.isDisposed) {\n\t\t\treturn Promise.reject(new Error('Throttler is disposed'));\n\t\t}\n\n\t\tif (this.activePromise) {\n\t\t\tthis.queuedPromiseFactory = promiseFactory;\n\n\t\t\tif (!this.queuedPromise) {\n\t\t\t\tconst onComplete = () => {\n\t\t\t\t\tthis.queuedPromise = null;\n\n\t\t\t\t\tif (this.isDisposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst result = this.queue(this.queuedPromiseFactory!);\n\t\t\t\t\tthis.queuedPromiseFactory = null;\n\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\n\t\t\t\tthis.queuedPromise = new Promise(resolve => {\n\t\t\t\t\tthis.activePromise!.then(onComplete, onComplete).then(resolve);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tthis.queuedPromise!.then(resolve, reject);\n\t\t\t});\n\t\t}\n\n\t\tthis.activePromise = promiseFactory();\n\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.activePromise!.then((result: T) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\tresolve(result);\n\t\t\t}, (err: unknown) => {\n\t\t\t\tthis.activePromise = null;\n\t\t\t\treject(err);\n\t\t\t});\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.isDisposed = true;\n\t}\n}\n\nexport class Sequencer {\n\n\tprivate current: Promise<unknown> = Promise.resolve(null);\n\n\tqueue<T>(promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\treturn this.current = this.current.then(() => promiseTask(), () => promiseTask());\n\t}\n}\n\nexport class SequencerByKey<TKey> {\n\n\tprivate promiseMap = new Map<TKey, Promise<unknown>>();\n\n\tqueue<T>(key: TKey, promiseTask: ITask<Promise<T>>): Promise<T> {\n\t\tconst runningPromise = this.promiseMap.get(key) ?? Promise.resolve();\n\t\tconst newPromise = runningPromise\n\t\t\t.catch(() => { })\n\t\t\t.then(promiseTask)\n\t\t\t.finally(() => {\n\t\t\t\tif (this.promiseMap.get(key) === newPromise) {\n\t\t\t\t\tthis.promiseMap.delete(key);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.promiseMap.set(key, newPromise);\n\t\treturn newPromise;\n\t}\n}\n\ninterface IScheduledLater extends IDisposable {\n\tisTriggered(): boolean;\n}\n\nconst timeoutDeferred = (timeout: number, fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tconst handle = setTimeout(() => {\n\t\tscheduled = false;\n\t\tfn();\n\t}, timeout);\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => {\n\t\t\tclearTimeout(handle);\n\t\t\tscheduled = false;\n\t\t},\n\t};\n};\n\nconst microtaskDeferred = (fn: () => void): IScheduledLater => {\n\tlet scheduled = true;\n\tqueueMicrotask(() => {\n\t\tif (scheduled) {\n\t\t\tscheduled = false;\n\t\t\tfn();\n\t\t}\n\t});\n\n\treturn {\n\t\tisTriggered: () => scheduled,\n\t\tdispose: () => { scheduled = false; },\n\t};\n};\n\n/**\n * A helper to delay (debounce) execution of a task that is being requested often.\n *\n * Following the throttler, now imagine the mail man wants to optimize the number of\n * trips proactively. The trip itself can be long, so he decides not to make the trip\n * as soon as a letter is submitted. Instead he waits a while, in case more\n * letters are submitted. After said waiting period, if no letters were submitted, he\n * decides to make the trip. Imagine that N more letters were submitted after the first\n * one, all within a short period of time between each other. Even though N+1\n * submissions occurred, only 1 delivery was made.\n *\n * The delayer offers this behavior via the trigger() method, into which both the task\n * to be executed and the waiting period (delay) must be passed in as arguments. Following\n * the example:\n *\n * \t\tconst delayer = new Delayer(WAITING_PERIOD);\n * \t\tconst letters = [];\n *\n * \t\tfunction letterReceived(l) {\n * \t\t\tletters.push(l);\n * \t\t\tdelayer.trigger(() => { return makeTheTrip(); });\n * \t\t}\n */\nexport class Delayer<T> implements IDisposable {\n\n\tprivate deferred: IScheduledLater | null;\n\tprivate completionPromise: Promise<any> | null;\n\tprivate doResolve: ((value?: any | Promise<any>) => void) | null;\n\tprivate doReject: ((err: any) => void) | null;\n\tprivate task: ITask<T | Promise<T>> | null;\n\n\tconstructor(public defaultDelay: number | typeof MicrotaskDelay) {\n\t\tthis.deferred = null;\n\t\tthis.completionPromise = null;\n\t\tthis.doResolve = null;\n\t\tthis.doReject = null;\n\t\tthis.task = null;\n\t}\n\n\ttrigger(task: ITask<T | Promise<T>>, delay = this.defaultDelay): Promise<T> {\n\t\tthis.task = task;\n\t\tthis.cancelTimeout();\n\n\t\tif (!this.completionPromise) {\n\t\t\tthis.completionPromise = new Promise((resolve, reject) => {\n\t\t\t\tthis.doResolve = resolve;\n\t\t\t\tthis.doReject = reject;\n\t\t\t}).then(() => {\n\t\t\t\tthis.completionPromise = null;\n\t\t\t\tthis.doResolve = null;\n\t\t\t\tif (this.task) {\n\t\t\t\t\tconst task = this.task;\n\t\t\t\t\tthis.task = null;\n\t\t\t\t\treturn task();\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t});\n\t\t}\n\n\t\tconst fn = () => {\n\t\t\tthis.deferred = null;\n\t\t\tthis.doResolve?.(null);\n\t\t};\n\n\t\tthis.deferred = delay === MicrotaskDelay ? microtaskDeferred(fn) : timeoutDeferred(delay, fn);\n\n\t\treturn this.completionPromise;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn !!this.deferred?.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.cancelTimeout();\n\n\t\tif (this.completionPromise) {\n\t\t\tthis.doReject?.(new CancellationError());\n\t\t\tthis.completionPromise = null;\n\t\t}\n\t}\n\n\tprivate cancelTimeout(): void {\n\t\tthis.deferred?.dispose();\n\t\tthis.deferred = null;\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\n/**\n * A helper to delay execution of a task that is being requested often, while\n * preventing accumulation of consecutive executions, while the task runs.\n *\n * The mail man is clever and waits for a certain amount of time, before going\n * out to deliver letters. While the mail man is going out, more letters arrive\n * and can only be delivered once he is back. Once he is back the mail man will\n * do one more trip to deliver the letters that have accumulated while he was out.\n */\nexport class ThrottledDelayer<T> {\n\n\tprivate delayer: Delayer<Promise<T>>;\n\tprivate throttler: Throttler;\n\n\tconstructor(defaultDelay: number) {\n\t\tthis.delayer = new Delayer(defaultDelay);\n\t\tthis.throttler = new Throttler();\n\t}\n\n\ttrigger(promiseFactory: ITask<Promise<T>>, delay?: number): Promise<T> {\n\t\treturn this.delayer.trigger(() => this.throttler.queue(promiseFactory), delay) as unknown as Promise<T>;\n\t}\n\n\tisTriggered(): boolean {\n\t\treturn this.delayer.isTriggered();\n\t}\n\n\tcancel(): void {\n\t\tthis.delayer.cancel();\n\t}\n\n\tdispose(): void {\n\t\tthis.delayer.dispose();\n\t\tthis.throttler.dispose();\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently.\n */\nexport class Barrier {\n\tprivate _isOpen: boolean;\n\tprivate _promise: Promise<boolean>;\n\tprivate _completePromise!: (v: boolean) => void;\n\n\tconstructor() {\n\t\tthis._isOpen = false;\n\t\tthis._promise = new Promise<boolean>((c, e) => {\n\t\t\tthis._completePromise = c;\n\t\t});\n\t}\n\n\tisOpen(): boolean {\n\t\treturn this._isOpen;\n\t}\n\n\topen(): void {\n\t\tthis._isOpen = true;\n\t\tthis._completePromise(true);\n\t}\n\n\twait(): Promise<boolean> {\n\t\treturn this._promise;\n\t}\n}\n\n/**\n * A barrier that is initially closed and then becomes opened permanently after a certain period of\n * time or when open is called explicitly\n */\nexport class AutoOpenBarrier extends Barrier {\n\n\tprivate readonly _timeout: any;\n\n\tconstructor(autoOpenTimeMs: number) {\n\t\tsuper();\n\t\tthis._timeout = setTimeout(() => this.open(), autoOpenTimeMs);\n\t}\n\n\toverride open(): void {\n\t\tclearTimeout(this._timeout);\n\t\tsuper.open();\n\t}\n}\n\nexport function timeout(millis: number): CancelablePromise<void>;\nexport function timeout(millis: number, token: CancellationToken): Promise<void>;\nexport function timeout(millis: number, token?: CancellationToken): CancelablePromise<void> | Promise<void> {\n\tif (!token) {\n\t\treturn createCancelablePromise(token => timeout(millis, token));\n\t}\n\n\treturn new Promise((resolve, reject) => {\n\t\tconst handle = setTimeout(() => {\n\t\t\tdisposable.dispose();\n\t\t\tresolve();\n\t\t}, millis);\n\t\tconst disposable = token.onCancellationRequested(() => {\n\t\t\tclearTimeout(handle);\n\t\t\tdisposable.dispose();\n\t\t\treject(new CancellationError());\n\t\t});\n\t});\n}\n\n/**\n * Creates a timeout that can be disposed using its returned value.\n * @param handler The timeout handler.\n * @param timeout An optional timeout in milliseconds.\n * @param store An optional {@link DisposableStore} that will have the timeout disposable managed automatically.\n *\n * @example\n * const store = new DisposableStore;\n * // Call the timeout after 1000ms at which point it will be automatically\n * // evicted from the store.\n * const timeoutDisposable = disposableTimeout(() => {}, 1000, store);\n *\n * if (foo) {\n *   // Cancel the timeout and evict it from store.\n *   timeoutDisposable.dispose();\n * }\n */\nexport function disposableTimeout(handler: () => void, timeout = 0, store?: DisposableStore): IDisposable {\n\tconst timer = setTimeout(() => {\n\t\thandler();\n\t\tif (store) {\n\t\t\tdisposable.dispose();\n\t\t}\n\t}, timeout);\n\tconst disposable = toDisposable(() => {\n\t\tclearTimeout(timer);\n\t\tstore?.deleteAndLeak(disposable);\n\t});\n\tstore?.add(disposable);\n\treturn disposable;\n}\n\n/**\n * Runs the provided list of promise factories in sequential order. The returned\n * promise will complete to an array of results from each promise.\n */\n\nexport function sequence<T>(promiseFactories: ITask<Promise<T>>[]): Promise<T[]> {\n\tconst results: T[] = [];\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tfunction next(): Promise<T> | null {\n\t\treturn index < len ? promiseFactories[index++]() : null;\n\t}\n\n\tfunction thenHandler(result: any): Promise<any> {\n\t\tif (result !== undefined && result !== null) {\n\t\t\tresults.push(result);\n\t\t}\n\n\t\tconst n = next();\n\t\tif (n) {\n\t\t\treturn n.then(thenHandler);\n\t\t}\n\n\t\treturn Promise.resolve(results);\n\t}\n\n\treturn Promise.resolve(null).then(thenHandler);\n}\n\nexport function first<T>(promiseFactories: ITask<Promise<T>>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null): Promise<T | null> {\n\tlet index = 0;\n\tconst len = promiseFactories.length;\n\n\tconst loop: () => Promise<T | null> = () => {\n\t\tif (index >= len) {\n\t\t\treturn Promise.resolve(defaultValue);\n\t\t}\n\n\t\tconst factory = promiseFactories[index++];\n\t\tconst promise = Promise.resolve(factory());\n\n\t\treturn promise.then(result => {\n\t\t\tif (shouldStop(result)) {\n\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\n\t\t\treturn loop();\n\t\t});\n\t};\n\n\treturn loop();\n}\n\n/**\n * Returns the result of the first promise that matches the \"shouldStop\",\n * running all promises in parallel. Supports cancelable promises.\n */\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop?: (t: T) => boolean, defaultValue?: T | null): Promise<T | null>;\nexport function firstParallel<T, R extends T>(promiseList: Promise<T>[], shouldStop: (t: T) => t is R, defaultValue?: R | null): Promise<R | null>;\nexport function firstParallel<T>(promiseList: Promise<T>[], shouldStop: (t: T) => boolean = t => !!t, defaultValue: T | null = null) {\n\tif (promiseList.length === 0) {\n\t\treturn Promise.resolve(defaultValue);\n\t}\n\n\tlet todo = promiseList.length;\n\tconst finish = () => {\n\t\ttodo = -1;\n\t\tfor (const promise of promiseList) {\n\t\t\t(promise as Partial<CancelablePromise<T>>).cancel?.();\n\t\t}\n\t};\n\n\treturn new Promise<T | null>((resolve, reject) => {\n\t\tfor (const promise of promiseList) {\n\t\t\tpromise.then(result => {\n\t\t\t\tif (--todo >= 0 && shouldStop(result)) {\n\t\t\t\t\tfinish();\n\t\t\t\t\tresolve(result);\n\t\t\t\t} else if (todo === 0) {\n\t\t\t\t\tresolve(defaultValue);\n\t\t\t\t}\n\t\t\t})\n\t\t\t\t.catch(err => {\n\t\t\t\t\tif (--todo >= 0) {\n\t\t\t\t\t\tfinish();\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t});\n}\n\ninterface ILimitedTaskFactory<T> {\n\tfactory: ITask<Promise<T>>;\n\tc: (value: T | Promise<T>) => void;\n\te: (error?: unknown) => void;\n}\n\nexport interface ILimiter<T> {\n\n\treadonly size: number;\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T>;\n\n\tclear(): void;\n}\n\n/**\n * A helper to queue N promises and run them all with a max degree of parallelism. The helper\n * ensures that at any time no more than M promises are running at the same time.\n */\nexport class Limiter<T> implements ILimiter<T> {\n\n\tprivate _size = 0;\n\tprivate _isDisposed = false;\n\tprivate runningPromises: number;\n\tprivate readonly maxDegreeOfParalellism: number;\n\tprivate readonly outstandingPromises: ILimitedTaskFactory<T>[];\n\tprivate readonly _onDrained: Emitter<void>;\n\n\tconstructor(maxDegreeOfParalellism: number) {\n\t\tthis.maxDegreeOfParalellism = maxDegreeOfParalellism;\n\t\tthis.outstandingPromises = [];\n\t\tthis.runningPromises = 0;\n\t\tthis._onDrained = new Emitter<void>();\n\t}\n\n\t/**\n\t *\n\t * @returns A promise that resolved when all work is done (onDrained) or when\n\t * there is nothing to do\n\t */\n\twhenIdle(): Promise<void> {\n\t\treturn this.size > 0\n\t\t\t? Event.toPromise(this.onDrained)\n\t\t\t: Promise.resolve();\n\t}\n\n\tget onDrained(): Event<void> {\n\t\treturn this._onDrained.event;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tqueue(factory: ITask<Promise<T>>): Promise<T> {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis._size++;\n\n\t\treturn new Promise<T>((c, e) => {\n\t\t\tthis.outstandingPromises.push({ factory, c, e });\n\t\t\tthis.consume();\n\t\t});\n\t}\n\n\tprivate consume(): void {\n\t\twhile (this.outstandingPromises.length && this.runningPromises < this.maxDegreeOfParalellism) {\n\t\t\tconst iLimitedTask = this.outstandingPromises.shift()!;\n\t\t\tthis.runningPromises++;\n\n\t\t\tconst promise = iLimitedTask.factory();\n\t\t\tpromise.then(iLimitedTask.c, iLimitedTask.e);\n\t\t\tpromise.then(() => this.consumed(), () => this.consumed());\n\t\t}\n\t}\n\n\tprivate consumed(): void {\n\t\tif (this._isDisposed) {\n\t\t\treturn;\n\t\t}\n\t\tthis.runningPromises--;\n\t\tif (--this._size === 0) {\n\t\t\tthis._onDrained.fire();\n\t\t}\n\n\t\tif (this.outstandingPromises.length > 0) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\tclear(): void {\n\t\tif (this._isDisposed) {\n\t\t\tthrow new Error('Object has been disposed');\n\t\t}\n\t\tthis.outstandingPromises.length = 0;\n\t\tthis._size = this.runningPromises;\n\t}\n\n\tdispose(): void {\n\t\tthis._isDisposed = true;\n\t\tthis.outstandingPromises.length = 0; // stop further processing\n\t\tthis._size = 0;\n\t\tthis._onDrained.dispose();\n\t}\n}\n\n/**\n * A queue is handles one promise at a time and guarantees that at any time only one promise is executing.\n */\nexport class Queue<T> extends Limiter<T> {\n\n\tconstructor() {\n\t\tsuper(1);\n\t}\n}\n\n/**\n * Same as `Queue`, ensures that only 1 task is executed at the same time. The difference to `Queue` is that\n * there is only 1 task about to be scheduled next. As such, calling `queue` while a task is executing will\n * replace the currently queued task until it executes.\n *\n * As such, the returned promise may not be from the factory that is passed in but from the next factory that\n * is running after having called `queue`.\n */\nexport class LimitedQueue {\n\n\tprivate readonly sequentializer = new TaskSequentializer();\n\n\tprivate tasks = 0;\n\n\tqueue(factory: ITask<Promise<void>>): Promise<void> {\n\t\tif (!this.sequentializer.isRunning()) {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t}\n\n\t\treturn this.sequentializer.queue(() => {\n\t\t\treturn this.sequentializer.run(this.tasks++, factory());\n\t\t});\n\t}\n}\n\n/**\n * A helper to organize queues per resource. The ResourceQueue makes sure to manage queues per resource\n * by disposing them once the queue is empty.\n */\nexport class ResourceQueue implements IDisposable {\n\n\tprivate readonly queues = new Map<string, Queue<void>>();\n\n\tprivate readonly drainers = new Set<DeferredPromise<void>>();\n\n\tprivate drainListeners: DisposableMap<number> | undefined = undefined;\n\tprivate drainListenerCount = 0;\n\n\tasync whenDrained(): Promise<void> {\n\t\tif (this.isDrained()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst promise = new DeferredPromise<void>();\n\t\tthis.drainers.add(promise);\n\n\t\treturn promise.p;\n\t}\n\n\tprivate isDrained(): boolean {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tif (queue.size > 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tqueueSize(resource: URI, extUri: IExtUri = defaultExtUri): number {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\treturn this.queues.get(key)?.size ?? 0;\n\t}\n\n\tqueueFor(resource: URI, factory: ITask<Promise<void>>, extUri: IExtUri = defaultExtUri): Promise<void> {\n\t\tconst key = extUri.getComparisonKey(resource);\n\n\t\tlet queue = this.queues.get(key);\n\t\tif (!queue) {\n\t\t\tqueue = new Queue<void>();\n\t\t\tconst drainListenerId = this.drainListenerCount++;\n\t\t\tconst drainListener = Event.once(queue.onDrained)(() => {\n\t\t\t\tqueue?.dispose();\n\t\t\t\tthis.queues.delete(key);\n\t\t\t\tthis.onDidQueueDrain();\n\n\t\t\t\tthis.drainListeners?.deleteAndDispose(drainListenerId);\n\n\t\t\t\tif (this.drainListeners?.size === 0) {\n\t\t\t\t\tthis.drainListeners.dispose();\n\t\t\t\t\tthis.drainListeners = undefined;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (!this.drainListeners) {\n\t\t\t\tthis.drainListeners = new DisposableMap();\n\t\t\t}\n\t\t\tthis.drainListeners.set(drainListenerId, drainListener);\n\n\t\t\tthis.queues.set(key, queue);\n\t\t}\n\n\t\treturn queue.queue(factory);\n\t}\n\n\tprivate onDidQueueDrain(): void {\n\t\tif (!this.isDrained()) {\n\t\t\treturn; // not done yet\n\t\t}\n\n\t\tthis.releaseDrainers();\n\t}\n\n\tprivate releaseDrainers(): void {\n\t\tfor (const drainer of this.drainers) {\n\t\t\tdrainer.complete();\n\t\t}\n\n\t\tthis.drainers.clear();\n\t}\n\n\tdispose(): void {\n\t\tfor (const [, queue] of this.queues) {\n\t\t\tqueue.dispose();\n\t\t}\n\n\t\tthis.queues.clear();\n\n\t\t// Even though we might still have pending\n\t\t// tasks queued, after the queues have been\n\t\t// disposed, we can no longer track them, so\n\t\t// we release drainers to prevent hanging\n\t\t// promises when the resource queue is being\n\t\t// disposed.\n\t\tthis.releaseDrainers();\n\n\t\tthis.drainListeners?.dispose();\n\t}\n}\n\nexport class TimeoutTimer implements IDisposable {\n\tprivate _token: any;\n\n\tconstructor();\n\tconstructor(runner: () => void, timeout: number);\n\tconstructor(runner?: () => void, timeout?: number) {\n\t\tthis._token = -1;\n\n\t\tif (typeof runner === 'function' && typeof timeout === 'number') {\n\t\t\tthis.setIfNotSet(runner, timeout);\n\t\t}\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n\n\tcancel(): void {\n\t\tif (this._token !== -1) {\n\t\t\tclearTimeout(this._token);\n\t\t\tthis._token = -1;\n\t\t}\n\t}\n\n\tcancelAndSet(runner: () => void, timeout: number): void {\n\t\tthis.cancel();\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n\n\tsetIfNotSet(runner: () => void, timeout: number): void {\n\t\tif (this._token !== -1) {\n\t\t\t// timer is already set\n\t\t\treturn;\n\t\t}\n\t\tthis._token = setTimeout(() => {\n\t\t\tthis._token = -1;\n\t\t\trunner();\n\t\t}, timeout);\n\t}\n}\n\nexport class IntervalTimer implements IDisposable {\n\n\tprivate disposable: IDisposable | undefined = undefined;\n\n\tcancel(): void {\n\t\tthis.disposable?.dispose();\n\t\tthis.disposable = undefined;\n\t}\n\n\tcancelAndSet(runner: () => void, interval: number, context = globalThis): void {\n\t\tthis.cancel();\n\t\tconst handle = context.setInterval(() => {\n\t\t\trunner();\n\t\t}, interval);\n\n\t\tthis.disposable = toDisposable(() => {\n\t\t\tcontext.clearInterval(handle);\n\t\t\tthis.disposable = undefined;\n\t\t});\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t}\n}\n\nexport class RunOnceScheduler implements IDisposable {\n\n\tprotected runner: ((...args: unknown[]) => void) | null;\n\n\tprivate timeoutToken: any;\n\tprivate timeout: number;\n\tprivate timeoutHandler: () => void;\n\n\tconstructor(runner: (...args: any[]) => void, delay: number) {\n\t\tthis.timeoutToken = -1;\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.timeoutHandler = this.onTimeout.bind(this);\n\t}\n\n\t/**\n\t * Dispose RunOnceScheduler\n\t */\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\t/**\n\t * Cancel current scheduled runner (if any).\n\t */\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearTimeout(this.timeoutToken);\n\t\t\tthis.timeoutToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tthis.cancel();\n\t\tthis.timeoutToken = setTimeout(this.timeoutHandler, delay);\n\t}\n\n\tget delay(): number {\n\t\treturn this.timeout;\n\t}\n\n\tset delay(value: number) {\n\t\tthis.timeout = value;\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.timeoutToken !== -1;\n\t}\n\n\tflush(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tthis.cancel();\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprivate onTimeout() {\n\t\tthis.timeoutToken = -1;\n\t\tif (this.runner) {\n\t\t\tthis.doRun();\n\t\t}\n\t}\n\n\tprotected doRun(): void {\n\t\tthis.runner?.();\n\t}\n}\n\n/**\n * Same as `RunOnceScheduler`, but doesn't count the time spent in sleep mode.\n * > **NOTE**: Only offers 1s resolution.\n *\n * When calling `setTimeout` with 3hrs, and putting the computer immediately to sleep\n * for 8hrs, `setTimeout` will fire **as soon as the computer wakes from sleep**. But\n * this scheduler will execute 3hrs **after waking the computer from sleep**.\n */\nexport class ProcessTimeRunOnceScheduler {\n\n\tprivate runner: (() => void) | null;\n\tprivate timeout: number;\n\n\tprivate counter: number;\n\tprivate intervalToken: any;\n\tprivate intervalHandler: () => void;\n\n\tconstructor(runner: () => void, delay: number) {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.runner = runner;\n\t\tthis.timeout = delay;\n\t\tthis.counter = 0;\n\t\tthis.intervalToken = -1;\n\t\tthis.intervalHandler = this.onInterval.bind(this);\n\t}\n\n\tdispose(): void {\n\t\tthis.cancel();\n\t\tthis.runner = null;\n\t}\n\n\tcancel(): void {\n\t\tif (this.isScheduled()) {\n\t\t\tclearInterval(this.intervalToken);\n\t\t\tthis.intervalToken = -1;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel previous runner (if any) & schedule a new runner.\n\t */\n\tschedule(delay = this.timeout): void {\n\t\tif (delay % 1000 !== 0) {\n\t\t\tconsole.warn(`ProcessTimeRunOnceScheduler resolution is 1s, ${delay}ms is not a multiple of 1000ms.`);\n\t\t}\n\t\tthis.cancel();\n\t\tthis.counter = Math.ceil(delay / 1000);\n\t\tthis.intervalToken = setInterval(this.intervalHandler, 1000);\n\t}\n\n\t/**\n\t * Returns true if scheduled.\n\t */\n\tisScheduled(): boolean {\n\t\treturn this.intervalToken !== -1;\n\t}\n\n\tprivate onInterval() {\n\t\tthis.counter--;\n\t\tif (this.counter > 0) {\n\t\t\t// still need to wait\n\t\t\treturn;\n\t\t}\n\n\t\t// time elapsed\n\t\tclearInterval(this.intervalToken);\n\t\tthis.intervalToken = -1;\n\t\tthis.runner?.();\n\t}\n}\n\nexport class RunOnceWorker<T> extends RunOnceScheduler {\n\n\tprivate units: T[] = [];\n\n\tconstructor(runner: (units: T[]) => void, timeout: number) {\n\t\tsuper(runner, timeout);\n\t}\n\n\twork(unit: T): void {\n\t\tthis.units.push(unit);\n\n\t\tif (!this.isScheduled()) {\n\t\t\tthis.schedule();\n\t\t}\n\t}\n\n\tprotected override doRun(): void {\n\t\tconst units = this.units;\n\t\tthis.units = [];\n\n\t\tthis.runner?.(units);\n\t}\n\n\toverride dispose(): void {\n\t\tthis.units = [];\n\n\t\tsuper.dispose();\n\t}\n}\n\nexport interface IThrottledWorkerOptions {\n\n\t/**\n\t * maximum of units the worker will pass onto handler at once\n\t */\n\tmaxWorkChunkSize: number;\n\n\t/**\n\t * maximum of units the worker will keep in memory for processing\n\t */\n\tmaxBufferedWork: number | undefined;\n\n\t/**\n\t * delay before processing the next round of chunks when chunk size exceeds limits\n\t */\n\tthrottleDelay: number;\n}\n\n/**\n * The `ThrottledWorker` will accept units of work `T`\n * to handle. The contract is:\n * * there is a maximum of units the worker can handle at once (via `maxWorkChunkSize`)\n * * there is a maximum of units the worker will keep in memory for processing (via `maxBufferedWork`)\n * * after having handled `maxWorkChunkSize` units, the worker needs to rest (via `throttleDelay`)\n */\nexport class ThrottledWorker<T> extends Disposable {\n\n\tprivate readonly pendingWork: T[] = [];\n\n\tprivate readonly throttler = this._register(new MutableDisposable<RunOnceScheduler>());\n\tprivate disposed = false;\n\n\tconstructor(\n\t\tprivate options: IThrottledWorkerOptions,\n\t\tprivate readonly handler: (units: T[]) => void\n\t) {\n\t\tsuper();\n\t}\n\n\t/**\n\t * The number of work units that are pending to be processed.\n\t */\n\tget pending(): number { return this.pendingWork.length; }\n\n\t/**\n\t * Add units to be worked on. Use `pending` to figure out\n\t * how many units are not yet processed after this method\n\t * was called.\n\t *\n\t * @returns whether the work was accepted or not. If the\n\t * worker is disposed, it will not accept any more work.\n\t * If the number of pending units would become larger\n\t * than `maxPendingWork`, more work will also not be accepted.\n\t */\n\twork(units: readonly T[]): boolean {\n\t\tif (this.disposed) {\n\t\t\treturn false; // work not accepted: disposed\n\t\t}\n\n\t\t// Check for reaching maximum of pending work\n\t\tif (typeof this.options.maxBufferedWork === 'number') {\n\n\t\t\t// Throttled: simple check if pending + units exceeds max pending\n\t\t\tif (this.throttler.value) {\n\t\t\t\tif (this.pending + units.length > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Unthrottled: same as throttled, but account for max chunk getting\n\t\t\t// worked on directly without being pending\n\t\t\telse {\n\t\t\t\tif (this.pending + units.length - this.options.maxWorkChunkSize > this.options.maxBufferedWork) {\n\t\t\t\t\treturn false; // work not accepted: too much pending work\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add to pending units first\n\t\tfor (const unit of units) {\n\t\t\tthis.pendingWork.push(unit);\n\t\t}\n\n\t\t// If not throttled, start working directly\n\t\t// Otherwise, when the throttle delay has\n\t\t// past, pending work will be worked again.\n\t\tif (!this.throttler.value) {\n\t\t\tthis.doWork();\n\t\t}\n\n\t\treturn true; // work accepted\n\t}\n\n\tprivate doWork(): void {\n\n\t\t// Extract chunk to handle and handle it\n\t\tthis.handler(this.pendingWork.splice(0, this.options.maxWorkChunkSize));\n\n\t\t// If we have remaining work, schedule it after a delay\n\t\tif (this.pendingWork.length > 0) {\n\t\t\tthis.throttler.value = new RunOnceScheduler(() => {\n\t\t\t\tthis.throttler.clear();\n\n\t\t\t\tthis.doWork();\n\t\t\t}, this.options.throttleDelay);\n\t\t\tthis.throttler.value.schedule();\n\t\t}\n\t}\n\n\toverride dispose(): void {\n\t\tsuper.dispose();\n\n\t\tthis.disposed = true;\n\t}\n}\n\n//#region -- run on idle tricks ------------\n\nexport interface IdleDeadline {\n\treadonly didTimeout: boolean;\n\ttimeRemaining(): number;\n}\n\ntype IdleApi = Pick<typeof globalThis, 'requestIdleCallback' | 'cancelIdleCallback'>;\n\n\n/**\n * Execute the callback the next time the browser is idle, returning an\n * {@link IDisposable} that will cancel the callback when disposed. This wraps\n * [requestIdleCallback] so it will fallback to [setTimeout] if the environment\n * doesn't support it.\n *\n * @param callback The callback to run when idle, this includes an\n * [IdleDeadline] that provides the time alloted for the idle callback by the\n * browser. Not respecting this deadline will result in a degraded user\n * experience.\n * @param timeout A timeout at which point to queue no longer wait for an idle\n * callback but queue it on the regular event loop (like setTimeout). Typically\n * this should not be used.\n *\n * [IdleDeadline]: https://developer.mozilla.org/en-US/docs/Web/API/IdleDeadline\n * [requestIdleCallback]: https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n * [setTimeout]: https://developer.mozilla.org/en-US/docs/Web/API/Window/setTimeout\n *\n * **Note** that there is `dom.ts#runWhenWindowIdle` which is better suited when running inside a browser\n * context\n */\nexport let runWhenGlobalIdle: (callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\nexport let _runWhenIdle: (targetWindow: IdleApi, callback: (idle: IdleDeadline) => void, timeout?: number) => IDisposable;\n\n(function () {\n\tif (typeof globalThis.requestIdleCallback !== 'function' || typeof globalThis.cancelIdleCallback !== 'function') {\n\t\t_runWhenIdle = (_targetWindow, runner) => {\n\t\t\tsetTimeout0(() => {\n\t\t\t\tif (disposed) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst end = Date.now() + 15; // one frame at 64fps\n\t\t\t\tconst deadline: IdleDeadline = {\n\t\t\t\t\tdidTimeout: true,\n\t\t\t\t\ttimeRemaining() {\n\t\t\t\t\t\treturn Math.max(0, end - Date.now());\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\trunner(Object.freeze(deadline));\n\t\t\t});\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t} else {\n\t\t_runWhenIdle = (targetWindow: IdleApi, runner, timeout?) => {\n\t\t\tconst handle: number = targetWindow.requestIdleCallback(runner, typeof timeout === 'number' ? { timeout } : undefined);\n\t\t\tlet disposed = false;\n\t\t\treturn {\n\t\t\t\tdispose() {\n\t\t\t\t\tif (disposed) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tdisposed = true;\n\t\t\t\t\ttargetWindow.cancelIdleCallback(handle);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\trunWhenGlobalIdle = (runner) => _runWhenIdle(globalThis, runner);\n})();\n\nexport abstract class AbstractIdleValue<T> {\n\n\tprivate readonly _executor: () => void;\n\tprivate readonly _handle: IDisposable;\n\n\tprivate _didRun: boolean = false;\n\tprivate _value?: T;\n\tprivate _error: unknown;\n\n\tconstructor(targetWindow: IdleApi, executor: () => T) {\n\t\tthis._executor = () => {\n\t\t\ttry {\n\t\t\t\tthis._value = executor();\n\t\t\t} catch (err) {\n\t\t\t\tthis._error = err;\n\t\t\t} finally {\n\t\t\t\tthis._didRun = true;\n\t\t\t}\n\t\t};\n\t\tthis._handle = _runWhenIdle(targetWindow, () => this._executor());\n\t}\n\n\tdispose(): void {\n\t\tthis._handle.dispose();\n\t}\n\n\tget value(): T {\n\t\tif (!this._didRun) {\n\t\t\tthis._handle.dispose();\n\t\t\tthis._executor();\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n\n\tget isInitialized(): boolean {\n\t\treturn this._didRun;\n\t}\n}\n\n/**\n * An `IdleValue` that always uses the current window (which might be throttled or inactive)\n *\n * **Note** that there is `dom.ts#WindowIdleValue` which is better suited when running inside a browser\n * context\n */\nexport class GlobalIdleValue<T> extends AbstractIdleValue<T> {\n\n\tconstructor(executor: () => T) {\n\t\tsuper(globalThis, executor);\n\t}\n}\n\n//#endregion\n\nexport async function retry<T>(task: ITask<Promise<T>>, delay: number, retries: number): Promise<T> {\n\tlet lastError: Error | undefined;\n\n\tfor (let i = 0; i < retries; i++) {\n\t\ttry {\n\t\t\treturn await task();\n\t\t} catch (error) {\n\t\t\tlastError = error;\n\n\t\t\tawait timeout(delay);\n\t\t}\n\t}\n\n\tthrow lastError;\n}\n\n//#region Task Sequentializer\n\ninterface IRunningTask {\n\treadonly taskId: number;\n\treadonly cancel: () => void;\n\treadonly promise: Promise<void>;\n}\n\ninterface IQueuedTask {\n\treadonly promise: Promise<void>;\n\treadonly promiseResolve: () => void;\n\treadonly promiseReject: (error: Error) => void;\n\trun: ITask<Promise<void>>;\n}\n\nexport interface ITaskSequentializerWithRunningTask {\n\treadonly running: Promise<void>;\n}\n\nexport interface ITaskSequentializerWithQueuedTask {\n\treadonly queued: IQueuedTask;\n}\n\n/**\n * @deprecated use `LimitedQueue` instead for an easier to use API\n */\nexport class TaskSequentializer {\n\n\tprivate _running?: IRunningTask;\n\tprivate _queued?: IQueuedTask;\n\n\tisRunning(taskId?: number): this is ITaskSequentializerWithRunningTask {\n\t\tif (typeof taskId === 'number') {\n\t\t\treturn this._running?.taskId === taskId;\n\t\t}\n\n\t\treturn !!this._running;\n\t}\n\n\tget running(): Promise<void> | undefined {\n\t\treturn this._running?.promise;\n\t}\n\n\tcancelRunning(): void {\n\t\tthis._running?.cancel();\n\t}\n\n\trun(taskId: number, promise: Promise<void>, onCancel?: () => void,): Promise<void> {\n\t\tthis._running = { taskId, cancel: () => onCancel?.(), promise };\n\n\t\tpromise.then(() => this.doneRunning(taskId), () => this.doneRunning(taskId));\n\n\t\treturn promise;\n\t}\n\n\tprivate doneRunning(taskId: number): void {\n\t\tif (this._running && taskId === this._running.taskId) {\n\n\t\t\t// only set running to done if the promise finished that is associated with that taskId\n\t\t\tthis._running = undefined;\n\n\t\t\t// schedule the queued task now that we are free if we have any\n\t\t\tthis.runQueued();\n\t\t}\n\t}\n\n\tprivate runQueued(): void {\n\t\tif (this._queued) {\n\t\t\tconst queued = this._queued;\n\t\t\tthis._queued = undefined;\n\n\t\t\t// Run queued task and complete on the associated promise\n\t\t\tqueued.run().then(queued.promiseResolve, queued.promiseReject);\n\t\t}\n\t}\n\n\t/**\n\t * Note: the promise to schedule as next run MUST itself call `run`.\n\t *       Otherwise, this sequentializer will report `false` for `isRunning`\n\t *       even when this task is running. Missing this detail means that\n\t *       suddenly multiple tasks will run in parallel.\n\t */\n\tqueue(run: ITask<Promise<void>>): Promise<void> {\n\n\t\t// this is our first queued task, so we create associated promise with it\n\t\t// so that we can return a promise that completes when the task has\n\t\t// completed.\n\t\tif (!this._queued) {\n\t\t\tconst { promise, resolve: promiseResolve, reject: promiseReject } = promiseWithResolvers<void>();\n\t\t\tthis._queued = {\n\t\t\t\trun,\n\t\t\t\tpromise,\n\t\t\t\tpromiseResolve: promiseResolve!,\n\t\t\t\tpromiseReject: promiseReject!\n\t\t\t};\n\t\t}\n\n\t\t// we have a previous queued task, just overwrite it\n\t\telse {\n\t\t\tthis._queued.run = run;\n\t\t}\n\n\t\treturn this._queued.promise;\n\t}\n\n\thasQueued(): this is ITaskSequentializerWithQueuedTask {\n\t\treturn !!this._queued;\n\t}\n\n\tasync join(): Promise<void> {\n\t\treturn this._queued?.promise ?? this._running?.promise;\n\t}\n}\n\n//#endregion\n\n//#region\n\n/**\n * The `IntervalCounter` allows to count the number\n * of calls to `increment()` over a duration of\n * `interval`. This utility can be used to conditionally\n * throttle a frequent task when a certain threshold\n * is reached.\n */\nexport class IntervalCounter {\n\n\tprivate lastIncrementTime = 0;\n\n\tprivate value = 0;\n\n\tconstructor(private readonly interval: number, private readonly nowFn = () => Date.now()) { }\n\n\tincrement(): number {\n\t\tconst now = this.nowFn();\n\n\t\t// We are outside of the range of `interval` and as such\n\t\t// start counting from 0 and remember the time\n\t\tif (now - this.lastIncrementTime > this.interval) {\n\t\t\tthis.lastIncrementTime = now;\n\t\t\tthis.value = 0;\n\t\t}\n\n\t\tthis.value++;\n\n\t\treturn this.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nexport type ValueCallback<T = unknown> = (value: T | Promise<T>) => void;\n\nconst enum DeferredOutcome {\n\tResolved,\n\tRejected\n}\n\n/**\n * Creates a promise whose resolution or rejection can be controlled imperatively.\n */\nexport class DeferredPromise<T> {\n\n\tprivate completeCallback!: ValueCallback<T>;\n\tprivate errorCallback!: (err: unknown) => void;\n\tprivate outcome?: { outcome: DeferredOutcome.Rejected; value: any } | { outcome: DeferredOutcome.Resolved; value: T };\n\n\tpublic get isRejected() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Rejected;\n\t}\n\n\tpublic get isResolved() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved;\n\t}\n\n\tpublic get isSettled() {\n\t\treturn !!this.outcome;\n\t}\n\n\tpublic get value() {\n\t\treturn this.outcome?.outcome === DeferredOutcome.Resolved ? this.outcome?.value : undefined;\n\t}\n\n\tpublic readonly p: Promise<T>;\n\n\tconstructor() {\n\t\tthis.p = new Promise<T>((c, e) => {\n\t\t\tthis.completeCallback = c;\n\t\t\tthis.errorCallback = e;\n\t\t});\n\t}\n\n\tpublic complete(value: T) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.completeCallback(value);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Resolved, value };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic error(err: unknown) {\n\t\treturn new Promise<void>(resolve => {\n\t\t\tthis.errorCallback(err);\n\t\t\tthis.outcome = { outcome: DeferredOutcome.Rejected, value: err };\n\t\t\tresolve();\n\t\t});\n\t}\n\n\tpublic cancel() {\n\t\treturn this.error(new CancellationError());\n\t}\n}\n\n//#endregion\n\n//#region Promises\n\nexport namespace Promises {\n\n\t/**\n\t * A drop-in replacement for `Promise.all` with the only difference\n\t * that the method awaits every promise to either fulfill or reject.\n\t *\n\t * Similar to `Promise.all`, only the first error will be returned\n\t * if any.\n\t */\n\texport async function settled<T>(promises: Promise<T>[]): Promise<T[]> {\n\t\tlet firstError: Error | undefined = undefined;\n\n\t\tconst result = await Promise.all(promises.map(promise => promise.then(value => value, error => {\n\t\t\tif (!firstError) {\n\t\t\t\tfirstError = error;\n\t\t\t}\n\n\t\t\treturn undefined; // do not rethrow so that other promises can settle\n\t\t})));\n\n\t\tif (typeof firstError !== 'undefined') {\n\t\t\tthrow firstError;\n\t\t}\n\n\t\treturn result as unknown as T[]; // cast is needed and protected by the `throw` above\n\t}\n\n\t/**\n\t * A helper to create a new `Promise<T>` with a body that is a promise\n\t * itself. By default, an error that raises from the async body will\n\t * end up as a unhandled rejection, so this utility properly awaits the\n\t * body and rejects the promise as a normal promise does without async\n\t * body.\n\t *\n\t * This method should only be used in rare cases where otherwise `async`\n\t * cannot be used (e.g. when callbacks are involved that require this).\n\t */\n\texport function withAsyncBody<T, E = Error>(bodyFn: (resolve: (value: T) => unknown, reject: (error: E) => unknown) => Promise<unknown>): Promise<T> {\n\t\t// eslint-disable-next-line no-async-promise-executor\n\t\treturn new Promise<T>(async (resolve, reject) => {\n\t\t\ttry {\n\t\t\t\tawait bodyFn(resolve, reject);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport class StatefulPromise<T> {\n\tprivate _value: T | undefined = undefined;\n\tget value(): T | undefined { return this._value; }\n\n\tprivate _error: unknown = undefined;\n\tget error(): unknown { return this._error; }\n\n\tprivate _isResolved = false;\n\tget isResolved() { return this._isResolved; }\n\n\tpublic readonly promise: Promise<T>;\n\n\tconstructor(promise: Promise<T>) {\n\t\tthis.promise = promise.then(\n\t\t\tvalue => {\n\t\t\t\tthis._value = value;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\treturn value;\n\t\t\t},\n\t\t\terror => {\n\t\t\t\tthis._error = error;\n\t\t\t\tthis._isResolved = true;\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t);\n\t}\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\tif (!this._isResolved) {\n\t\t\tthrow new BugIndicatingError('Promise is not resolved yet');\n\t\t}\n\t\tif (this._error) {\n\t\t\tthrow this._error;\n\t\t}\n\t\treturn this._value!;\n\t}\n}\n\nexport class LazyStatefulPromise<T> {\n\tprivate readonly _promise = new Lazy(() => new StatefulPromise(this._compute()));\n\n\tconstructor(\n\t\tprivate readonly _compute: () => Promise<T>,\n\t) { }\n\n\t/**\n\t * Returns the resolved value.\n\t * Throws if the promise is not resolved yet.\n\t */\n\tpublic requireValue(): T {\n\t\treturn this._promise.value.requireValue();\n\t}\n\n\t/**\n\t * Returns the promise (and triggers a computation of the promise if not yet done so).\n\t */\n\tpublic getPromise(): Promise<T> {\n\t\treturn this._promise.value.promise;\n\t}\n\n\t/**\n\t * Reads the current value without triggering a computation of the promise.\n\t */\n\tpublic get currentValue(): T | undefined {\n\t\treturn this._promise.rawValue?.value;\n\t}\n}\n\n//#endregion\n\n//#region\n\nconst enum AsyncIterableSourceState {\n\tInitial,\n\tDoneOK,\n\tDoneError,\n}\n\n/**\n * An object that allows to emit async values asynchronously or bring the iterable to an error state using `reject()`.\n * This emitter is valid only for the duration of the executor (until the promise returned by the executor settles).\n */\nexport interface AsyncIterableEmitter<T> {\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitOne(value: T): void;\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `reject()` has already been called, this method has no effect.\n\t */\n\temitMany(values: T[]): void;\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `reject()` have already been called, this method has no effect.\n\t */\n\treject(error: Error): void;\n}\n\n/**\n * An executor for the `AsyncIterableObject` that has access to an emitter.\n */\nexport interface AsyncIterableExecutor<T> {\n\t/**\n\t * @param emitter An object that allows to emit async values valid only for the duration of the executor.\n\t */\n\t(emitter: AsyncIterableEmitter<T>): void | Promise<void>;\n}\n\n/**\n * A rich implementation for an `AsyncIterable<T>`.\n */\nexport class AsyncIterableObject<T> implements AsyncIterable<T> {\n\n\tpublic static fromArray<T>(items: T[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>((writer) => {\n\t\t\twriter.emitMany(items);\n\t\t});\n\t}\n\n\tpublic static fromPromise<T>(promise: Promise<T[]>): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\temitter.emitMany(await promise);\n\t\t});\n\t}\n\n\tpublic static fromPromises<T>(promises: Promise<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tawait Promise.all(promises.map(async (p) => emitter.emitOne(await p)));\n\t\t});\n\t}\n\n\tpublic static merge<T>(iterables: AsyncIterable<T>[]): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject(async (emitter) => {\n\t\t\tawait Promise.all(iterables.map(async (iterable) => {\n\t\t\t\tfor await (const item of iterable) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}));\n\t\t});\n\t}\n\n\tpublic static EMPTY = AsyncIterableObject.fromArray<any>([]);\n\n\tprivate _state: AsyncIterableSourceState;\n\tprivate _results: T[];\n\tprivate _error: Error | null;\n\tprivate readonly _onReturn?: () => void | Promise<void>;\n\tprivate readonly _onStateChanged: Emitter<void>;\n\n\tconstructor(executor: AsyncIterableExecutor<T>, onReturn?: () => void | Promise<void>) {\n\t\tthis._state = AsyncIterableSourceState.Initial;\n\t\tthis._results = [];\n\t\tthis._error = null;\n\t\tthis._onReturn = onReturn;\n\t\tthis._onStateChanged = new Emitter<void>();\n\n\t\tqueueMicrotask(async () => {\n\t\t\tconst writer: AsyncIterableEmitter<T> = {\n\t\t\t\temitOne: (item) => this.emitOne(item),\n\t\t\t\temitMany: (items) => this.emitMany(items),\n\t\t\t\treject: (error) => this.reject(error)\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait Promise.resolve(executor(writer));\n\t\t\t\tthis.resolve();\n\t\t\t} catch (err) {\n\t\t\t\tthis.reject(err);\n\t\t\t} finally {\n\t\t\t\twriter.emitOne = undefined!;\n\t\t\t\twriter.emitMany = undefined!;\n\t\t\t\twriter.reject = undefined!;\n\t\t\t}\n\t\t});\n\t}\n\n\t[Symbol.asyncIterator](): AsyncIterator<T, undefined, undefined> {\n\t\tlet i = 0;\n\t\treturn {\n\t\t\tnext: async () => {\n\t\t\t\tdo {\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneError) {\n\t\t\t\t\t\tthrow this._error;\n\t\t\t\t\t}\n\t\t\t\t\tif (i < this._results.length) {\n\t\t\t\t\t\treturn { done: false, value: this._results[i++] };\n\t\t\t\t\t}\n\t\t\t\t\tif (this._state === AsyncIterableSourceState.DoneOK) {\n\t\t\t\t\t\treturn { done: true, value: undefined };\n\t\t\t\t\t}\n\t\t\t\t\tawait Event.toPromise(this._onStateChanged.event);\n\t\t\t\t} while (true);\n\t\t\t},\n\t\t\treturn: async () => {\n\t\t\t\tthis._onReturn?.();\n\t\t\t\treturn { done: true, value: undefined };\n\t\t\t}\n\t\t};\n\t}\n\n\tpublic static map<T, R>(iterable: AsyncIterable<T>, mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn new AsyncIterableObject<R>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\temitter.emitOne(mapFn(item));\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic map<R>(mapFn: (item: T) => R): AsyncIterableObject<R> {\n\t\treturn AsyncIterableObject.map(this, mapFn);\n\t}\n\n\tpublic static filter<T>(iterable: AsyncIterable<T>, filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn new AsyncIterableObject<T>(async (emitter) => {\n\t\t\tfor await (const item of iterable) {\n\t\t\t\tif (filterFn(item)) {\n\t\t\t\t\temitter.emitOne(item);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic filter(filterFn: (item: T) => boolean): AsyncIterableObject<T> {\n\t\treturn AsyncIterableObject.filter(this, filterFn);\n\t}\n\n\tpublic static coalesce<T>(iterable: AsyncIterable<T | undefined | null>): AsyncIterableObject<T> {\n\t\treturn <AsyncIterableObject<T>>AsyncIterableObject.filter(iterable, item => !!item);\n\t}\n\n\tpublic coalesce(): AsyncIterableObject<NonNullable<T>> {\n\t\treturn AsyncIterableObject.coalesce(this) as AsyncIterableObject<NonNullable<T>>;\n\t}\n\n\tpublic static async toPromise<T>(iterable: AsyncIterable<T>): Promise<T[]> {\n\t\tconst result: T[] = [];\n\t\tfor await (const item of iterable) {\n\t\t\tresult.push(item);\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic toPromise(): Promise<T[]> {\n\t\treturn AsyncIterableObject.toPromise(this);\n\t}\n\n\t/**\n\t * The value will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitOne(value: T): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results.push(value);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * The values will be appended at the end.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate emitMany(values: T[]): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\t// it is important to add new values at the end,\n\t\t// as we may have iterators already running on the array\n\t\tthis._results = this._results.concat(values);\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Calling `resolve()` will mark the result array as complete.\n\t *\n\t * **NOTE** `resolve()` must be called, otherwise all consumers of this iterable will hang indefinitely, similar to a non-resolved promise.\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate resolve(): void {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneOK;\n\t\tthis._onStateChanged.fire();\n\t}\n\n\t/**\n\t * Writing an error will permanently invalidate this iterable.\n\t * The current users will receive an error thrown, as will all future users.\n\t *\n\t * **NOTE** If `resolve()` or `reject()` have already been called, this method has no effect.\n\t */\n\tprivate reject(error: Error) {\n\t\tif (this._state !== AsyncIterableSourceState.Initial) {\n\t\t\treturn;\n\t\t}\n\t\tthis._state = AsyncIterableSourceState.DoneError;\n\t\tthis._error = error;\n\t\tthis._onStateChanged.fire();\n\t}\n}\n\nexport class CancelableAsyncIterableObject<T> extends AsyncIterableObject<T> {\n\tconstructor(\n\t\tprivate readonly _source: CancellationTokenSource,\n\t\texecutor: AsyncIterableExecutor<T>\n\t) {\n\t\tsuper(executor);\n\t}\n\n\tcancel(): void {\n\t\tthis._source.cancel();\n\t}\n}\n\nexport function createCancelableAsyncIterable<T>(callback: (token: CancellationToken) => AsyncIterable<T>): CancelableAsyncIterableObject<T> {\n\tconst source = new CancellationTokenSource();\n\tconst innerIterable = callback(source.token);\n\n\treturn new CancelableAsyncIterableObject<T>(source, async (emitter) => {\n\t\tconst subscription = source.token.onCancellationRequested(() => {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(new CancellationError());\n\t\t});\n\t\ttry {\n\t\t\tfor await (const item of innerIterable) {\n\t\t\t\tif (source.token.isCancellationRequested) {\n\t\t\t\t\t// canceled in the meantime\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\temitter.emitOne(item);\n\t\t\t}\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t} catch (err) {\n\t\t\tsubscription.dispose();\n\t\t\tsource.dispose();\n\t\t\temitter.reject(err);\n\t\t}\n\t});\n}\n\nexport class AsyncIterableSource<T> {\n\n\tprivate readonly _deferred = new DeferredPromise<void>();\n\tprivate readonly _asyncIterable: AsyncIterableObject<T>;\n\n\tprivate _errorFn: (error: Error) => void;\n\tprivate _emitFn: (item: T) => void;\n\n\t/**\n\t *\n\t * @param onReturn A function that will be called when consuming the async iterable\n\t * has finished by the consumer, e.g the for-await-loop has be existed (break, return) early.\n\t * This is NOT called when resolving this source by its owner.\n\t */\n\tconstructor(onReturn?: () => Promise<void> | void) {\n\t\tthis._asyncIterable = new AsyncIterableObject(emitter => {\n\n\t\t\tif (earlyError) {\n\t\t\t\temitter.reject(earlyError);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (earlyItems) {\n\t\t\t\temitter.emitMany(earlyItems);\n\t\t\t}\n\t\t\tthis._errorFn = (error: Error) => emitter.reject(error);\n\t\t\tthis._emitFn = (item: T) => emitter.emitOne(item);\n\t\t\treturn this._deferred.p;\n\t\t}, onReturn);\n\n\t\tlet earlyError: Error | undefined;\n\t\tlet earlyItems: T[] | undefined;\n\n\t\tthis._emitFn = (item: T) => {\n\t\t\tif (!earlyItems) {\n\t\t\t\tearlyItems = [];\n\t\t\t}\n\t\t\tearlyItems.push(item);\n\t\t};\n\t\tthis._errorFn = (error: Error) => {\n\t\t\tif (!earlyError) {\n\t\t\t\tearlyError = error;\n\t\t\t}\n\t\t};\n\t}\n\n\tget asyncIterable(): AsyncIterableObject<T> {\n\t\treturn this._asyncIterable;\n\t}\n\n\tresolve(): void {\n\t\tthis._deferred.complete();\n\t}\n\n\treject(error: Error): void {\n\t\tthis._errorFn(error);\n\t\tthis._deferred.complete();\n\t}\n\n\temitOne(item: T): void {\n\t\tthis._emitFn(item);\n\t}\n}\n\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { equals } from 'vs/base/common/arrays';\nimport { isThenable } from 'vs/base/common/async';\nimport { CharCode } from 'vs/base/common/charCode';\nimport { isEqualOrParent } from 'vs/base/common/extpath';\nimport { LRUCache } from 'vs/base/common/map';\nimport { basename, extname, posix, sep } from 'vs/base/common/path';\nimport { isLinux } from 'vs/base/common/platform';\nimport { escapeRegExpCharacters, ltrim } from 'vs/base/common/strings';\n\nexport interface IRelativePattern {\n\n\t/**\n\t * A base file path to which this pattern will be matched against relatively.\n\t */\n\treadonly base: string;\n\n\t/**\n\t * A file glob pattern like `*.{ts,js}` that will be matched on file paths\n\t * relative to the base path.\n\t *\n\t * Example: Given a base of `/home/work/folder` and a file path of `/home/work/folder/index.js`,\n\t * the file glob pattern will match on `index.js`.\n\t */\n\treadonly pattern: string;\n}\n\nexport interface IExpression {\n\t[pattern: string]: boolean | SiblingClause;\n}\n\nexport function getEmptyExpression(): IExpression {\n\treturn Object.create(null);\n}\n\ninterface SiblingClause {\n\twhen: string;\n}\n\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\n\nconst PATH_REGEX = '[/\\\\\\\\]';\t\t// any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]';\t// any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\n\nfunction starsToRegExp(starCount: number, isLastPattern?: boolean): string {\n\tswitch (starCount) {\n\t\tcase 0:\n\t\t\treturn '';\n\t\tcase 1:\n\t\t\treturn `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n\t\tdefault:\n\t\t\t// Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n\t\t\t//           in which case also matches (Path Sep followed by Path Val)\n\t\t\t// Group is non capturing because we don't need to capture at all (?:...)\n\t\t\t// Overall we use non-greedy matching because it could be that we match too much\n\t\t\treturn `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n\t}\n}\n\nexport function splitGlobAware(pattern: string, splitChar: string): string[] {\n\tif (!pattern) {\n\t\treturn [];\n\t}\n\n\tconst segments: string[] = [];\n\n\tlet inBraces = false;\n\tlet inBrackets = false;\n\n\tlet curVal = '';\n\tfor (const char of pattern) {\n\t\tswitch (char) {\n\t\t\tcase splitChar:\n\t\t\t\tif (!inBraces && !inBrackets) {\n\t\t\t\t\tsegments.push(curVal);\n\t\t\t\t\tcurVal = '';\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '{':\n\t\t\t\tinBraces = true;\n\t\t\t\tbreak;\n\t\t\tcase '}':\n\t\t\t\tinBraces = false;\n\t\t\t\tbreak;\n\t\t\tcase '[':\n\t\t\t\tinBrackets = true;\n\t\t\t\tbreak;\n\t\t\tcase ']':\n\t\t\t\tinBrackets = false;\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcurVal += char;\n\t}\n\n\t// Tail\n\tif (curVal) {\n\t\tsegments.push(curVal);\n\t}\n\n\treturn segments;\n}\n\nfunction parseRegExp(pattern: string): string {\n\tif (!pattern) {\n\t\treturn '';\n\t}\n\n\tlet regEx = '';\n\n\t// Split up into segments for each slash found\n\tconst segments = splitGlobAware(pattern, GLOB_SPLIT);\n\n\t// Special case where we only have globstars\n\tif (segments.every(segment => segment === GLOBSTAR)) {\n\t\tregEx = '.*';\n\t}\n\n\t// Build regex over segments\n\telse {\n\t\tlet previousSegmentWasGlobStar = false;\n\t\tsegments.forEach((segment, index) => {\n\n\t\t\t// Treat globstar specially\n\t\t\tif (segment === GLOBSTAR) {\n\n\t\t\t\t// if we have more than one globstar after another, just ignore it\n\t\t\t\tif (previousSegmentWasGlobStar) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tregEx += starsToRegExp(2, index === segments.length - 1);\n\t\t\t}\n\n\t\t\t// Anything else, not globstar\n\t\t\telse {\n\n\t\t\t\t// States\n\t\t\t\tlet inBraces = false;\n\t\t\t\tlet braceVal = '';\n\n\t\t\t\tlet inBrackets = false;\n\t\t\t\tlet bracketVal = '';\n\n\t\t\t\tfor (const char of segment) {\n\n\t\t\t\t\t// Support brace expansion\n\t\t\t\t\tif (char !== '}' && inBraces) {\n\t\t\t\t\t\tbraceVal += char;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Support brackets\n\t\t\t\t\tif (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n\t\t\t\t\t\tlet res: string;\n\n\t\t\t\t\t\t// range operator\n\t\t\t\t\t\tif (char === '-') {\n\t\t\t\t\t\t\tres = char;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// negation operator (only valid on first index in bracket)\n\t\t\t\t\t\telse if ((char === '^' || char === '!') && !bracketVal) {\n\t\t\t\t\t\t\tres = '^';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// glob split matching is not allowed within character ranges\n\t\t\t\t\t\t// see http://man7.org/linux/man-pages/man7/glob.7.html\n\t\t\t\t\t\telse if (char === GLOB_SPLIT) {\n\t\t\t\t\t\t\tres = '';\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// anything else gets escaped\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tres = escapeRegExpCharacters(char);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbracketVal += res;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch (char) {\n\t\t\t\t\t\tcase '{':\n\t\t\t\t\t\t\tinBraces = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tinBrackets = true;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '}': {\n\t\t\t\t\t\t\tconst choices = splitGlobAware(braceVal, ',');\n\n\t\t\t\t\t\t\t// Converts {foo,bar} => [foo|bar]\n\t\t\t\t\t\t\tconst braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n\n\t\t\t\t\t\t\tregEx += braceRegExp;\n\n\t\t\t\t\t\t\tinBraces = false;\n\t\t\t\t\t\t\tbraceVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase ']': {\n\t\t\t\t\t\t\tregEx += ('[' + bracketVal + ']');\n\n\t\t\t\t\t\t\tinBrackets = false;\n\t\t\t\t\t\t\tbracketVal = '';\n\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcase '?':\n\t\t\t\t\t\t\tregEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tcase '*':\n\t\t\t\t\t\t\tregEx += starsToRegExp(1);\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tregEx += escapeRegExpCharacters(char);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Tail: Add the slash we had split on if there is more to\n\t\t\t\t// come and the remaining pattern is not a globstar\n\t\t\t\t// For example if pattern: some/**/*.js we want the \"/\" after\n\t\t\t\t// some to be included in the RegEx to prevent a folder called\n\t\t\t\t// \"something\" to match as well.\n\t\t\t\tif (\n\t\t\t\t\tindex < segments.length - 1 &&\t\t\t// more segments to come after this\n\t\t\t\t\t(\n\t\t\t\t\t\tsegments[index + 1] !== GLOBSTAR ||\t// next segment is not **, or...\n\t\t\t\t\t\tindex + 2 < segments.length\t\t\t// ...next segment is ** but there is more segments after that\n\t\t\t\t\t)\n\t\t\t\t) {\n\t\t\t\t\tregEx += PATH_REGEX;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// update globstar state\n\t\t\tpreviousSegmentWasGlobStar = (segment === GLOBSTAR);\n\t\t});\n\t}\n\n\treturn regEx;\n}\n\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; \t\t\t\t\t\t\t\t\t\t\t\t\t// **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; \t\t\t\t\t\t// {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; \t// Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t\t// **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; \t\t\t\t\t\t\t\t\t\t\t// something/else\n\nexport type ParsedPattern = (path: string, basename?: string) => boolean;\n\n// The `ParsedExpression` returns a `Promise`\n// iff `hasSibling` returns a `Promise`.\nexport type ParsedExpression = (path: string, basename?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => string | null | Promise<string | null> /* the matching pattern */;\n\ninterface IGlobOptions {\n\n\t/**\n\t * Simplify patterns for use as exclusion filters during\n\t * tree traversal to skip entire subtrees. Cannot be used\n\t * outside of a tree traversal.\n\t */\n\ttrimForExclusions?: boolean;\n}\n\ninterface ParsedStringPattern {\n\t(path: string, basename?: string): string | null | Promise<string | null> /* the matching pattern */;\n\tbasenames?: string[];\n\tpatterns?: string[];\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\ninterface ParsedExpressionPattern {\n\t(path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>): string | null | Promise<string | null> /* the matching pattern */;\n\trequiresSiblings?: boolean;\n\tallBasenames?: string[];\n\tallPaths?: string[];\n}\n\nconst CACHE = new LRUCache<string, ParsedStringPattern>(10000); // bounded to 10000 elements\n\nconst FALSE = function () {\n\treturn false;\n};\n\nconst NULL = function (): string | null {\n\treturn null;\n};\n\nfunction parsePattern(arg1: string | IRelativePattern, options: IGlobOptions): ParsedStringPattern {\n\tif (!arg1) {\n\t\treturn NULL;\n\t}\n\n\t// Handle relative patterns\n\tlet pattern: string;\n\tif (typeof arg1 !== 'string') {\n\t\tpattern = arg1.pattern;\n\t} else {\n\t\tpattern = arg1;\n\t}\n\n\t// Whitespace trimming\n\tpattern = pattern.trim();\n\n\t// Check cache\n\tconst patternKey = `${pattern}_${!!options.trimForExclusions}`;\n\tlet parsedPattern = CACHE.get(patternKey);\n\tif (parsedPattern) {\n\t\treturn wrapRelativePattern(parsedPattern, arg1);\n\t}\n\n\t// Check for Trivials\n\tlet match: RegExpExecArray | null;\n\tif (T1.test(pattern)) {\n\t\tparsedPattern = trivia1(pattern.substr(4), pattern); \t\t\t// common pattern: **/*.txt just need endsWith check\n\t} else if (match = T2.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/some.txt just need basename check\n\t\tparsedPattern = trivia2(match[1], pattern);\n\t} else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n\t\tparsedPattern = trivia3(pattern, options);\n\t} else if (match = T4.exec(trimForExclusions(pattern, options))) { \t// common pattern: **/something/else just need endsWith check\n\t\tparsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n\t} else if (match = T5.exec(trimForExclusions(pattern, options))) { \t// common pattern: something/else just need equals check\n\t\tparsedPattern = trivia4and5(match[1], pattern, false);\n\t}\n\n\t// Otherwise convert to pattern\n\telse {\n\t\tparsedPattern = toRegExp(pattern);\n\t}\n\n\t// Cache\n\tCACHE.set(patternKey, parsedPattern);\n\n\treturn wrapRelativePattern(parsedPattern, arg1);\n}\n\nfunction wrapRelativePattern(parsedPattern: ParsedStringPattern, arg2: string | IRelativePattern): ParsedStringPattern {\n\tif (typeof arg2 === 'string') {\n\t\treturn parsedPattern;\n\t}\n\n\tconst wrappedPattern: ParsedStringPattern = function (path, basename) {\n\t\tif (!isEqualOrParent(path, arg2.base, !isLinux)) {\n\t\t\t// skip glob matching if `base` is not a parent of `path`\n\t\t\treturn null;\n\t\t}\n\n\t\t// Given we have checked `base` being a parent of `path`,\n\t\t// we can now remove the `base` portion of the `path`\n\t\t// and only match on the remaining path components\n\t\t// For that we try to extract the portion of the `path`\n\t\t// that comes after the `base` portion. We have to account\n\t\t// for the fact that `base` might end in a path separator\n\t\t// (https://github.com/microsoft/vscode/issues/162498)\n\n\t\treturn parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n\t};\n\n\t// Make sure to preserve associated metadata\n\twrappedPattern.allBasenames = parsedPattern.allBasenames;\n\twrappedPattern.allPaths = parsedPattern.allPaths;\n\twrappedPattern.basenames = parsedPattern.basenames;\n\twrappedPattern.patterns = parsedPattern.patterns;\n\n\treturn wrappedPattern;\n}\n\nfunction trimForExclusions(pattern: string, options: IGlobOptions): string {\n\treturn options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base: string, pattern: string): ParsedStringPattern {\n\treturn function (path: string, basename?: string) {\n\t\treturn typeof path === 'string' && path.endsWith(base) ? pattern : null;\n\t};\n}\n\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base: string, pattern: string): ParsedStringPattern {\n\tconst slashBase = `/${base}`;\n\tconst backslashBase = `\\\\${base}`;\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (basename) {\n\t\t\treturn basename === base ? pattern : null;\n\t\t}\n\n\t\treturn path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n\t};\n\n\tconst basenames = [base];\n\tparsedPattern.basenames = basenames;\n\tparsedPattern.patterns = [pattern];\n\tparsedPattern.allBasenames = basenames;\n\n\treturn parsedPattern;\n}\n\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern: string, options: IGlobOptions): ParsedStringPattern {\n\tconst parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n\t\t.split(',')\n\t\t.map(pattern => parsePattern(pattern, options))\n\t\t.filter(pattern => pattern !== NULL), pattern);\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (patternsLength === 1) {\n\t\treturn parsedPatterns[0];\n\t}\n\n\tconst parsedPattern: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\tif (parsedPatterns[i](path, basename)) {\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tparsedPattern.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tparsedPattern.allPaths = allPaths;\n\t}\n\n\treturn parsedPattern;\n}\n\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath: string, pattern: string, matchPathEnds: boolean): ParsedStringPattern {\n\tconst usingPosixSep = sep === posix.sep;\n\tconst nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n\tconst nativePathEnd = sep + nativePath;\n\tconst targetPathEnd = posix.sep + targetPath;\n\n\tlet parsedPattern: ParsedStringPattern;\n\tif (matchPathEnds) {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n\t\t};\n\t} else {\n\t\tparsedPattern = function (path: string, basename?: string) {\n\t\t\treturn typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n\t\t};\n\t}\n\n\tparsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n\n\treturn parsedPattern;\n}\n\nfunction toRegExp(pattern: string): ParsedStringPattern {\n\ttry {\n\t\tconst regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n\t\treturn function (path: string) {\n\t\t\tregExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n\n\t\t\treturn typeof path === 'string' && regExp.test(path) ? pattern : null;\n\t\t};\n\t} catch (error) {\n\t\treturn NULL;\n\t}\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function match(pattern: string | IRelativePattern, path: string): boolean;\nexport function match(expression: IExpression, path: string, hasSibling?: (name: string) => boolean): string /* the matching pattern */;\nexport function match(arg1: string | IExpression | IRelativePattern, path: string, hasSibling?: (name: string) => boolean): boolean | string | null | Promise<string | null> {\n\tif (!arg1 || typeof path !== 'string') {\n\t\treturn false;\n\t}\n\n\treturn parse(arg1)(path, undefined, hasSibling);\n}\n\n/**\n * Simplified glob matching. Supports a subset of glob patterns:\n * * `*` to match zero or more characters in a path segment\n * * `?` to match on one character in a path segment\n * * `**` to match any number of path segments, including none\n * * `{}` to group conditions (e.g. *.{ts,js} matches all TypeScript and JavaScript files)\n * * `[]` to declare a range of characters to match in a path segment (e.g., `example.[0-9]` to match on `example.0`, `example.1`, )\n * * `[!...]` to negate a range of characters to match in a path segment (e.g., `example.[!0-9]` to match on `example.a`, `example.b`, but not `example.0`)\n */\nexport function parse(pattern: string | IRelativePattern, options?: IGlobOptions): ParsedPattern;\nexport function parse(expression: IExpression, options?: IGlobOptions): ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options?: IGlobOptions): ParsedPattern | ParsedExpression;\nexport function parse(arg1: string | IExpression | IRelativePattern, options: IGlobOptions = {}): ParsedPattern | ParsedExpression {\n\tif (!arg1) {\n\t\treturn FALSE;\n\t}\n\n\t// Glob with String\n\tif (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n\t\tconst parsedPattern = parsePattern(arg1, options);\n\t\tif (parsedPattern === NULL) {\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tconst resultPattern: ParsedPattern & { allBasenames?: string[]; allPaths?: string[] } = function (path: string, basename?: string) {\n\t\t\treturn !!parsedPattern(path, basename);\n\t\t};\n\n\t\tif (parsedPattern.allBasenames) {\n\t\t\tresultPattern.allBasenames = parsedPattern.allBasenames;\n\t\t}\n\n\t\tif (parsedPattern.allPaths) {\n\t\t\tresultPattern.allPaths = parsedPattern.allPaths;\n\t\t}\n\n\t\treturn resultPattern;\n\t}\n\n\t// Glob with Expression\n\treturn parsedExpression(<IExpression>arg1, options);\n}\n\nexport function isRelativePattern(obj: unknown): obj is IRelativePattern {\n\tconst rp = obj as IRelativePattern | undefined | null;\n\tif (!rp) {\n\t\treturn false;\n\t}\n\n\treturn typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\n\nexport function getBasenameTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allBasenames || [];\n}\n\nexport function getPathTerms(patternOrExpression: ParsedPattern | ParsedExpression): string[] {\n\treturn (<ParsedStringPattern>patternOrExpression).allPaths || [];\n}\n\nfunction parsedExpression(expression: IExpression, options: IGlobOptions): ParsedExpression {\n\tconst parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n\t\t.map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n\t\t.filter(pattern => pattern !== NULL));\n\n\tconst patternsLength = parsedPatterns.length;\n\tif (!patternsLength) {\n\t\treturn NULL;\n\t}\n\n\tif (!parsedPatterns.some(parsedPattern => !!(<ParsedExpressionPattern>parsedPattern).requiresSiblings)) {\n\t\tif (patternsLength === 1) {\n\t\t\treturn parsedPatterns[0] as ParsedStringPattern;\n\t\t}\n\n\t\tconst resultExpression: ParsedStringPattern = function (path: string, basename?: string) {\n\t\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\t\t\t\tconst result = parsedPatterns[i](path, basename);\n\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t\t}\n\n\t\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t\t// later processing and await the result properly.\n\t\t\t\tif (isThenable(result)) {\n\t\t\t\t\tif (!resultPromises) {\n\t\t\t\t\t\tresultPromises = [];\n\t\t\t\t\t}\n\n\t\t\t\t\tresultPromises.push(result);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// With result promises, we have to loop over each and\n\t\t\t// await the result before we can return any result.\n\t\t\tif (resultPromises) {\n\t\t\t\treturn (async () => {\n\t\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\treturn null;\n\t\t};\n\n\t\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\t\tif (withBasenames) {\n\t\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t\t}\n\n\t\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\t\tif (allPaths.length) {\n\t\t\tresultExpression.allPaths = allPaths;\n\t\t}\n\n\t\treturn resultExpression;\n\t}\n\n\tconst resultExpression: ParsedStringPattern = function (path: string, base?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) {\n\t\tlet name: string | undefined = undefined;\n\t\tlet resultPromises: Promise<string | null>[] | undefined = undefined;\n\n\t\tfor (let i = 0, n = parsedPatterns.length; i < n; i++) {\n\n\t\t\t// Pattern matches path\n\t\t\tconst parsedPattern = (<ParsedExpressionPattern>parsedPatterns[i]);\n\t\t\tif (parsedPattern.requiresSiblings && hasSibling) {\n\t\t\t\tif (!base) {\n\t\t\t\t\tbase = basename(path);\n\t\t\t\t}\n\n\t\t\t\tif (!name) {\n\t\t\t\t\tname = base.substr(0, base.length - extname(path).length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst result = parsedPattern(path, base, name, hasSibling);\n\t\t\tif (typeof result === 'string') {\n\t\t\t\treturn result; // immediately return as soon as the first expression matches\n\t\t\t}\n\n\t\t\t// If the result is a promise, we have to keep it for\n\t\t\t// later processing and await the result properly.\n\t\t\tif (isThenable(result)) {\n\t\t\t\tif (!resultPromises) {\n\t\t\t\t\tresultPromises = [];\n\t\t\t\t}\n\n\t\t\t\tresultPromises.push(result);\n\t\t\t}\n\t\t}\n\n\t\t// With result promises, we have to loop over each and\n\t\t// await the result before we can return any result.\n\t\tif (resultPromises) {\n\t\t\treturn (async () => {\n\t\t\t\tfor (const resultPromise of resultPromises) {\n\t\t\t\t\tconst result = await resultPromise;\n\t\t\t\t\tif (typeof result === 'string') {\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\t\t\t})();\n\t\t}\n\n\t\treturn null;\n\t};\n\n\tconst withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n\tif (withBasenames) {\n\t\tresultExpression.allBasenames = withBasenames.allBasenames;\n\t}\n\n\tconst allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, [] as string[]);\n\tif (allPaths.length) {\n\t\tresultExpression.allPaths = allPaths;\n\t}\n\n\treturn resultExpression;\n}\n\nfunction parseExpressionPattern(pattern: string, value: boolean | SiblingClause, options: IGlobOptions): (ParsedStringPattern | ParsedExpressionPattern) {\n\tif (value === false) {\n\t\treturn NULL; // pattern is disabled\n\t}\n\n\tconst parsedPattern = parsePattern(pattern, options);\n\tif (parsedPattern === NULL) {\n\t\treturn NULL;\n\t}\n\n\t// Expression Pattern is <boolean>\n\tif (typeof value === 'boolean') {\n\t\treturn parsedPattern;\n\t}\n\n\t// Expression Pattern is <SiblingClause>\n\tif (value) {\n\t\tconst when = value.when;\n\t\tif (typeof when === 'string') {\n\t\t\tconst result: ParsedExpressionPattern = (path: string, basename?: string, name?: string, hasSibling?: (name: string) => boolean | Promise<boolean>) => {\n\t\t\t\tif (!hasSibling || !parsedPattern(path, basename)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tconst clausePattern = when.replace('$(basename)', () => name!);\n\t\t\t\tconst matched = hasSibling(clausePattern);\n\t\t\t\treturn isThenable(matched) ?\n\t\t\t\t\tmatched.then(match => match ? pattern : null) :\n\t\t\t\t\tmatched ? pattern : null;\n\t\t\t};\n\n\t\t\tresult.requiresSiblings = true;\n\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t// Expression is anything\n\treturn parsedPattern;\n}\n\nfunction aggregateBasenameMatches(parsedPatterns: Array<ParsedStringPattern | ParsedExpressionPattern>, result?: string): Array<ParsedStringPattern | ParsedExpressionPattern> {\n\tconst basenamePatterns = parsedPatterns.filter(parsedPattern => !!(<ParsedStringPattern>parsedPattern).basenames);\n\tif (basenamePatterns.length < 2) {\n\t\treturn parsedPatterns;\n\t}\n\n\tconst basenames = basenamePatterns.reduce<string[]>((all, current) => {\n\t\tconst basenames = (<ParsedStringPattern>current).basenames;\n\n\t\treturn basenames ? all.concat(basenames) : all;\n\t}, [] as string[]);\n\n\tlet patterns: string[];\n\tif (result) {\n\t\tpatterns = [];\n\n\t\tfor (let i = 0, n = basenames.length; i < n; i++) {\n\t\t\tpatterns.push(result);\n\t\t}\n\t} else {\n\t\tpatterns = basenamePatterns.reduce((all, current) => {\n\t\t\tconst patterns = (<ParsedStringPattern>current).patterns;\n\n\t\t\treturn patterns ? all.concat(patterns) : all;\n\t\t}, [] as string[]);\n\t}\n\n\tconst aggregate: ParsedStringPattern = function (path: string, basename?: string) {\n\t\tif (typeof path !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!basename) {\n\t\t\tlet i: number;\n\t\t\tfor (i = path.length; i > 0; i--) {\n\t\t\t\tconst ch = path.charCodeAt(i - 1);\n\t\t\t\tif (ch === CharCode.Slash || ch === CharCode.Backslash) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasename = path.substr(i);\n\t\t}\n\n\t\tconst index = basenames.indexOf(basename);\n\t\treturn index !== -1 ? patterns[index] : null;\n\t};\n\n\taggregate.basenames = basenames;\n\taggregate.patterns = patterns;\n\taggregate.allBasenames = basenames;\n\n\tconst aggregatedPatterns = parsedPatterns.filter(parsedPattern => !(<ParsedStringPattern>parsedPattern).basenames);\n\taggregatedPatterns.push(aggregate);\n\n\treturn aggregatedPatterns;\n}\n\nexport function patternsEquals(patternsA: Array<string | IRelativePattern> | undefined, patternsB: Array<string | IRelativePattern> | undefined): boolean {\n\treturn equals(patternsA, patternsB, (a, b) => {\n\t\tif (typeof a === 'string' && typeof b === 'string') {\n\t\t\treturn a === b;\n\t\t}\n\n\t\tif (typeof a !== 'string' && typeof b !== 'string') {\n\t\t\treturn a.base === b.base && a.pattern === b.pattern;\n\t\t}\n\n\t\treturn false;\n\t});\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ITextSearchResult } from 'vs/workbench/services/search/common/search';\nimport { TextSearchPreviewOptions } from 'vs/workbench/services/search/common/searchExtTypes';\nimport { Range } from 'vs/editor/common/core/range';\n\nexport const getFileResults = (\n\tbytes: Uint8Array,\n\tpattern: RegExp,\n\toptions: {\n\t\tbeforeContext: number;\n\t\tafterContext: number;\n\t\tpreviewOptions: TextSearchPreviewOptions | undefined;\n\t\tremainingResultQuota: number;\n\t}\n): ITextSearchResult[] => {\n\n\tlet text: string;\n\tif (bytes[0] === 0xff && bytes[1] === 0xfe) {\n\t\ttext = new TextDecoder('utf-16le').decode(bytes);\n\t} else if (bytes[0] === 0xfe && bytes[1] === 0xff) {\n\t\ttext = new TextDecoder('utf-16be').decode(bytes);\n\t} else {\n\t\ttext = new TextDecoder('utf8').decode(bytes);\n\t\tif (text.slice(0, 1000).includes('\\uFFFD') && bytes.includes(0)) {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tconst results: ITextSearchResult[] = [];\n\n\tconst patternIndecies: { matchStartIndex: number; matchedText: string }[] = [];\n\n\tlet patternMatch: RegExpExecArray | null = null;\n\tlet remainingResultQuota = options.remainingResultQuota;\n\twhile (remainingResultQuota >= 0 && (patternMatch = pattern.exec(text))) {\n\t\tpatternIndecies.push({ matchStartIndex: patternMatch.index, matchedText: patternMatch[0] });\n\t\tremainingResultQuota--;\n\t}\n\n\tif (patternIndecies.length) {\n\t\tconst contextLinesNeeded = new Set<number>();\n\t\tconst resultLines = new Set<number>();\n\n\t\tconst lineRanges: { start: number; end: number }[] = [];\n\t\tconst readLine = (lineNumber: number) => text.slice(lineRanges[lineNumber].start, lineRanges[lineNumber].end);\n\n\t\tlet prevLineEnd = 0;\n\t\tlet lineEndingMatch: RegExpExecArray | null = null;\n\t\tconst lineEndRegex = /\\r?\\n/g;\n\t\twhile ((lineEndingMatch = lineEndRegex.exec(text))) {\n\t\t\tlineRanges.push({ start: prevLineEnd, end: lineEndingMatch.index });\n\t\t\tprevLineEnd = lineEndingMatch.index + lineEndingMatch[0].length;\n\t\t}\n\t\tif (prevLineEnd < text.length) { lineRanges.push({ start: prevLineEnd, end: text.length }); }\n\n\t\tlet startLine = 0;\n\t\tfor (const { matchStartIndex, matchedText } of patternIndecies) {\n\t\t\tif (remainingResultQuota < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\twhile (Boolean(lineRanges[startLine + 1]) && matchStartIndex > lineRanges[startLine].end) {\n\t\t\t\tstartLine++;\n\t\t\t}\n\t\t\tlet endLine = startLine;\n\t\t\twhile (Boolean(lineRanges[endLine + 1]) && matchStartIndex + matchedText.length > lineRanges[endLine].end) {\n\t\t\t\tendLine++;\n\t\t\t}\n\n\t\t\tif (options.beforeContext) {\n\t\t\t\tfor (let contextLine = Math.max(0, startLine - options.beforeContext); contextLine < startLine; contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet previewText = '';\n\t\t\tlet offset = 0;\n\t\t\tfor (let matchLine = startLine; matchLine <= endLine; matchLine++) {\n\t\t\t\tlet previewLine = readLine(matchLine);\n\t\t\t\tif (options.previewOptions?.charsPerLine && previewLine.length > options.previewOptions.charsPerLine) {\n\t\t\t\t\toffset = Math.max(matchStartIndex - lineRanges[startLine].start - 20, 0);\n\t\t\t\t\tpreviewLine = previewLine.substr(offset, options.previewOptions.charsPerLine);\n\t\t\t\t}\n\t\t\t\tpreviewText += `${previewLine}\\n`;\n\t\t\t\tresultLines.add(matchLine);\n\t\t\t}\n\n\t\t\tconst fileRange = new Range(\n\t\t\t\tstartLine,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start,\n\t\t\t\tendLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start\n\t\t\t);\n\t\t\tconst previewRange = new Range(\n\t\t\t\t0,\n\t\t\t\tmatchStartIndex - lineRanges[startLine].start - offset,\n\t\t\t\tendLine - startLine,\n\t\t\t\tmatchStartIndex + matchedText.length - lineRanges[endLine].start - (endLine === startLine ? offset : 0)\n\t\t\t);\n\n\t\t\tconst match: ITextSearchResult = {\n\t\t\t\tranges: fileRange,\n\t\t\t\tpreview: { text: previewText, matches: previewRange },\n\t\t\t};\n\t\t\tresults.push(match);\n\n\t\t\tif (options.afterContext) {\n\t\t\t\tfor (let contextLine = endLine + 1; contextLine <= Math.min(endLine + options.afterContext, lineRanges.length - 1); contextLine++) {\n\t\t\t\t\tcontextLinesNeeded.add(contextLine);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (const contextLine of contextLinesNeeded) {\n\t\t\tif (!resultLines.has(contextLine)) {\n\n\t\t\t\tresults.push({\n\t\t\t\t\ttext: readLine(contextLine),\n\t\t\t\t\tlineNumber: contextLine + 1,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\treturn results;\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\n\n\nexport class IgnoreFile {\n\n\tprivate isPathIgnored: (path: string, isDir: boolean, parent?: IgnoreFile) => boolean;\n\n\tconstructor(\n\t\tcontents: string,\n\t\tprivate readonly location: string,\n\t\tprivate readonly parent?: IgnoreFile) {\n\t\tif (location[location.length - 1] === '\\\\') {\n\t\t\tthrow Error('Unexpected path format, do not use trailing backslashes');\n\t\t}\n\t\tif (location[location.length - 1] !== '/') {\n\t\t\tlocation += '/';\n\t\t}\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Updates the contents of the ignorefile. Preservering the location and parent\n\t * @param contents The new contents of the gitignore file\n\t */\n\tupdateContents(contents: string) {\n\t\tthis.isPathIgnored = this.parseIgnoreFile(contents, this.location, this.parent);\n\t}\n\n\t/**\n\t * Returns true if a path in a traversable directory has not been ignored.\n\t *\n\t * Note: For performance reasons this does not check if the parent directories have been ignored,\n\t * so it should always be used in tandem with `shouldTraverseDir` when walking a directory.\n\t *\n\t * In cases where a path must be tested in isolation, `isArbitraryPathIncluded` should be used.\n\t */\n\tisPathIncludedInTraversal(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst ignored = this.isPathIgnored(path, isDir);\n\n\t\treturn !ignored;\n\t}\n\n\t/**\n\t * Returns true if an arbitrary path has not been ignored.\n\t * This is an expensive operation and should only be used ouside of traversals.\n\t */\n\tisArbitraryPathIgnored(path: string, isDir: boolean): boolean {\n\t\tif (path[0] !== '/' || path[path.length - 1] === '/') {\n\t\t\tthrow Error('Unexpected path format, expectred to begin with slash and end without. got:' + path);\n\t\t}\n\n\t\tconst segments = path.split('/').filter(x => x);\n\t\tlet ignored = false;\n\n\t\tlet walkingPath = '';\n\n\t\tfor (let i = 0; i < segments.length; i++) {\n\t\t\tconst isLast = i === segments.length - 1;\n\t\t\tconst segment = segments[i];\n\n\t\t\twalkingPath = walkingPath + '/' + segment;\n\n\t\t\tif (!this.isPathIncludedInTraversal(walkingPath, isLast ? isDir : true)) {\n\t\t\t\tignored = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn ignored;\n\t}\n\n\tprivate gitignoreLinesToExpression(lines: string[], dirPath: string, trimForExclusions: boolean): glob.ParsedExpression {\n\t\tconst includeLines = lines.map(line => this.gitignoreLineToGlob(line, dirPath));\n\n\t\tconst includeExpression: glob.IExpression = Object.create(null);\n\t\tfor (const line of includeLines) {\n\t\t\tincludeExpression[line] = true;\n\t\t}\n\n\t\treturn glob.parse(includeExpression, { trimForExclusions });\n\t}\n\n\n\tprivate parseIgnoreFile(ignoreContents: string, dirPath: string, parent: IgnoreFile | undefined): (path: string, isDir: boolean) => boolean {\n\t\tconst contentLines = ignoreContents\n\t\t\t.split('\\n')\n\t\t\t.map(line => line.trim())\n\t\t\t.filter(line => line && line[0] !== '#');\n\n\t\t// Pull out all the lines that end with `/`, those only apply to directories\n\t\tconst fileLines = contentLines.filter(line => !line.endsWith('/'));\n\n\t\tconst fileIgnoreLines = fileLines.filter(line => !line.includes('!'));\n\t\tconst isFileIgnored = this.gitignoreLinesToExpression(fileIgnoreLines, dirPath, true);\n\n\t\t// TODO: Slight hack... this naieve approach may reintroduce too many files in cases of weirdly complex .gitignores\n\t\tconst fileIncludeLines = fileLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isFileIncluded = this.gitignoreLinesToExpression(fileIncludeLines, dirPath, false);\n\n\t\t// When checking if a dir is ignored we can use all lines\n\t\tconst dirIgnoreLines = contentLines.filter(line => !line.includes('!'));\n\t\tconst isDirIgnored = this.gitignoreLinesToExpression(dirIgnoreLines, dirPath, true);\n\n\t\t// Same hack.\n\t\tconst dirIncludeLines = contentLines.filter(line => line.includes('!')).map(line => line.replace(/!/g, ''));\n\t\tconst isDirIncluded = this.gitignoreLinesToExpression(dirIncludeLines, dirPath, false);\n\n\t\tconst isPathIgnored = (path: string, isDir: boolean) => {\n\t\t\tif (!path.startsWith(dirPath)) { return false; }\n\t\t\tif (isDir && isDirIgnored(path) && !isDirIncluded(path)) { return true; }\n\t\t\tif (isFileIgnored(path) && !isFileIncluded(path)) { return true; }\n\n\t\t\tif (parent) { return parent.isPathIgnored(path, isDir); }\n\n\t\t\treturn false;\n\t\t};\n\n\t\treturn isPathIgnored;\n\t}\n\n\tprivate gitignoreLineToGlob(line: string, dirPath: string): string {\n\t\tconst firstSep = line.indexOf('/');\n\t\tif (firstSep === -1 || firstSep === line.length - 1) {\n\t\t\tline = '**/' + line;\n\t\t} else {\n\t\t\tif (firstSep === 0) {\n\t\t\t\tif (dirPath.slice(-1) === '/') {\n\t\t\t\t\tline = line.slice(1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dirPath.slice(-1) !== '/') {\n\t\t\t\t\tline = '/' + line;\n\t\t\t\t}\n\t\t\t}\n\t\t\tline = dirPath + line;\n\t\t}\n\n\t\treturn line;\n\t}\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport * as glob from 'vs/base/common/glob';\nimport { UriComponents, URI } from 'vs/base/common/uri';\nimport { IRequestHandler } from 'vs/base/common/worker/simpleWorker';\nimport { ILocalFileSearchSimpleWorker, ILocalFileSearchSimpleWorkerHost, IWorkerFileSearchComplete, IWorkerFileSystemDirectoryHandle, IWorkerFileSystemHandle, IWorkerTextSearchComplete } from 'vs/workbench/services/search/common/localFileSearchWorkerTypes';\nimport { ICommonQueryProps, IFileMatch, IFileQueryProps, IFolderQuery, IPatternInfo, ITextQueryProps, } from 'vs/workbench/services/search/common/search';\nimport * as paths from 'vs/base/common/path';\nimport { CancellationToken, CancellationTokenSource } from 'vs/base/common/cancellation';\nimport { getFileResults } from 'vs/workbench/services/search/common/getFileResults';\nimport { IgnoreFile } from 'vs/workbench/services/search/common/ignoreFile';\nimport { createRegExp } from 'vs/base/common/strings';\nimport { Promises } from 'vs/base/common/async';\nimport { ExtUri } from 'vs/base/common/resources';\n\nconst PERF = false;\n\ntype FileNode = {\n\ttype: 'file';\n\tname: string;\n\tpath: string;\n\tresolve: () => Promise<ArrayBuffer>;\n};\n\ntype DirNode = {\n\ttype: 'dir';\n\tname: string;\n\tentries: Promise<(DirNode | FileNode)[]>;\n};\n\nconst globalStart = +new Date();\nconst itrcount: Record<string, number> = {};\nconst time = async <T>(name: string, task: () => Promise<T> | T) => {\n\tif (!PERF) { return task(); }\n\n\tconst start = Date.now();\n\tconst itr = (itrcount[name] ?? 0) + 1;\n\tconsole.info(name, itr, 'starting', Math.round((start - globalStart) * 10) / 10000);\n\n\titrcount[name] = itr;\n\tconst r = await task();\n\tconst end = Date.now();\n\tconsole.info(name, itr, 'took', end - start);\n\treturn r;\n};\n\n/**\n * Called on the worker side\n * @internal\n */\nexport function create(host: ILocalFileSearchSimpleWorkerHost): IRequestHandler {\n\treturn new LocalFileSearchSimpleWorker(host);\n}\n\nexport class LocalFileSearchSimpleWorker implements ILocalFileSearchSimpleWorker, IRequestHandler {\n\t_requestHandlerBrand: any;\n\n\tcancellationTokens: Map<number, CancellationTokenSource> = new Map();\n\n\tconstructor(private host: ILocalFileSearchSimpleWorkerHost) { }\n\n\tcancelQuery(queryId: number): void {\n\t\tthis.cancellationTokens.get(queryId)?.cancel();\n\t}\n\n\tprivate registerCancellationToken(queryId: number): CancellationTokenSource {\n\t\tconst source = new CancellationTokenSource();\n\t\tthis.cancellationTokens.set(queryId, source);\n\t\treturn source;\n\t}\n\n\tasync listDirectory(handle: IWorkerFileSystemDirectoryHandle, query: IFileQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerFileSearchComplete> {\n\t\tconst revivedFolderQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\tconst token = this.registerCancellationToken(queryId);\n\t\tconst entries: string[] = [];\n\t\tlet limitHit = false;\n\t\tlet count = 0;\n\n\t\tconst max = query.maxResults || 512;\n\n\t\tconst filePatternMatcher = query.filePattern\n\t\t\t? (name: string) => query.filePattern!.split('').every(c => name.includes(c))\n\t\t\t: (name: string) => true;\n\n\t\tawait time('listDirectory', () => this.walkFolderQuery(handle, reviveQueryProps(query), revivedFolderQuery, extUri, file => {\n\t\t\tif (!filePatternMatcher(file.name)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcount++;\n\n\t\t\tif (max && count > max) {\n\t\t\t\tlimitHit = true;\n\t\t\t\ttoken.cancel();\n\t\t\t}\n\t\t\treturn entries.push(file.path);\n\t\t}, token.token));\n\n\t\treturn {\n\t\t\tresults: entries,\n\t\t\tlimitHit\n\t\t};\n\t}\n\n\tasync searchDirectory(handle: IWorkerFileSystemDirectoryHandle, query: ITextQueryProps<UriComponents>, folderQuery: IFolderQuery<UriComponents>, ignorePathCasing: boolean, queryId: number): Promise<IWorkerTextSearchComplete> {\n\t\tconst revivedQuery = reviveFolderQuery(folderQuery);\n\t\tconst extUri = new ExtUri(() => ignorePathCasing);\n\n\t\treturn time('searchInFiles', async () => {\n\t\t\tconst token = this.registerCancellationToken(queryId);\n\n\t\t\tconst results: IFileMatch[] = [];\n\n\t\t\tconst pattern = createSearchRegExp(query.contentPattern);\n\n\t\t\tconst onGoingProcesses: Promise<void>[] = [];\n\n\t\t\tlet fileCount = 0;\n\t\t\tlet resultCount = 0;\n\t\t\tconst limitHit = false;\n\n\t\t\tconst processFile = async (file: FileNode) => {\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tfileCount++;\n\n\t\t\t\tconst contents = await file.resolve();\n\t\t\t\tif (token.token.isCancellationRequested) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst bytes = new Uint8Array(contents);\n\t\t\t\tconst fileResults = getFileResults(bytes, pattern, {\n\t\t\t\t\tafterContext: query.afterContext ?? 0,\n\t\t\t\t\tbeforeContext: query.beforeContext ?? 0,\n\t\t\t\t\tpreviewOptions: query.previewOptions,\n\t\t\t\t\tremainingResultQuota: query.maxResults ? (query.maxResults - resultCount) : 10000,\n\t\t\t\t});\n\n\t\t\t\tif (fileResults.length) {\n\t\t\t\t\tresultCount += fileResults.length;\n\t\t\t\t\tif (query.maxResults && resultCount > query.maxResults) {\n\t\t\t\t\t\ttoken.cancel();\n\t\t\t\t\t}\n\t\t\t\t\tconst match = {\n\t\t\t\t\t\tresource: URI.joinPath(revivedQuery.folder, file.path),\n\t\t\t\t\t\tresults: fileResults,\n\t\t\t\t\t};\n\t\t\t\t\tthis.host.sendTextSearchMatch(match, queryId);\n\t\t\t\t\tresults.push(match);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tawait time('walkFolderToResolve', () =>\n\t\t\t\tthis.walkFolderQuery(handle, reviveQueryProps(query), revivedQuery, extUri, async file => onGoingProcesses.push(processFile(file)), token.token)\n\t\t\t);\n\n\t\t\tawait time('resolveOngoingProcesses', () => Promise.all(onGoingProcesses));\n\n\t\t\tif (PERF) { console.log('Searched in', fileCount, 'files'); }\n\n\t\t\treturn {\n\t\t\t\tresults,\n\t\t\t\tlimitHit,\n\t\t\t};\n\t\t});\n\n\t}\n\n\tprivate async walkFolderQuery(handle: IWorkerFileSystemDirectoryHandle, queryProps: ICommonQueryProps<URI>, folderQuery: IFolderQuery<URI>, extUri: ExtUri, onFile: (file: FileNode) => any, token: CancellationToken): Promise<void> {\n\n\t\tconst folderExcludes = glob.parse(folderQuery.excludePattern ?? {}, { trimForExclusions: true }) as glob.ParsedExpression;\n\n\t\t// For folders, only check if the folder is explicitly excluded so walking continues.\n\t\tconst isFolderExcluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return true; }\n\t\t\tif (pathExcludedInQuery(queryProps, path)) { return true; }\n\t\t\treturn false;\n\t\t};\n\n\t\t// For files ensure the full check takes place.\n\t\tconst isFileIncluded = (path: string, basename: string, hasSibling: (query: string) => boolean) => {\n\t\t\tpath = path.slice(1);\n\t\t\tif (folderExcludes(path, basename, hasSibling)) { return false; }\n\t\t\tif (!pathIncludedInQuery(queryProps, path, extUri)) { return false; }\n\t\t\treturn true;\n\t\t};\n\n\t\tconst processFile = (file: FileSystemFileHandle, prior: string): FileNode => {\n\n\t\t\tconst resolved: FileNode = {\n\t\t\t\ttype: 'file',\n\t\t\t\tname: file.name,\n\t\t\t\tpath: prior,\n\t\t\t\tresolve: () => file.getFile().then(r => r.arrayBuffer())\n\t\t\t} as const;\n\n\t\t\treturn resolved;\n\t\t};\n\n\t\tconst isFileSystemDirectoryHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemDirectoryHandle => {\n\t\t\treturn handle.kind === 'directory';\n\t\t};\n\n\t\tconst isFileSystemFileHandle = (handle: IWorkerFileSystemHandle): handle is FileSystemFileHandle => {\n\t\t\treturn handle.kind === 'file';\n\t\t};\n\n\t\tconst processDirectory = async (directory: IWorkerFileSystemDirectoryHandle, prior: string, ignoreFile?: IgnoreFile): Promise<DirNode> => {\n\n\t\t\tif (!folderQuery.disregardIgnoreFiles) {\n\t\t\t\tconst ignoreFiles = await Promise.all([\n\t\t\t\t\tdirectory.getFileHandle('.gitignore').catch(e => undefined),\n\t\t\t\t\tdirectory.getFileHandle('.ignore').catch(e => undefined),\n\t\t\t\t]);\n\n\t\t\t\tawait Promise.all(ignoreFiles.map(async file => {\n\t\t\t\t\tif (!file) { return; }\n\n\t\t\t\t\tconst ignoreContents = new TextDecoder('utf8').decode(new Uint8Array(await (await file.getFile()).arrayBuffer()));\n\t\t\t\t\tignoreFile = new IgnoreFile(ignoreContents, prior, ignoreFile);\n\t\t\t\t}));\n\t\t\t}\n\n\t\t\tconst entries = Promises.withAsyncBody<(FileNode | DirNode)[]>(async c => {\n\t\t\t\tconst files: FileNode[] = [];\n\t\t\t\tconst dirs: Promise<DirNode>[] = [];\n\n\t\t\t\tconst entries: [string, IWorkerFileSystemHandle][] = [];\n\t\t\t\tconst sibilings = new Set<string>();\n\n\t\t\t\tfor await (const entry of directory.entries()) {\n\t\t\t\t\tentries.push(entry);\n\t\t\t\t\tsibilings.add(entry[0]);\n\t\t\t\t}\n\n\t\t\t\tfor (const [basename, handle] of entries) {\n\t\t\t\t\tif (token.isCancellationRequested) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst path = prior + basename;\n\n\t\t\t\t\tif (ignoreFile && !ignoreFile.isPathIncludedInTraversal(path, handle.kind === 'directory')) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst hasSibling = (query: string) => sibilings.has(query);\n\n\t\t\t\t\tif (isFileSystemDirectoryHandle(handle) && !isFolderExcluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tdirs.push(processDirectory(handle, path + '/', ignoreFile));\n\t\t\t\t\t} else if (isFileSystemFileHandle(handle) && isFileIncluded(path, basename, hasSibling)) {\n\t\t\t\t\t\tfiles.push(processFile(handle, path));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tc([...await Promise.all(dirs), ...files]);\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\ttype: 'dir',\n\t\t\t\tname: directory.name,\n\t\t\t\tentries\n\t\t\t};\n\t\t};\n\n\t\tconst resolveDirectory = async (directory: DirNode, onFile: (f: FileNode) => any) => {\n\t\t\tif (token.isCancellationRequested) { return; }\n\n\t\t\tawait Promise.all(\n\t\t\t\t(await directory.entries)\n\t\t\t\t\t.sort((a, b) => -(a.type === 'dir' ? 0 : 1) + (b.type === 'dir' ? 0 : 1))\n\t\t\t\t\t.map(async entry => {\n\t\t\t\t\t\tif (entry.type === 'dir') {\n\t\t\t\t\t\t\treturn resolveDirectory(entry, onFile);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn onFile(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t};\n\n\t\tconst processed = await time('process', () => processDirectory(handle, '/'));\n\t\tawait time('resolve', () => resolveDirectory(processed, onFile));\n\t}\n}\n\nfunction createSearchRegExp(options: IPatternInfo): RegExp {\n\treturn createRegExp(options.pattern, !!options.isRegExp, {\n\t\twholeWord: options.isWordMatch,\n\t\tglobal: true,\n\t\tmatchCase: options.isCaseSensitive,\n\t\tmultiline: true,\n\t\tunicode: true,\n\t});\n}\n\nfunction reviveFolderQuery(folderQuery: IFolderQuery<UriComponents>): IFolderQuery<URI> {\n\treturn {\n\t\t...folderQuery,\n\t\tfolder: URI.revive(folderQuery.folder),\n\t};\n}\n\nfunction reviveQueryProps(queryProps: ICommonQueryProps<UriComponents>): ICommonQueryProps<URI> {\n\treturn {\n\t\t...queryProps,\n\t\textraFileResources: queryProps.extraFileResources?.map(r => URI.revive(r)),\n\t\tfolderQueries: queryProps.folderQueries.map(fq => reviveFolderQuery(fq)),\n\t};\n}\n\n\nfunction pathExcludedInQuery(queryProps: ICommonQueryProps<URI>, fsPath: string): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, fsPath)) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunction pathIncludedInQuery(queryProps: ICommonQueryProps<URI>, path: string, extUri: ExtUri): boolean {\n\tif (queryProps.excludePattern && glob.match(queryProps.excludePattern, path)) {\n\t\treturn false;\n\t}\n\n\tif (queryProps.includePattern || queryProps.usingSearchPaths) {\n\t\tif (queryProps.includePattern && glob.match(queryProps.includePattern, path)) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If searchPaths are being used, the extra file must be in a subfolder and match the pattern, if present\n\t\tif (queryProps.usingSearchPaths) {\n\n\t\t\treturn !!queryProps.folderQueries && queryProps.folderQueries.some(fq => {\n\t\t\t\tconst searchPath = fq.folder;\n\t\t\t\tconst uri = URI.file(path);\n\t\t\t\tif (extUri.isEqualOrParent(uri, searchPath)) {\n\t\t\t\t\tconst relPath = paths.relative(searchPath.path, uri.path);\n\t\t\t\t\treturn !fq.includePattern || !!glob.match(fq.includePattern, relPath);\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","exports","$og","$pg","$qg","$rg","$sg","$tg","$ug","$vg","$wg","$xg","$yg","$zg","$Ag","$Bg","$Cg","$Dg","$Eg","code","osPath","path_1","path","sep","firstLetter","pos","start","platform_1","WINDOWS_INVALID_FILE_CHARS","UNIX_INVALID_FILE_CHARS","WINDOWS_FORBIDDEN_NAMES","name","isWindowsOS","invalidFileChars","pathA","pathB","ignoreCase","identityEquals","strings_1","base","parentCandidate","separator","sepOffset","char0","candidate","cwd","pathNormalized","rawPath","segments","line","column","segment","segmentAsNumber","types_1","pathChars","windowsSafePathFirstChars","parent","prefix","randomLength","suffix","pathCharsTouse","randomFileName","$Fg","$Gg","$Kg","Schemas","target","scheme","uri_1","schemes","RemoteAuthoritiesImpl","schema","delegate","product","serverBasePath","paths","authority","host","port","connectionToken","uri","err","errors","query","platform","basePath","FileAccessImpl","resourcePath","require","uriOrModule","moduleIdToUrl","COI","coiHeaders","coiSearchParamName","getHeadersFromQuery","url","params","value","addSearchParam","urlOrSearch","coop","coep","$Xg","$gh","$hh","$Yg","a","uri1","uri2","ignoreFragment","network_1","extpath","resource","pathFragment","dirname","normalizedPath","from","to","relativePath","fromPath","toPath","newURI","a1","a2","fsp","p","isRootSep","_","items","resourceAccessor","distinctParents","candidateResource","otherItem","index","DataUri","parseMetaData","dataUri","metadata","property","key","mime","localScheme","$ih","$jh","$kh","$lh","$mh","$nh","$oh","$ph","$xh","$yh","$zh","$Ah","$Bh","$Qh","$Yh","obj","callback","source","cancellation_1","thenable","promise","resolve","reject","subscription","errors_1","onfinally","token","defaultValue","ref","cancellablePromises","resolvedPromiseIndex","promises","cancellablePromise","timeout","onTimeout","promiseResolve","timer","item","res","rej","$qh","promiseFactory","onComplete","$rh","promiseTask","$sh","newPromise","timeoutDeferred","fn","scheduled","handle","microtaskDeferred","$th","defaultDelay","task","delay","symbols_1","$uh","$vh","c","e","$wh","autoOpenTimeMs","millis","disposable","handler","store","lifecycle_1","promiseFactories","results","next","thenHandler","n","shouldStop","t","loop","factory","promiseList","todo","finish","$Ch","maxDegreeOfParalellism","event_1","iLimitedTask","$Dh","$Eh","$Rh","$Fh","$Th","queue","extUri","resources_1","drainListenerId","drainListener","drainer","$Gh","runner","$Hh","interval","context","$Ih","$Jh","$Kh","unit","units","$Lh","g","h","_targetWindow","disposed","end","targetWindow","$Oh","executor","$Ph","retries","lastError","error","taskId","onCancel","queued","run","promiseReject","$Sh","d","f","now","DeferredOutcome","Promises","settled","firstError","withAsyncBody","bodyFn","$Uh","$Vh","b","lazy_1","AsyncIterableSourceState","$Wh","writer","emitter","iterables","iterable","onReturn","mapFn","filterFn","values","$Xh","m","innerIterable","$Zh","earlyError","earlyItems","$lk","$ok","$pk","$qk","$rk","$sk","$tk","$uk","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","pattern","splitChar","inBraces","inBrackets","curVal","char","parseRegExp","regEx","previousSegmentWasGlobStar","braceVal","bracketVal","braceRegExp","choice","T1","T2","T3","T3_2","T4","T5","CACHE","map_1","FALSE","NULL","parsePattern","arg1","options","patternKey","parsedPattern","wrapRelativePattern","match","trivia1","trimForExclusions","trivia2","trivia3","trivia4and5","toRegExp","arg2","wrappedPattern","basename","extpath_1","slashBase","backslashBase","basenames","parsedPatterns","aggregateBasenameMatches","patternsLength","withBasenames","allPaths","all","current","targetPath","matchPathEnds","usingPosixSep","nativePath","nativePathEnd","targetPathEnd","regExp","hasSibling","resultPattern","parsedExpression","rp","patternOrExpression","expression","parseExpressionPattern","resultExpression","resultPromises","async_1","resultPromise","when","clausePattern","matched","basenamePatterns","patterns","aggregate","ch","aggregatedPatterns","patternsA","patternsB","arrays_1","$Dqc","bytes","text","patternIndecies","patternMatch","remainingResultQuota","contextLinesNeeded","resultLines","lineRanges","readLine","lineNumber","prevLineEnd","lineEndingMatch","lineEndRegex","startLine","matchStartIndex","matchedText","endLine","contextLine","previewText","offset","matchLine","previewLine","fileRange","range_1","previewRange","$eqb","contents","isDir","x","ignored","walkingPath","isLast","lines","dirPath","includeLines","includeExpression","glob","ignoreContents","contentLines","fileLines","fileIgnoreLines","isFileIgnored","fileIncludeLines","isFileIncluded","dirIgnoreLines","isDirIgnored","dirIncludeLines","isDirIncluded","firstSep","create","PERF","globalStart","itrcount","time","itr","r","LocalFileSearchSimpleWorker","queryId","folderQuery","ignorePathCasing","revivedFolderQuery","reviveFolderQuery","entries","limitHit","count","max","filePatternMatcher","reviveQueryProps","file","revivedQuery","createSearchRegExp","onGoingProcesses","fileCount","resultCount","processFile","fileResults","getFileResults_1","queryProps","onFile","folderExcludes","isFolderExcluded","pathExcludedInQuery","pathIncludedInQuery","prior","isFileSystemDirectoryHandle","isFileSystemFileHandle","processDirectory","directory","ignoreFile","ignoreFiles","ignoreFile_1","files","dirs","sibilings","entry","resolveDirectory","processed","fq","fsPath","searchPath","relPath"],"file":"localFileSearch.js"}