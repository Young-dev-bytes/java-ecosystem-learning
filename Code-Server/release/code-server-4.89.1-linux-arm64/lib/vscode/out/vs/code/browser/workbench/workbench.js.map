{"version":3,"sources":["out-vscode-reh-web/vs/code/browser/workbench/fake","out-vscode-reh-web/vs/code/browser/workbench/file:/home/runner/work/code-server/code-server/lib/vscode/src/vs/code/browser/workbench/workbench.ts"],"sourcesContent":["}).call(this);","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { isStandalone } from 'vs/base/browser/browser';\nimport { mainWindow } from 'vs/base/browser/window';\nimport { VSBuffer, decodeBase64, encodeBase64 } from 'vs/base/common/buffer';\nimport { Emitter } from 'vs/base/common/event';\nimport { Disposable, IDisposable } from 'vs/base/common/lifecycle';\nimport { parse } from 'vs/base/common/marshalling';\nimport { Schemas } from 'vs/base/common/network';\nimport { posix } from 'vs/base/common/path';\nimport { isEqual } from 'vs/base/common/resources';\nimport { ltrim } from 'vs/base/common/strings';\nimport { URI, UriComponents } from 'vs/base/common/uri';\nimport product from 'vs/platform/product/common/product';\nimport { ISecretStorageProvider } from 'vs/platform/secrets/common/secrets';\nimport { isFolderToOpen, isWorkspaceToOpen } from 'vs/platform/window/common/window';\nimport type { IWorkbenchConstructionOptions, IWorkspace, IWorkspaceProvider } from 'vs/workbench/browser/web.api';\nimport { AuthenticationSessionInfo } from 'vs/workbench/services/authentication/browser/authenticationService';\nimport { extractLocalHostUriMetaDataForPortMapping, TunnelOptions, TunnelCreationOptions } from 'vs/platform/tunnel/common/tunnel';\nimport type { IURLCallbackProvider } from 'vs/workbench/services/url/browser/urlService';\nimport { create } from 'vs/workbench/workbench.web.main';\n\ninterface ISecretStorageCrypto {\n\tseal(data: string): Promise<string>;\n\tunseal(data: string): Promise<string>;\n}\n\nclass TransparentCrypto implements ISecretStorageCrypto {\n\tasync seal(data: string): Promise<string> {\n\t\treturn data;\n\t}\n\n\tasync unseal(data: string): Promise<string> {\n\t\treturn data;\n\t}\n}\n\nconst enum AESConstants {\n\tALGORITHM = 'AES-GCM',\n\tKEY_LENGTH = 256,\n\tIV_LENGTH = 12,\n}\n\nclass ServerKeyedAESCrypto implements ISecretStorageCrypto {\n\tprivate _serverKey: Uint8Array | undefined;\n\n\t/** Gets whether the algorithm is supported; requires a secure context */\n\tpublic static supported() {\n\t\treturn !!crypto.subtle;\n\t}\n\n\tconstructor(private readonly authEndpoint: string) { }\n\n\tasync seal(data: string): Promise<string> {\n\t\t// Get a new key and IV on every change, to avoid the risk of reusing the same key and IV pair with AES-GCM\n\t\t// (see also: https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams#properties)\n\t\tconst iv = mainWindow.crypto.getRandomValues(new Uint8Array(AESConstants.IV_LENGTH));\n\t\t// crypto.getRandomValues isn't a good-enough PRNG to generate crypto keys, so we need to use crypto.subtle.generateKey and export the key instead\n\t\tconst clientKeyObj = await mainWindow.crypto.subtle.generateKey(\n\t\t\t{ name: AESConstants.ALGORITHM as const, length: AESConstants.KEY_LENGTH as const },\n\t\t\ttrue,\n\t\t\t['encrypt', 'decrypt']\n\t\t);\n\n\t\tconst clientKey = new Uint8Array(await mainWindow.crypto.subtle.exportKey('raw', clientKeyObj));\n\t\tconst key = await this.getKey(clientKey);\n\t\tconst dataUint8Array = new TextEncoder().encode(data);\n\t\tconst cipherText: ArrayBuffer = await mainWindow.crypto.subtle.encrypt(\n\t\t\t{ name: AESConstants.ALGORITHM as const, iv },\n\t\t\tkey,\n\t\t\tdataUint8Array\n\t\t);\n\n\t\t// Base64 encode the result and store the ciphertext, the key, and the IV in localStorage\n\t\t// Note that the clientKey and IV don't need to be secret\n\t\tconst result = new Uint8Array([...clientKey, ...iv, ...new Uint8Array(cipherText)]);\n\t\treturn encodeBase64(VSBuffer.wrap(result));\n\t}\n\n\tasync unseal(data: string): Promise<string> {\n\t\t// encrypted should contain, in order: the key (32-byte), the IV for AES-GCM (12-byte) and the ciphertext (which has the GCM auth tag at the end)\n\t\t// Minimum length must be 44 (key+IV length) + 16 bytes (1 block encrypted with AES - regardless of key size)\n\t\tconst dataUint8Array = decodeBase64(data);\n\n\t\tif (dataUint8Array.byteLength < 60) {\n\t\t\tthrow Error('Invalid length for the value for credentials.crypto');\n\t\t}\n\n\t\tconst keyLength = AESConstants.KEY_LENGTH / 8;\n\t\tconst clientKey = dataUint8Array.slice(0, keyLength);\n\t\tconst iv = dataUint8Array.slice(keyLength, keyLength + AESConstants.IV_LENGTH);\n\t\tconst cipherText = dataUint8Array.slice(keyLength + AESConstants.IV_LENGTH);\n\n\t\t// Do the decryption and parse the result as JSON\n\t\tconst key = await this.getKey(clientKey.buffer);\n\t\tconst decrypted = await mainWindow.crypto.subtle.decrypt(\n\t\t\t{ name: AESConstants.ALGORITHM as const, iv: iv.buffer },\n\t\t\tkey,\n\t\t\tcipherText.buffer\n\t\t);\n\n\t\treturn new TextDecoder().decode(new Uint8Array(decrypted));\n\t}\n\n\t/**\n\t * Given a clientKey, returns the CryptoKey object that is used to encrypt/decrypt the data.\n\t * The actual key is (clientKey XOR serverKey)\n\t */\n\tprivate async getKey(clientKey: Uint8Array): Promise<CryptoKey> {\n\t\tif (!clientKey || clientKey.byteLength !== AESConstants.KEY_LENGTH / 8) {\n\t\t\tthrow Error('Invalid length for clientKey');\n\t\t}\n\n\t\tconst serverKey = await this.getServerKeyPart();\n\t\tconst keyData = new Uint8Array(AESConstants.KEY_LENGTH / 8);\n\n\t\tfor (let i = 0; i < keyData.byteLength; i++) {\n\t\t\tkeyData[i] = clientKey[i]! ^ serverKey[i]!;\n\t\t}\n\n\t\treturn mainWindow.crypto.subtle.importKey(\n\t\t\t'raw',\n\t\t\tkeyData,\n\t\t\t{\n\t\t\t\tname: AESConstants.ALGORITHM as const,\n\t\t\t\tlength: AESConstants.KEY_LENGTH as const,\n\t\t\t},\n\t\t\ttrue,\n\t\t\t['encrypt', 'decrypt']\n\t\t);\n\t}\n\n\tprivate async getServerKeyPart(): Promise<Uint8Array> {\n\t\tif (this._serverKey) {\n\t\t\treturn this._serverKey;\n\t\t}\n\n\t\tlet attempt = 0;\n\t\tlet lastError: unknown | undefined;\n\n\t\twhile (attempt <= 3) {\n\t\t\ttry {\n\t\t\t\tconst res = await fetch(this.authEndpoint, { credentials: 'include', method: 'POST' });\n\t\t\t\tif (!res.ok) {\n\t\t\t\t\tthrow new Error(res.statusText);\n\t\t\t\t}\n\t\t\t\tconst serverKey = new Uint8Array(await await res.arrayBuffer());\n\t\t\t\tif (serverKey.byteLength !== AESConstants.KEY_LENGTH / 8) {\n\t\t\t\t\tthrow Error(`The key retrieved by the server is not ${AESConstants.KEY_LENGTH} bit long.`);\n\t\t\t\t}\n\t\t\t\tthis._serverKey = serverKey;\n\t\t\t\treturn this._serverKey;\n\t\t\t} catch (e) {\n\t\t\t\tlastError = e;\n\t\t\t\tattempt++;\n\n\t\t\t\t// exponential backoff\n\t\t\t\tawait new Promise(resolve => setTimeout(resolve, attempt * attempt * 100));\n\t\t\t}\n\t\t}\n\n\t\tthrow lastError;\n\t}\n}\n\nexport class LocalStorageSecretStorageProvider implements ISecretStorageProvider {\n\tprivate readonly _storageKey = 'secrets.provider';\n\n\tprivate _secretsPromise: Promise<Record<string, string>> = this.load();\n\n\ttype: 'in-memory' | 'persisted' | 'unknown' = 'persisted';\n\n\tconstructor(\n\t\tprivate readonly crypto: ISecretStorageCrypto,\n\t) { }\n\n\tprivate async load(): Promise<Record<string, string>> {\n\t\tconst record = this.loadAuthSessionFromElement();\n\t\t// Get the secrets from localStorage\n\t\tconst encrypted = localStorage.getItem(this._storageKey);\n\t\tif (encrypted) {\n\t\t\ttry {\n\t\t\t\tconst decrypted = JSON.parse(await this.crypto.unseal(encrypted));\n\t\t\t\treturn { ...record, ...decrypted };\n\t\t\t} catch (err) {\n\t\t\t\t// TODO: send telemetry\n\t\t\t\tconsole.error('Failed to decrypt secrets from localStorage', err);\n\t\t\t\tlocalStorage.removeItem(this._storageKey);\n\t\t\t}\n\t\t}\n\n\t\treturn record;\n\t}\n\n\tprivate loadAuthSessionFromElement(): Record<string, string> {\n\t\tlet authSessionInfo: (AuthenticationSessionInfo & { scopes: string[][] }) | undefined;\n\t\tconst authSessionElement = mainWindow.document.getElementById('vscode-workbench-auth-session');\n\t\tconst authSessionElementAttribute = authSessionElement ? authSessionElement.getAttribute('data-settings') : undefined;\n\t\tif (authSessionElementAttribute) {\n\t\t\ttry {\n\t\t\t\tauthSessionInfo = JSON.parse(authSessionElementAttribute);\n\t\t\t} catch (error) { /* Invalid session is passed. Ignore. */ }\n\t\t}\n\n\t\tif (!authSessionInfo) {\n\t\t\treturn {};\n\t\t}\n\n\t\tconst record: Record<string, string> = {};\n\n\t\t// Settings Sync Entry\n\t\trecord[`${product.urlProtocol}.loginAccount`] = JSON.stringify(authSessionInfo);\n\n\t\t// Auth extension Entry\n\t\tif (authSessionInfo.providerId !== 'github') {\n\t\t\tconsole.error(`Unexpected auth provider: ${authSessionInfo.providerId}. Expected 'github'.`);\n\t\t\treturn record;\n\t\t}\n\n\t\tconst authAccount = JSON.stringify({ extensionId: 'vscode.github-authentication', key: 'github.auth' });\n\t\trecord[authAccount] = JSON.stringify(authSessionInfo.scopes.map(scopes => ({\n\t\t\tid: authSessionInfo.id,\n\t\t\tscopes,\n\t\t\taccessToken: authSessionInfo.accessToken\n\t\t})));\n\n\t\treturn record;\n\t}\n\n\tasync get(key: string): Promise<string | undefined> {\n\t\tconst secrets = await this._secretsPromise;\n\t\treturn secrets[key];\n\t}\n\tasync set(key: string, value: string): Promise<void> {\n\t\tconst secrets = await this._secretsPromise;\n\t\tsecrets[key] = value;\n\t\tthis._secretsPromise = Promise.resolve(secrets);\n\t\tthis.save();\n\t}\n\tasync delete(key: string): Promise<void> {\n\t\tconst secrets = await this._secretsPromise;\n\t\tdelete secrets[key];\n\t\tthis._secretsPromise = Promise.resolve(secrets);\n\t\tthis.save();\n\t}\n\n\tprivate async save(): Promise<void> {\n\t\ttry {\n\t\t\tconst encrypted = await this.crypto.seal(JSON.stringify(await this._secretsPromise));\n\t\t\tlocalStorage.setItem(this._storageKey, encrypted);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t}\n\t}\n}\n\n\nclass LocalStorageURLCallbackProvider extends Disposable implements IURLCallbackProvider {\n\n\tprivate static REQUEST_ID = 0;\n\n\tprivate static QUERY_KEYS: ('scheme' | 'authority' | 'path' | 'query' | 'fragment')[] = [\n\t\t'scheme',\n\t\t'authority',\n\t\t'path',\n\t\t'query',\n\t\t'fragment'\n\t];\n\n\tprivate readonly _onCallback = this._register(new Emitter<URI>());\n\treadonly onCallback = this._onCallback.event;\n\n\tprivate pendingCallbacks = new Set<number>();\n\tprivate lastTimeChecked = Date.now();\n\tprivate checkCallbacksTimeout: unknown | undefined = undefined;\n\tprivate onDidChangeLocalStorageDisposable: IDisposable | undefined;\n\n\tconstructor(private readonly _callbackRoute: string) {\n\t\tsuper();\n\t}\n\n\tcreate(options: Partial<UriComponents> = {}): URI {\n\t\tconst id = ++LocalStorageURLCallbackProvider.REQUEST_ID;\n\t\tconst queryParams: string[] = [`vscode-reqid=${id}`];\n\n\t\tfor (const key of LocalStorageURLCallbackProvider.QUERY_KEYS) {\n\t\t\tconst value = options[key];\n\n\t\t\tif (value) {\n\t\t\t\tqueryParams.push(`vscode-${key}=${encodeURIComponent(value)}`);\n\t\t\t}\n\t\t}\n\n\t\t// TODO@joao remove eventually\n\t\t// https://github.com/microsoft/vscode-dev/issues/62\n\t\t// https://github.com/microsoft/vscode/blob/159479eb5ae451a66b5dac3c12d564f32f454796/extensions/github-authentication/src/githubServer.ts#L50-L50\n\t\tif (!(options.authority === 'vscode.github-authentication' && options.path === '/dummy')) {\n\t\t\tconst key = `vscode-web.url-callbacks[${id}]`;\n\t\t\tlocalStorage.removeItem(key);\n\n\t\t\tthis.pendingCallbacks.add(id);\n\t\t\tthis.startListening();\n\t\t}\n\n\t\tconst path = (mainWindow.location.pathname + \"/\" + this._callbackRoute).replace(/\\/\\/+/g, \"/\");\n\t\treturn URI.parse(mainWindow.location.href).with({ path: path, query: queryParams.join('&') });\n\t}\n\n\tprivate startListening(): void {\n\t\tif (this.onDidChangeLocalStorageDisposable) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst fn = () => this.onDidChangeLocalStorage();\n\t\tmainWindow.addEventListener('storage', fn);\n\t\tthis.onDidChangeLocalStorageDisposable = { dispose: () => mainWindow.removeEventListener('storage', fn) };\n\t}\n\n\tprivate stopListening(): void {\n\t\tthis.onDidChangeLocalStorageDisposable?.dispose();\n\t\tthis.onDidChangeLocalStorageDisposable = undefined;\n\t}\n\n\t// this fires every time local storage changes, but we\n\t// don't want to check more often than once a second\n\tprivate async onDidChangeLocalStorage(): Promise<void> {\n\t\tconst ellapsed = Date.now() - this.lastTimeChecked;\n\n\t\tif (ellapsed > 1000) {\n\t\t\tthis.checkCallbacks();\n\t\t} else if (this.checkCallbacksTimeout === undefined) {\n\t\t\tthis.checkCallbacksTimeout = setTimeout(() => {\n\t\t\t\tthis.checkCallbacksTimeout = undefined;\n\t\t\t\tthis.checkCallbacks();\n\t\t\t}, 1000 - ellapsed);\n\t\t}\n\t}\n\n\tprivate checkCallbacks(): void {\n\t\tlet pendingCallbacks: Set<number> | undefined;\n\n\t\tfor (const id of this.pendingCallbacks) {\n\t\t\tconst key = `vscode-web.url-callbacks[${id}]`;\n\t\t\tconst result = localStorage.getItem(key);\n\n\t\t\tif (result !== null) {\n\t\t\t\ttry {\n\t\t\t\t\tthis._onCallback.fire(URI.revive(JSON.parse(result)));\n\t\t\t\t} catch (error) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\n\t\t\t\tpendingCallbacks = pendingCallbacks ?? new Set(this.pendingCallbacks);\n\t\t\t\tpendingCallbacks.delete(id);\n\t\t\t\tlocalStorage.removeItem(key);\n\t\t\t}\n\t\t}\n\n\t\tif (pendingCallbacks) {\n\t\t\tthis.pendingCallbacks = pendingCallbacks;\n\n\t\t\tif (this.pendingCallbacks.size === 0) {\n\t\t\t\tthis.stopListening();\n\t\t\t}\n\t\t}\n\n\t\tthis.lastTimeChecked = Date.now();\n\t}\n}\n\nclass WorkspaceProvider implements IWorkspaceProvider {\n\n\tprivate static QUERY_PARAM_EMPTY_WINDOW = 'ew';\n\tprivate static QUERY_PARAM_FOLDER = 'folder';\n\tprivate static QUERY_PARAM_WORKSPACE = 'workspace';\n\n\tprivate static QUERY_PARAM_PAYLOAD = 'payload';\n\n\tstatic create(config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents }) {\n\t\tlet foundWorkspace = false;\n\t\tlet workspace: IWorkspace;\n\t\tlet payload = Object.create(null);\n\n\t\tconst query = new URL(document.location.href).searchParams;\n\t\tquery.forEach((value, key) => {\n\t\t\tswitch (key) {\n\n\t\t\t\t// Folder\n\t\t\t\tcase WorkspaceProvider.QUERY_PARAM_FOLDER:\n\t\t\t\t\tif (config.remoteAuthority && value.startsWith(posix.sep)) {\n\t\t\t\t\t\t// when connected to a remote and having a value\n\t\t\t\t\t\t// that is a path (begins with a `/`), assume this\n\t\t\t\t\t\t// is a vscode-remote resource as simplified URL.\n\t\t\t\t\t\tworkspace = { folderUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tworkspace = { folderUri: URI.parse(value) };\n\t\t\t\t\t}\n\t\t\t\t\tfoundWorkspace = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Workspace\n\t\t\t\tcase WorkspaceProvider.QUERY_PARAM_WORKSPACE:\n\t\t\t\t\tif (config.remoteAuthority && value.startsWith(posix.sep)) {\n\t\t\t\t\t\t// when connected to a remote and having a value\n\t\t\t\t\t\t// that is a path (begins with a `/`), assume this\n\t\t\t\t\t\t// is a vscode-remote resource as simplified URL.\n\t\t\t\t\t\tworkspace = { workspaceUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };\n\t\t\t\t\t} else {\n\t\t\t\t\t\tworkspace = { workspaceUri: URI.parse(value) };\n\t\t\t\t\t}\n\t\t\t\t\tfoundWorkspace = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Empty\n\t\t\t\tcase WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:\n\t\t\t\t\tworkspace = undefined;\n\t\t\t\t\tfoundWorkspace = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// Payload\n\t\t\t\tcase WorkspaceProvider.QUERY_PARAM_PAYLOAD:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpayload = parse(value); // use marshalling#parse() to revive potential URIs\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(error); // possible invalid JSON\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t});\n\n\t\t// If no workspace is provided through the URL, check for config\n\t\t// attribute from server\n\t\tif (!foundWorkspace) {\n\t\t\tif (config.folderUri) {\n\t\t\t\tworkspace = { folderUri: URI.revive(config.folderUri) };\n\t\t\t} else if (config.workspaceUri) {\n\t\t\t\tworkspace = { workspaceUri: URI.revive(config.workspaceUri) };\n\t\t\t}\n\t\t}\n\n\t\treturn new WorkspaceProvider(workspace, payload, config);\n\t}\n\n\treadonly trusted = true;\n\n\tprivate constructor(\n\t\treadonly workspace: IWorkspace,\n\t\treadonly payload: object,\n\t\tprivate readonly config: IWorkbenchConstructionOptions\n\t) {\n\t}\n\n\tasync open(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): Promise<boolean> {\n\t\tif (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {\n\t\t\treturn true; // return early if workspace and environment is not changing and we are reusing window\n\t\t}\n\n\t\tconst targetHref = this.createTargetUrl(workspace, options);\n\t\tif (targetHref) {\n\t\t\tif (options?.reuse) {\n\t\t\t\tmainWindow.location.href = targetHref;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tlet result;\n\t\t\t\tif (isStandalone()) {\n\t\t\t\t\tresult = mainWindow.open(targetHref, '_blank', 'toolbar=no'); // ensures to open another 'standalone' window!\n\t\t\t\t} else {\n\t\t\t\t\tresult = mainWindow.open(targetHref);\n\t\t\t\t}\n\n\t\t\t\treturn !!result;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate createTargetUrl(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): string | undefined {\n\n\t\t// Empty\n\t\tlet targetHref: string | undefined = undefined;\n\t\tif (!workspace) {\n\t\t\ttargetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;\n\t\t}\n\n\t\t// Folder\n\t\telse if (isFolderToOpen(workspace)) {\n\t\t\tconst queryParamFolder = this.encodeWorkspacePath(workspace.folderUri);\n\t\t\ttargetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${queryParamFolder}`;\n\t\t}\n\n\t\t// Workspace\n\t\telse if (isWorkspaceToOpen(workspace)) {\n\t\t\tconst queryParamWorkspace = this.encodeWorkspacePath(workspace.workspaceUri);\n\t\t\ttargetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${queryParamWorkspace}`;\n\t\t}\n\n\t\t// Append payload if any\n\t\tif (options?.payload) {\n\t\t\ttargetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;\n\t\t}\n\n\t\treturn targetHref;\n\t}\n\n\tprivate encodeWorkspacePath(uri: URI): string {\n\t\tif (this.config.remoteAuthority && uri.scheme === Schemas.vscodeRemote) {\n\n\t\t\t// when connected to a remote and having a folder\n\t\t\t// or workspace for that remote, only use the path\n\t\t\t// as query value to form shorter, nicer URLs.\n\t\t\t// however, we still need to `encodeURIComponent`\n\t\t\t// to ensure to preserve special characters, such\n\t\t\t// as `+` in the path.\n\n\t\t\treturn encodeURIComponent(`${posix.sep}${ltrim(uri.path, posix.sep)}`).replaceAll('%2F', '/');\n\t\t}\n\n\t\treturn encodeURIComponent(uri.toString(true));\n\t}\n\n\tprivate isSame(workspaceA: IWorkspace, workspaceB: IWorkspace): boolean {\n\t\tif (!workspaceA || !workspaceB) {\n\t\t\treturn workspaceA === workspaceB; // both empty\n\t\t}\n\n\t\tif (isFolderToOpen(workspaceA) && isFolderToOpen(workspaceB)) {\n\t\t\treturn isEqual(workspaceA.folderUri, workspaceB.folderUri); // same workspace\n\t\t}\n\n\t\tif (isWorkspaceToOpen(workspaceA) && isWorkspaceToOpen(workspaceB)) {\n\t\t\treturn isEqual(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace\n\t\t}\n\n\t\treturn false;\n\t}\n\n\thasRemote(): boolean {\n\t\tif (this.workspace) {\n\t\t\tif (isFolderToOpen(this.workspace)) {\n\t\t\t\treturn this.workspace.folderUri.scheme === Schemas.vscodeRemote;\n\t\t\t}\n\n\t\t\tif (isWorkspaceToOpen(this.workspace)) {\n\t\t\t\treturn this.workspace.workspaceUri.scheme === Schemas.vscodeRemote;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\n(function () {\n\n\t// Find config by checking for DOM\n\tconst configElement = mainWindow.document.getElementById('vscode-workbench-web-configuration');\n\tconst configElementAttribute = configElement ? configElement.getAttribute('data-settings') : undefined;\n\tif (!configElement || !configElementAttribute) {\n\t\tthrow new Error('Missing web configuration element');\n\t}\n\tconst config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents; callbackRoute: string } = { ...JSON.parse(configElementAttribute), remoteAuthority: location.host }\n\tconst secretStorageKeyPath = (window.location.pathname + \"/mint-key\").replace(/\\/\\/+/g, \"/\");\n\tconst secretStorageCrypto = secretStorageKeyPath && ServerKeyedAESCrypto.supported()\n\t\t? new ServerKeyedAESCrypto(secretStorageKeyPath) : new TransparentCrypto();\n\n\t// Create workbench\n\tcreate(mainWindow.document.body, {\n\t\t...config,\n\t\twindowIndicator: config.windowIndicator ?? { label: '$(remote)', tooltip: `${product.nameShort} Web` },\n\t\tsettingsSyncOptions: config.settingsSyncOptions ? { enabled: config.settingsSyncOptions.enabled, } : undefined,\n\t\tworkspaceProvider: WorkspaceProvider.create(config),\n\t\turlCallbackProvider: new LocalStorageURLCallbackProvider(config.callbackRoute),\n\t\tresolveExternalUri: (uri: URI): Promise<URI> => {\n\t\t\tlet resolvedUri = uri\n\t\t\tconst localhostMatch = extractLocalHostUriMetaDataForPortMapping(resolvedUri)\n\t\t\tif (localhostMatch && resolvedUri.authority !== location.host) {\n\t\t\t\tif (config.productConfiguration && config.productConfiguration.proxyEndpointTemplate) {\n\t\t\t\t\tconst renderedTemplate = config.productConfiguration.proxyEndpointTemplate\n\t\t\t\t\t\t.replace('{{port}}', localhostMatch.port.toString())\n\t\t\t\t\t\t.replace('{{host}}', window.location.host)\n\t\t\t\t\tresolvedUri = URI.parse(new URL(renderedTemplate, window.location.href).toString())\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(`Failed to resolve external URI: ${uri.toString()}. Could not determine base url because productConfiguration missing.`)\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If not localhost, return unmodified.\n\t\t\treturn Promise.resolve(resolvedUri)\n\t\t},\n\t\ttunnelProvider: {\n\t\t\ttunnelFactory: (tunnelOptions: TunnelOptions, tunnelCreationOptions: TunnelCreationOptions) => {\n\t\t\t\tconst onDidDispose: Emitter<void> = new Emitter();\n\t\t\t\tlet isDisposed = false;\n\t\t\t\treturn Promise.resolve({\n\t\t\t\t\tremoteAddress: tunnelOptions.remoteAddress,\n\t\t\t\t\tlocalAddress: `localhost:${tunnelOptions.remoteAddress.port}`,\n\t\t\t\t\tonDidDispose: onDidDispose.event,\n\t\t\t\t\tdispose: () => {\n\t\t\t\t\t\tif (!isDisposed) {\n\t\t\t\t\t\t\tisDisposed = true;\n\t\t\t\t\t\t\tonDidDispose.fire();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t},\n\t\tsecretStorageProvider: config.remoteAuthority && !secretStorageKeyPath\n\t\t\t? undefined /* with a remote without embedder-preferred storage, store on the remote */\n\t\t\t: new LocalStorageSecretStorageProvider(secretStorageCrypto),\n\t});\n})();\n"],"mappings":"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","names":["__m","__M","deps","result","i","len","TransparentCrypto","data","AESConstants","ServerKeyedAESCrypto","b","iv","window_1","clientKeyObj","clientKey","key","dataUint8Array","cipherText","buffer_1","keyLength","decrypted","serverKey","keyData","attempt","lastError","res","e","resolve","LocalStorageSecretStorageProvider","c","record","encrypted","err","authSessionInfo","authSessionElement","authSessionElementAttribute","product_1","authAccount","scopes","value","secrets","exports","LocalStorageURLCallbackProvider","lifecycle_1","m","event_1","options","id","queryParams","path","uri_1","fn","ellapsed","pendingCallbacks","error","WorkspaceProvider","config","foundWorkspace","workspace","payload","path_1","network_1","marshalling_1","f","targetHref","browser_1","window_2","queryParamFolder","queryParamWorkspace","uri","strings_1","workspaceA","workspaceB","resources_1","configElement","configElementAttribute","secretStorageKeyPath","secretStorageCrypto","workbench_web_main_1","resolvedUri","localhostMatch","tunnel_1","renderedTemplate","tunnelOptions","tunnelCreationOptions","onDidDispose","isDisposed"],"file":"workbench.js"}